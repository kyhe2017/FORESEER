var tipuesearch = {"pages":[{"text":"FORESEER FORESEER FORESEER, FOrtran RiEmann SolvErs EnviRonment A KISS pure Fortran Library providing a large set of Riemann Solvers: FORESEER is a pure Fortran (KISS) library for solving Riemann problems (1D); FORESEER is Fortran 2008+ standard compliant; FORESEER is OOP designed; FORESEER is TDD developed; FORESEER is a Free, Open Source Project. A taste of FORESEER use foreseer type ( riemann_solver ) :: rsolver call rsolver % initialize ( solver = 'hllc' , input_type = 'conservative' ) call rsolver % solve ( left = U_left , right = U_right , interface = U_interface ) To be completed. Issues Compiler Support What is FORESEER? | Main features | Copyrights | Download | Compilation | Documentation | References What is FORESEER? FORESEER is a modern Fortran library providing a large set of Riemann Solvers. To be completed. How to use To be written. Go to Top Main features To be written. Any feature request is welcome. Go to Top Copyrights HASTY is a Free and Open Source Software (FOSS), it is distributed under a very permissive multi-licensing system: selectable licenses are GPLv3 , BSD2-Clause , BSD3-Clause and MIT , feel free to select the license that best matches your workflow. Anyone is interest to use, to develop or to contribute to HASTY is welcome. More details can be found on wiki . Go to Top Download To be written. Go to Top Compilation To be written. Documentation Besides this README file the FORESEER documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FORESEER "},{"text":"Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_llf.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_riemann_solver_compressible_llff90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_llff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_llf.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefileforeseer_riemann_solver_compressible_llff90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_llff90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_llf Source Code foreseer_riemann_solver_compressible_llf.F90 Source Code !< Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_llf !< Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_llf type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf !< Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_llf contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. call self % solver_pvl % initialize ( config = 'u23' ) endsubroutine initialize subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( conservative_compressible ) :: fluxes_left !< Fluxes of left state. type ( conservative_compressible ) :: fluxes_right !< Fluxes of right state. type ( conservative_compressible ) :: fluxes_ !< Fluxes, local variable. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: lmax !< Maximum wave speed estimation. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) lmax = maxval ( abs ( waves )) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) select type ( fluxes ) type is ( conservative_compressible ) #ifdef __GFORTRAN__ fluxes = 0.5_R8P * ( fluxes_left + fluxes_right - ( lmax * ( state_right_ - state_left_ ))) #else ! Intel Fortran has issue in resolving the equation with multiple operators... it must be split fluxes_ = state_right_ - state_left_ fluxes_ = lmax * fluxes_ fluxes = fluxes_left + fluxes_right fluxes = fluxes - fluxes_ fluxes = 0.5_R8P * fluxes #endif endselect endsubroutine solve endmodule foreseer_riemann_solver_compressible_llf","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_llf.f90.html","title":"foreseer_riemann_solver_compressible_llf.F90 – FORESEER"},{"text":"Define the Primitive Variables Linearization based Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_pvl.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_riemann_solver_compressible_pvlf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_pvlf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_pvl.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefileforeseer_riemann_solver_compressible_pvlf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_pvlf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_pvl Source Code foreseer_riemann_solver_compressible_pvl.f90 Source Code !< Define the Primitive Variables Linearization based Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_pvl !< Define the Primitive Variables Linearization based Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : I4P , R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_pvl type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl !< Primitive Variables Linearization based Riemann solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. procedure ( compute_waves_interface ), pointer :: compute_waves_ => compute_waves_up23 !< Compute waves pattern procedure ( solve_interface ), pointer :: solve_ => solve_up23 !< Solve Riemann problem. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. ! private methods procedure , pass ( self ), private :: compute_p23 !< Compute interstates pressure. procedure , pass ( self ), private :: compute_u23 !< Compute interstates velocity. procedure , pass ( self ), private :: compute_up23 !< Compute interstates velocity and pressure. procedure , pass ( self ), private :: compute_waves_u23 !< Compute waves speed by `u23` algorithm. procedure , pass ( self ), private :: compute_waves_up23 !< Compute waves speed by `up23` algorithm. procedure , pass ( self ), private :: solve_u23 !< Compute whole pattern by `u23` algorithm. procedure , pass ( self ), private :: solve_up23 !< Compute whole pattern by `up23` algorithm. endtype riemann_solver_compressible_pvl abstract interface pure subroutine compute_waves_interface ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. import :: conservative_object , eos_object , riemann_solver_compressible_pvl , R8P , vector class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. endsubroutine compute_waves_interface pure subroutine solve_interface ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem. import :: conservative_object , eos_object , riemann_solver_compressible_pvl , vector class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. endsubroutine solve_interface endinterface contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % compute_waves_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves pure subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. call self % solve_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , fluxes = fluxes ) endsubroutine solve subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local var. self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 config_ = '' ; if ( present ( config )) config_ = config select case ( config_ ) case ( 'u23' ) self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 case ( 'up23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 case ( 'upr23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 endselect endsubroutine initialize ! private methods elemental subroutine compute_p23 ( self ) !< Compute interstates pressure. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. self % p23 = 0.5_R8P * (( self % p_1 + self % p_4 ) - 0.25_R8P * ( self % u_4 - self % u_1 ) * ( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 )) endsubroutine compute_p23 elemental subroutine compute_u23 ( self ) !< Compute interstates velocity. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. self % u23 = 0.5_R8P * ( self % u_1 + self % u_4 ) - 2.0_R8P * ( self % p_4 - self % p_1 ) / (( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 )) endsubroutine compute_u23 elemental subroutine compute_up23 ( self ) !< Compute interstates velocity and pressure. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. real ( R8P ) :: ram !< Mean value of `r * a`. ram = 0.25_R8P * ( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 ) self % u23 = 0.5_R8P * (( self % u_1 + self % u_4 ) - ( self % p_4 - self % p_1 ) / ram ) self % p23 = 0.5_R8P * (( self % p_1 + self % p_4 ) - ( self % u_4 - self % u_1 ) * ram ) endsubroutine compute_up23 pure subroutine compute_waves_u23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. real ( R8P ) :: x !< Dummy variable. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_u23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock x = 0.25_R8P * ( self % g_1 + 1._R8P ) * ( self % u23 - self % u_1 ) / self % a_1 self % s_1 = self % u_1 + self % a_1 * ( x - sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock x = 0.25_R8P * ( self % g_4 + 1._R8P ) * ( self % u23 - self % u_4 ) / self % a_4 self % s_4 = self % u_4 + self % a_4 * ( x + sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_u23 pure subroutine compute_waves_up23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_up23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock self % s_1 = self % u_1 - self % a_1 * sqrt ( 1._R8P + 0.5_R8P * ( self % g_1 + 1._R8P ) / self % g_1 * ( self % p23 / self % p_1 - 1._R8P )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock self % s_4 = self % u_4 + self % a_4 * sqrt ( 1._R8P + 0.5_R8P * ( self % g_4 + 1._R8P ) / self % g_4 * ( self % p23 / self % p_4 - 1._R8P )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_up23 pure subroutine solve_u23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem by `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_u23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_u23 pure subroutine solve_up23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem `up23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Riemann pattern. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_up23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_up23 endmodule foreseer_riemann_solver_compressible_pvl","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_pvl.f90.html","title":"foreseer_riemann_solver_compressible_pvl.f90 – FORESEER"},{"text":"Define compressible variables transformations of FORESEER library. This File Depends On sourcefile~~foreseer_compressible_transformations.f90~~EfferentGraph sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_compressible_transformationsf90EfferentGraph = svgPanZoom('#sourcefileforeseer_compressible_transformationsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_compressible_transformations.f90~~AfferentGraph sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_compressible_transformations Source Code foreseer_compressible_transformations.f90 Source Code !< Define compressible variables transformations of FORESEER library. module foreseer_compressible_transformations !< Define compressible variables transformations of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible use foreseer_primitive_compressible , only : primitive_compressible use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: conservative_to_primitive_compressible public :: primitive_to_conservative_compressible contains ! public procedures elemental function conservative_to_primitive_compressible ( conservative , eos ) result ( primitive_ ) !< Return a [[primitive_compressible]] state transforming a given [[conservative_compressible]] state. type ( conservative_compressible ), intent ( in ) :: conservative !< Conservative state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( primitive_compressible ) :: primitive_ !< Primitive state. primitive_ % density = conservative % density primitive_ % velocity = conservative % velocity () primitive_ % pressure = conservative % pressure ( eos = eos ) endfunction conservative_to_primitive_compressible elemental function primitive_to_conservative_compressible ( primitive , eos ) result ( conservative_ ) !< Return a [[conservative_compressible]] state transforming a given [[primitive_compressible]] state. type ( primitive_compressible ), intent ( in ) :: primitive !< Primitive state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( conservative_compressible ) :: conservative_ !< Conservative state. conservative_ % density = primitive % density conservative_ % momentum = primitive % momentum () conservative_ % energy = primitive % energy ( eos = eos ) endfunction primitive_to_conservative_compressible endmodule foreseer_compressible_transformations","tags":"","loc":"sourcefile/foreseer_compressible_transformations.f90.html","title":"foreseer_compressible_transformations.f90 – FORESEER"},{"text":"Define the abstract Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_object.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_riemann_solver_objectf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_object.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 var pansourcefileforeseer_riemann_solver_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_object Source Code foreseer_riemann_solver_object.f90 Source Code !< Define the abstract Riemann solver of FORESEER library. module foreseer_riemann_solver_object !< Define the abstract Riemann solver of FORESEER library. use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: riemann_solver_object type , abstract :: riemann_solver_object !< Abstract Riemann Solver. contains ! public deferred methods procedure ( compute_waves_interface ), pass ( self ), deferred :: compute_waves !< Compute waves pattern. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize solver. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( solve_interface ), pass ( self ), deferred :: solve !< Solve Riemann Problem. endtype riemann_solver_object abstract interface !< Abstract interfaces of [[riemann_solver_object]] deferred methods. pure subroutine compute_waves_interface ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< This compute only the waves pattern, not the fluxes: this is useful for building solvers being hybrid of other solvers. import :: conservative_object , eos_object , riemann_solver_object , R8P , vector class ( riemann_solver_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. endsubroutine compute_waves_interface subroutine initialize_interface ( self , config ) !< Initialize solver. import :: riemann_solver_object class ( riemann_solver_object ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. endsubroutine initialize_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: riemann_solver_object class ( riemann_solver_object ), intent ( in ) :: self !< Solver. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface subroutine solve_interface ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. import :: conservative_object , eos_object , riemann_solver_object , vector class ( riemann_solver_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. endsubroutine solve_interface endinterface endmodule foreseer_riemann_solver_object","tags":"","loc":"sourcefile/foreseer_riemann_solver_object.f90.html","title":"foreseer_riemann_solver_object.f90 – FORESEER"},{"text":"Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. This File Depends On sourcefile~~foreseer_eos_compressible.f90~~EfferentGraph sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_eos_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_eos_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_eos_compressible.f90~~AfferentGraph sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_eos_compressible Source Code foreseer_eos_compressible.f90 Source Code !< Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. module foreseer_eos_compressible !< Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. use foreseer_eos_object , only : eos_object use penf , only : R8P implicit none private public :: eos_compressible type , extends ( eos_object ) :: eos_compressible !< Equation of state (EOS) of ideal compressible object class. private real ( R8P ) :: cp_ = 0._R8P !< Specific heat at constant pressure `cp`. real ( R8P ) :: cv_ = 0._R8P !< Specific heat at constant volume `cv`. contains ! deferred methods procedure , pass ( self ) :: cp !< Return specific heat at constant pressure. procedure , pass ( self ) :: cv !< Return specific heat at constant volume. procedure , pass ( self ) :: density !< Return density. procedure , pass ( self ) :: energy !< Return specific internal energy. procedure , pass ( self ) :: gam !< Return specific heats ratio `gamma=cp/cv`. procedure , pass ( self ) :: pressure !< Return pressure. procedure , pass ( self ) :: R !< Return fluid constant `R=cp-cv`. procedure , pass ( self ) :: speed_of_sound !< Return speed of sound. procedure , pass ( self ) :: temperature !< Return temperature. endtype eos_compressible interface eos_compressible !< Overload [[eos_compressible]] name with its constructor. module procedure eos_compressible_instance endinterface contains ! deferred methods elemental function cp ( self ) result ( cp_ ) !< Return specific heat at constant pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. cp_ = self % cp_ endfunction cp elemental function cv ( self ) result ( cv_ ) !< Return specific heat at constant volume. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. cv_ = self % cv_ endfunction cv elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % gam () - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % gam () * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R () * temperature ) endif endfunction density elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % gam () - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy elemental function gam ( self ) result ( gam_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gam_ !< Specific heats ratio value. gam_ = self % cp_ / self % cv_ endfunction gam elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % gam () - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R () * temperature endif endfunction pressure elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % cp_ - self % cv_ endfunction R elemental function speed_of_sound ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. speed_of_sound_ = sqrt ( self % gam () * pressure / density ) endfunction speed_of_sound elemental function temperature ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. temperature_ = 0._R8P if ( present ( density ). and . present ( pressure )) then temperature_ = pressure / ( self % R () * density ) elseif ( present ( energy )) then temperature_ = energy / self % cv () endif endfunction temperature ! private non TBP elemental function eos_compressible_instance ( cp , cv , gam , R ) result ( instance ) !< Return and instance of [[eos_compressible]]. !< !< @note This procedure is used for overloading [[eos_compressible]] name. real ( R8P ), intent ( in ), optional :: cp !< Specific heat at constant pressure `cp` value. real ( R8P ), intent ( in ), optional :: cv !< Specific heat at constant volume `cv` value. real ( R8P ), intent ( in ), optional :: gam !< Specific heats ratio `gamma=cp/cv` value. real ( R8P ), intent ( in ), optional :: R !< Fluid constant `R=cp-cv` value. type ( eos_compressible ) :: instance !< Instance of [[eos_compressible]]. if ( present ( cp ). and . present ( cv )) then instance % cp_ = cp instance % cv_ = cv elseif ( present ( gam ). and . present ( R )) then instance % cv_ = R / ( gam - 1._R8P ) instance % cp_ = gam * instance % cv_ elseif ( present ( gam ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp / gam elseif ( present ( gam ). and . present ( cv )) then instance % cp_ = gam * cv instance % cv_ = cv elseif ( present ( R ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp - R elseif ( present ( R ). and . present ( cv )) then instance % cp_ = cv + R instance % cv_ = cv endif endfunction eos_compressible_instance endmodule foreseer_eos_compressible","tags":"","loc":"sourcefile/foreseer_eos_compressible.f90.html","title":"foreseer_eos_compressible.f90 – FORESEER"},{"text":"Define the abstract equation of state (EOS) for FORESEER library. This File Depends On sourcefile~~foreseer_eos_object.f90~~EfferentGraph sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_eos_objectf90EfferentGraph = svgPanZoom('#sourcefileforeseer_eos_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_eos_object.f90~~AfferentGraph sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 var pansourcefileforeseer_eos_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_eos_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_eos_object Source Code foreseer_eos_object.f90 Source Code !< Define the abstract equation of state (EOS) for FORESEER library. module foreseer_eos_object !< Define the abstract equation of state (EOS) for FORESEER library. use penf , only : R8P implicit none private public :: eos_object type , abstract :: eos_object !< Equation of State (EOS) object class. contains ! deferred methods procedure ( cp_interface ), pass ( self ), deferred :: cp !< Return specific heat at constant pressure. procedure ( cv_interface ), pass ( self ), deferred :: cv !< Return specific heat at constant volume. procedure ( density_interface ), pass ( self ), deferred :: density !< Return density. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return specific internal energy. procedure ( gam_interface ), pass ( self ), deferred :: gam !< Return specific heats ratio `gamma=cp/cv`. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure. procedure ( R_interface ), pass ( self ), deferred :: R !< Return fluid constant `R=cp-cv`. procedure ( speed_of_sound_interface ), pass ( self ), deferred :: speed_of_sound !< Return speed of sound. procedure ( temperature_interface ), pass ( self ), deferred :: temperature !< Return temperature. endtype eos_object abstract interface !< Abstract interfaces of deferred methods of [[eos_object]]. elemental function cp_interface ( self ) result ( cp_ ) !< Return specific heat at constant pressure. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. endfunction cp_interface elemental function cv_interface ( self ) result ( cv_ ) !< Return specific heat at constant volume. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. endfunction cv_interface elemental function density_interface ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. endfunction density_interface elemental function energy_interface ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. endfunction energy_interface elemental function gam_interface ( self ) result ( gam_ ) !< Return specific heats ratio `gamma=cp/cv`. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gam_ !< Specific heats ratio value. endfunction gam_interface elemental function pressure_interface ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. endfunction pressure_interface elemental function R_interface ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. endfunction R_interface elemental function speed_of_sound_interface ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. endfunction speed_of_sound_interface elemental function temperature_interface ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. endfunction temperature_interface endinterface endmodule foreseer_eos_object","tags":"","loc":"sourcefile/foreseer_eos_object.f90.html","title":"foreseer_eos_object.f90 – FORESEER"},{"text":"Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_primitive_compressible.f90~~EfferentGraph sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_primitive_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_primitive_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_primitive_compressible.f90~~AfferentGraph sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefileforeseer_primitive_compressiblef90AfferentGraph = svgPanZoom('#sourcefileforeseer_primitive_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_primitive_compressible Source Code foreseer_primitive_compressible.f90 Source Code !< Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. module foreseer_primitive_compressible !< Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foreseer_primitive_object , only : primitive_object use foreseer_eos_object , only : eos_object use penf , only : R8P , str use vecfor , only : vector implicit none private public :: primitive_compressible public :: primitive_compressible_pointer type , extends ( primitive_object ) :: primitive_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. contains ! public methods procedure , pass ( self ) :: left_eigenvectors !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. procedure , pass ( self ) :: right_eigenvectors !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of primitive. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. procedure , pass ( lhs ) :: prim_assign_prim !< Operator `=`. procedure , pass ( lhs ) :: prim_divide_real !< Operator `prim / real`. procedure , pass ( lhs ) :: prim_multiply_real !< Operator `prim * real`. procedure , pass ( lhs ) :: prim_multiply_prim !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_prim !< Operator `real * prim`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ prim`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- prim`. endtype primitive_compressible interface primitive_compressible !< Overload [[primitive_compressible]] name with its constructor. module procedure primitive_compressible_instance endinterface contains ! public non TBP function primitive_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[primitive_compressible]] pointer associated to [[primitive_object]] or its extensions until !< [[primitive_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( primitive_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( primitive_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( primitive_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast primitive_object to primitive_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction primitive_compressible_pointer ! public methods pure function left_eigenvectors ( self , eos ) result ( eig ) !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_a !< `g*p/a`. gp = eos % gam () * self % pressure gp_a = gp / eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0._R8P ; eig ( 1 , 2 ) = - gp_a ; eig ( 1 , 3 ) = 1._R8P eig ( 2 , 1 ) = gp / self % density ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - 1._R8P eig ( 3 , 1 ) = 0._R8P ; eig ( 3 , 2 ) = gp_a ; eig ( 3 , 3 ) = 1._R8P endfunction left_eigenvectors pure function right_eigenvectors ( self , eos ) result ( eig ) !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_inv !< `1/(g*p)`. real ( R8P ) :: a !< Speed of sound, `sqrt(g*p/r)`. gp = eos % gam () * self % pressure gp_inv = 1._R8P / gp a = eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0.5_R8P * self % density * gp_inv ; eig ( 1 , 2 ) = self % density * gp_inv ; eig ( 1 , 3 ) = eig ( 1 , 1 ) eig ( 2 , 1 ) = - 0.5_R8P * a * gp_inv ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - eig ( 2 , 1 ) eig ( 3 , 1 ) = 0.5_R8P ; eig ( 3 , 2 ) = 0._R8P ; eig ( 3 , 3 ) = eig ( 3 , 1 ) endfunction right_eigenvectors ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of primitive. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of primitive. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endfunction array pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endfunction description elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % gam () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum ! operators pure subroutine prim_assign_prim ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure endselect endsubroutine prim_assign_prim function prim_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim / real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density / rhs operator_result % velocity = lhs % velocity / rhs operator_result % pressure = lhs % pressure / rhs endselect endfunction prim_divide_real function prim_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim * real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs operator_result % velocity = lhs % velocity * rhs operator_result % pressure = lhs % pressure * rhs endselect endfunction prim_multiply_real function real_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `real * prim`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs * rhs % density operator_result % velocity = lhs * rhs % velocity operator_result % pressure = lhs * rhs % pressure endselect endfunction real_multiply_prim function prim_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs % density operator_result % velocity = lhs % velocity * rhs % velocity operator_result % pressure = lhs % pressure * rhs % pressure endselect endselect endfunction prim_multiply_prim function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density + rhs % density operator_result % velocity = lhs % velocity + rhs % velocity operator_result % pressure = lhs % pressure + rhs % pressure endselect endselect endfunction add function positive ( self ) result ( operator_result ) !< Unary operator `+ prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = + self % density operator_result % velocity = + self % velocity operator_result % pressure = + self % pressure endselect endfunction positive function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density - rhs % density operator_result % velocity = lhs % velocity - rhs % velocity operator_result % pressure = lhs % pressure - rhs % pressure endselect endselect endfunction sub function negative ( self ) result ( operator_result ) !< Unary operator `- prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = - self % density operator_result % velocity = - self % velocity operator_result % pressure = - self % pressure endselect endfunction negative ! private non TBP elemental function primitive_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[primitive_compressible]]. !< !< @note This procedure is used for overloading [[primitive_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: velocity !< Velocity, `v`. real ( R8P ), intent ( in ), optional :: pressure !< Pressure, `p`. type ( primitive_compressible ) :: instance !< Instance of [[primitive_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure endfunction primitive_compressible_instance endmodule foreseer_primitive_compressible","tags":"","loc":"sourcefile/foreseer_primitive_compressible.f90.html","title":"foreseer_primitive_compressible.f90 – FORESEER"},{"text":"Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_conservative_compressible.f90~~EfferentGraph sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_conservative_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_conservative_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_conservative_compressible.f90~~AfferentGraph sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_conservative_compressiblef90AfferentGraph = svgPanZoom('#sourcefileforeseer_conservative_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_conservative_compressible Source Code foreseer_conservative_compressible.f90 Source Code !< Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. module foreseer_conservative_compressible !< Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use penf , only : R8P , str use vecfor , only : vector implicit none private public :: conservative_compressible public :: conservative_compressible_pointer type , extends ( conservative_object ) :: conservative_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ) :: energy = 0._R8P !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. contains ! public methods procedure , pass ( self ) :: compute_fluxes_from_primitive !< Compute conservative fluxes from primitives at interface. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of conservative. procedure , pass ( self ) :: compute_fluxes !< Compute conservative fluxes. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy conservative. procedure , pass ( self ) :: initialize !< Initialize conservative. procedure , pass ( self ) :: pressure !< Return pressure value. procedure , pass ( self ) :: velocity !< Return velocity vector. procedure , pass ( lhs ) :: cons_assign_cons !< Operator `=`. procedure , pass ( lhs ) :: cons_divide_real !< Operator `cons / real`. procedure , pass ( lhs ) :: cons_multiply_real !< Operator `cons * real`. procedure , pass ( lhs ) :: cons_multiply_cons !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_cons !< Operator `real * cons`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ cons`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- cons`. endtype conservative_compressible interface conservative_compressible !< Overload [[conservative_compressible]] name with its constructor. module procedure conservative_compressible_instance endinterface contains ! public non TBP function conservative_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( conservative_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( conservative_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( conservative_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast conservative_object to conservative_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction conservative_compressible_pointer ! public methods elemental subroutine compute_fluxes_from_primitive ( self , eos , p , r , u , normal ) !< Compute conservative fluxes from primitives at interface. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: p !< Pressure at interface. real ( R8P ), intent ( in ) :: r !< Density at interface. real ( R8P ), intent ( in ) :: u !< Velocity (normal component) at interface. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. self % density = r * u self % momentum = ( r * u * u + p ) * normal self % energy = ( r * eos % energy ( density = r , pressure = p ) + r * u * u * 0.5_R8P + p ) * u endsubroutine compute_fluxes_from_primitive ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of conservative. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of conservative. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % momentum % x array_ ( 3 ) = self % momentum % y array_ ( 4 ) = self % momentum % z array_ ( 5 ) = self % energy endfunction array subroutine compute_fluxes ( self , eos , normal , fluxes ) !< Compute conservative fluxes. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. real ( R8P ) :: velocity_normal_ !< Velocity component parallel to given normal. select type ( fluxes ) class is ( conservative_compressible ) pressure_ = self % pressure ( eos = eos ) velocity_ = self % velocity () velocity_normal_ = velocity_ . dot . normal fluxes % density = self % momentum . dot . normal fluxes % momentum = self % density * velocity_ * velocity_normal_ + pressure_ * normal fluxes % energy = ( self % energy + pressure_ ) * velocity_normal_ endselect endsubroutine compute_fluxes pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'momentum = ' // trim ( str ( n = [ self % momentum % x , self % momentum % y , self % momentum % z ])) // NL desc = desc // prefix_ // 'energy   = ' // trim ( str ( n = self % energy )) endfunction description elemental subroutine destroy ( self ) !< Destroy conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. type ( conservative_compressible ) :: fresh !< Fresh instance of conservative object. self = fresh endsubroutine destroy subroutine initialize ( self , initial_state ) !< Initialize conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( conservative_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( conservative_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize elemental function pressure ( self , eos ) result ( pressure_ ) !< Return pressure value. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % velocity () pressure_ = ( eos % gam () - 1._R8P ) * ( self % energy - 0.5_R8P * self % density * velocity_ % sq_norm ()) endfunction pressure elemental function velocity ( self ) result ( velocity_ ) !< Return velocity vector. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % momentum / self % density endfunction velocity ! operators pure subroutine cons_assign_cons ( lhs , rhs ) !< Operator `=`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( conservative_compressible ) lhs % density = rhs % density lhs % momentum = rhs % momentum lhs % energy = rhs % energy endselect endsubroutine cons_assign_cons function cons_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons / real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density / rhs operator_result % momentum = lhs % momentum / rhs operator_result % energy = lhs % energy / rhs endselect endfunction cons_divide_real function cons_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons * real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs operator_result % momentum = lhs % momentum * rhs operator_result % energy = lhs % energy * rhs endselect endfunction cons_multiply_real function real_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `real * cons`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs * rhs % density operator_result % momentum = lhs * rhs % momentum operator_result % energy = lhs * rhs % energy endselect endfunction real_multiply_cons function cons_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs % density operator_result % momentum = lhs % momentum * rhs % momentum operator_result % energy = lhs % energy * rhs % energy endselect endselect endfunction cons_multiply_cons function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density + rhs % density operator_result % momentum = lhs % momentum + rhs % momentum operator_result % energy = lhs % energy + rhs % energy endselect endselect endfunction add function positive ( self ) result ( operator_result ) !< Unary operator `+ cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = + self % density operator_result % momentum = + self % momentum operator_result % energy = + self % energy endselect endfunction positive function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density - rhs % density operator_result % momentum = lhs % momentum - rhs % momentum operator_result % energy = lhs % energy - rhs % energy endselect endselect endfunction sub function negative ( self ) result ( operator_result ) !< Unary operator `- cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = - self % density operator_result % momentum = - self % momentum operator_result % energy = - self % energy endselect endfunction negative ! private non TBP elemental function conservative_compressible_instance ( density , momentum , energy ) result ( instance ) !< Return and instance of [[conservative_compressible]]. !< !< @note This procedure is used for overloading [[conservative_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ), intent ( in ), optional :: energy !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. type ( conservative_compressible ) :: instance !< Instance of [[conservative_compressible]]. if ( present ( density )) instance % density = density if ( present ( momentum )) instance % momentum = momentum if ( present ( energy )) instance % energy = energy endfunction conservative_compressible_instance endmodule foreseer_conservative_compressible","tags":"","loc":"sourcefile/foreseer_conservative_compressible.f90.html","title":"foreseer_conservative_compressible.f90 – FORESEER"},{"text":"Define the abstract conservative state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_conservative_object.f90~~EfferentGraph sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_conservative_objectf90EfferentGraph = svgPanZoom('#sourcefileforeseer_conservative_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_conservative_object.f90~~AfferentGraph sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_conservative_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_conservative_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_conservative_object Source Code foreseer_conservative_object.f90 Source Code !< Define the abstract conservative state of a Riemann Problem for FORESEER library. module foreseer_conservative_object !< Define the abstract conservative state of a Riemann Problem for FORESEER library. use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: conservative_object type , abstract :: conservative_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of conservative. procedure ( compute_fluxes_interface ), pass ( self ), deferred :: compute_fluxes !< Compute conservative fluxes. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy conservative. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize conservative. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure value. procedure ( velocity_interface ), pass ( self ), deferred :: velocity !< Return velocity vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: cons_assign_cons !< Operator `=`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_divide_real !< Operator `cons / real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: cons_multiply_cons !< Operator `*`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_multiply_real !< Operator `cons * real`. procedure ( real_operator_cons ), pass ( rhs ), deferred :: real_multiply_cons !< Operator `real * cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- cons`. ! operators generic :: assignment ( = ) => cons_assign_cons !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => cons_multiply_cons , cons_multiply_real , real_multiply_cons !< Overload `*`. generic :: operator ( / ) => cons_divide_real !< Overload `/`. endtype conservative_object abstract interface !< Abstract interfaces of deferred methods of [[conservative_object]]. pure function array_interface ( self ) result ( array_ ) !< Return serialized array of conservative. import :: conservative_object , R8P class ( conservative_object ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of conservative. endfunction array_interface subroutine compute_fluxes_interface ( self , eos , normal , fluxes ) !< Compute conservative fluxes. import :: conservative_object , eos_object , vector class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. endsubroutine compute_fluxes_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: conservative_object class ( conservative_object ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental subroutine destroy_interface ( self ) !< Destroy conservative. import :: conservative_object class ( conservative_object ), intent ( inout ) :: self !< Conservative. endsubroutine destroy_interface subroutine initialize_interface ( self , initial_state ) !< Initialize conservative. import :: conservative_object class ( conservative_object ), intent ( inout ) :: self !< Conservative. class ( conservative_object ), optional , intent ( in ) :: initial_state !< Initial state. endsubroutine initialize_interface elemental function pressure_interface ( self , eos ) result ( pressure_ ) !< Return pressure value. import :: conservative_object , eos_object , R8P class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. endfunction pressure_interface elemental function velocity_interface ( self ) result ( velocity_ ) !< Return velocity vector. import :: conservative_object , vector class ( conservative_object ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. endfunction velocity_interface pure subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: conservative_object class ( conservative_object ), intent ( inout ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface function cons_operator_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons.op.real`. import :: conservative_object , R8P class ( conservative_object ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction cons_operator_real function real_operator_cons ( lhs , rhs ) result ( operator_result ) !< Operator `real.op.cons`. import :: conservative_object , R8P real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction real_operator_cons function symmetric_operator ( lhs , rhs ) result ( operator_result ) !< Symmetric operator `cons.op.cons`. import :: conservative_object class ( conservative_object ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction symmetric_operator function unary_operator ( self ) result ( operator_result ) !< Unary operator `.op.cons`. import :: conservative_object class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction unary_operator endinterface endmodule foreseer_conservative_object","tags":"","loc":"sourcefile/foreseer_conservative_object.f90.html","title":"foreseer_conservative_object.f90 – FORESEER"},{"text":"FORESEER, FOrtran RiEmann SolvErs EnviRonment. This File Depends On sourcefile~~foreseer.f90~~EfferentGraph sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseerf90EfferentGraph = svgPanZoom('#sourcefileforeseerf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer.f90~~AfferentGraph sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer Source Code foreseer.f90 Source Code !< FORESEER, FOrtran RiEmann SolvErs EnviRonment. module foreseer !< FORESEER, FOrtran RiEmann SolvErs EnviRonment. use foreseer_compressible_transformations , only : conservative_to_primitive_compressible , primitive_to_conservative_compressible use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_compressible , only : eos_compressible use foreseer_eos_object , only : eos_object use foreseer_primitive_compressible , only : primitive_compressible , primitive_compressible_pointer use foreseer_primitive_object , only : primitive_object use foreseer_riemann_solver_compressible_llf , only : riemann_solver_compressible_llf use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_object , only : riemann_solver_object implicit none private public :: conservative_to_primitive_compressible , primitive_to_conservative_compressible public :: conservative_compressible , conservative_compressible_pointer public :: conservative_object public :: eos_compressible public :: eos_object public :: primitive_compressible public :: primitive_object public :: riemann_solver_compressible_llf public :: riemann_solver_compressible_object public :: riemann_solver_compressible_pvl public :: riemann_solver_object endmodule foreseer","tags":"","loc":"sourcefile/foreseer.f90.html","title":"foreseer.f90 – FORESEER"},{"text":"Define the Riemann solver for ideal compressible fluid for FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_object.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_riemann_solver_compressible_objectf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_object.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 var pansourcefileforeseer_riemann_solver_compressible_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_object Source Code foreseer_riemann_solver_compressible_object.f90 Source Code !< Define the Riemann solver for ideal compressible fluid for FORESEER library. module foreseer_riemann_solver_compressible_object !< Define the Riemann solver for ideal compressible fluid for FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : R8P , str use vecfor , only : vector implicit none private public :: riemann_solver_compressible_object type , extends ( riemann_solver_object ), abstract :: riemann_solver_compressible_object !< Riemann solver for ideal compressible fluid object class. !< !< The ideal compressible fluid generates a 3-waves pattern: 2 genuinely non-linear acoustic waves and 1 !< linear-degener contact discontinuity. !< !<``` !<   t &#94;                                . !<     |     S1 _       S2 _            .      _ S       _ S3       _ S4 !<     |       |\\_        |\\_           .      /|      __/|       __/| !<     |          \\__        \\_     U2  .     /  U3  _/       ___/ !<     |             \\___      \\_       .    /    __/     ___/ !<     |                 \\____   \\_     .   /   _/    ___/ !<     |                      \\___ \\_   .  / __/  ___/ !<     |          UL=U1           \\__\\_ . /_/____/          UR=U4 !<     |                              \\\\./// !<  ---+--------------------------------o---------------------------------> !<     |                                xo                                x !<``` real ( R8P ) :: g_1 = 0._R8P !< Specific heats ratio `gamma=cp/cv` of state 1. real ( R8P ) :: d_1 = 0._R8P !< `(gamma-1)/2` of state 1. real ( R8P ) :: e_1 = 0._R8P !< `2*g/(g-1)` of state 1. real ( R8P ) :: u_1 = 0._R8P !< Velocity (normal) of state 1. real ( R8P ) :: p_1 = 0._R8P !< Pressure of state 1. real ( R8P ) :: r_1 = 0._R8P !< Density of state 1. real ( R8P ) :: a_1 = 0._R8P !< Speed of sound of state 1. real ( R8P ) :: g_4 = 0._R8P !< Specific heats ratio `gamma=cp/cv` of state 4. real ( R8P ) :: d_4 = 0._R8P !< `(gamma-1)/2` of state 4. real ( R8P ) :: e_4 = 0._R8P !< `2*g/(g-1)` of state 4. real ( R8P ) :: u_4 = 0._R8P !< Velocity (normal) of state 4. real ( R8P ) :: p_4 = 0._R8P !< Pressure of state 4. real ( R8P ) :: r_4 = 0._R8P !< Density of state 4. real ( R8P ) :: a_4 = 0._R8P !< Speed of sound of state 4. real ( R8P ) :: u23 = 0._R8P !< Velocity (normal) of intermediate states. real ( R8P ) :: p23 = 0._R8P !< Pressure of intermediate states. real ( R8P ) :: r_2 = 0._R8P !< Density of state 2. real ( R8P ) :: r_3 = 0._R8P !< Density of state 3. real ( R8P ) :: s_1 = 0._R8P !< Left-front of left wave. real ( R8P ) :: s_2 = 0._R8P !< Right-front of left wave. real ( R8P ) :: s_3 = 0._R8P !< Left-front of right wave. real ( R8P ) :: s_4 = 0._R8P !< Right-front of right wave. contains ! deferred methods procedure , pass ( self ) :: description !< Return pretty-printed object description. ! public methods procedure , pass ( self ) :: compute_fluxes !< Compute fluxes at interface `x=xo`. procedure , pass ( self ) :: set_states14 !< Set states 1 and 4. endtype riemann_solver_compressible_object contains ! deferred methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'u_1 = ' // trim ( str ( n = self % u_1 )) // NL desc = desc // prefix_ // 'u_4 = ' // trim ( str ( n = self % u_4 )) // NL desc = desc // prefix_ // 'p_1 = ' // trim ( str ( n = self % p_1 )) // NL desc = desc // prefix_ // 'p_4 = ' // trim ( str ( n = self % p_4 )) // NL desc = desc // prefix_ // 'r_1 = ' // trim ( str ( n = self % r_1 )) // NL desc = desc // prefix_ // 'r_4 = ' // trim ( str ( n = self % r_4 )) // NL desc = desc // prefix_ // 'a_1 = ' // trim ( str ( n = self % a_1 )) // NL desc = desc // prefix_ // 'a_4 = ' // trim ( str ( n = self % a_4 )) // NL desc = desc // prefix_ // 'u23 = ' // trim ( str ( n = self % u23 )) // NL desc = desc // prefix_ // 'p23 = ' // trim ( str ( n = self % p23 )) // NL desc = desc // prefix_ // 'r_2 = ' // trim ( str ( n = self % r_2 )) // NL desc = desc // prefix_ // 'r_3 = ' // trim ( str ( n = self % r_3 )) // NL desc = desc // prefix_ // 's_1 = ' // trim ( str ( n = self % s_1 )) // NL desc = desc // prefix_ // 's_2 = ' // trim ( str ( n = self % s_2 )) // NL desc = desc // prefix_ // 's_3 = ' // trim ( str ( n = self % s_3 )) // NL desc = desc // prefix_ // 's_4 = ' // trim ( str ( n = self % s_4 )) endfunction description ! public methods elemental subroutine compute_fluxes ( self , eos_left , eos_right , normal , fluxes ) !< Compute fluxes at interface `x=xo`. !< !< Sampling the pattern the interface states are computed. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes at interface `x=xo`. real ( R8P ) :: a !< Speed of sound at interface `x=xo`. real ( R8P ) :: p !< Pressure at interface `x=xo`. real ( R8P ) :: r !< Desnity at interface `x=xo`. call fluxes % destroy associate ( s1 => self % s_1 , s2 => self % s_2 , u23 => self % u23 , s3 => self % s_3 , s4 => self % s_4 , & p1 => self % p_1 , r1 => self % r_1 , u1 => self % u_1 , a1 => self % a_1 , g1 => self % g_1 , d1 => self % d_1 , e1 => self % e_1 , & p4 => self % p_4 , r4 => self % r_4 , u4 => self % u_4 , a4 => self % a_4 , g4 => self % g_4 , d4 => self % d_4 , e4 => self % e_4 , & p23 => self % p23 , r2 => self % r_2 , r3 => self % r_3 ) select type ( fluxes ) class is ( conservative_compressible ) select case ( minloc ([ - s1 , s1 * s2 , s2 * u23 , u23 * s3 , s3 * s4 , s4 ], dim = 1 )) case ( 1 ) ! left supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p1 , r = r1 , u = u1 , normal = normal ) case ( 2 ) ! left transonic a = ( a1 + u1 * d1 ) / ( 1._R8P + d1 ) p = p1 * ( a / a1 ) ** e1 r = eos_left % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p , r = r , u = a , normal = normal ) case ( 3 ) ! left subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p23 , r = r2 , u = u23 , normal = normal ) case ( 4 ) ! right subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p23 , r = r3 , u = u23 , normal = normal ) case ( 5 ) ! right transonic a = ( a4 - u4 * d4 ) / ( 1._R8P + d4 ) p = p4 * ( a / a4 ) ** e4 r = eos_right % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p , r = r , u =- a , normal = normal ) case ( 6 ) ! right supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p4 , r = r4 , u = u4 , normal = normal ) endselect endselect endassociate endsubroutine compute_fluxes elemental subroutine set_states14 ( self , eos_left , state_left , eos_right , state_right , normal ) !< Set states 1 and 4. class ( riemann_solver_compressible_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. select type ( state_left ) class is ( conservative_compressible ) self % g_1 = eos_left % gam () self % d_1 = ( self % g_1 - 1._R8P ) * 0.5_R8P self % e_1 = 2._R8P * self % g_1 / ( self % g_1 - 1._R8P ) self % u_1 = state_left % velocity (). dot . normal self % p_1 = state_left % pressure ( eos = eos_left ) self % r_1 = state_left % density self % a_1 = eos_left % speed_of_sound ( density = state_left % density , pressure = self % p_1 ) endselect select type ( state_right ) class is ( conservative_compressible ) self % g_4 = eos_right % gam () self % d_4 = ( self % g_4 - 1._R8P ) * 0.5_R8P self % e_4 = 2._R8P * self % g_4 / ( self % g_4 - 1._R8P ) self % u_4 = state_right % velocity (). dot . normal self % p_4 = state_right % pressure ( eos = eos_right ) self % r_4 = state_right % density self % a_4 = eos_right % speed_of_sound ( density = state_right % density , pressure = self % p_4 ) endselect endsubroutine set_states14 endmodule foreseer_riemann_solver_compressible_object","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_object.f90.html","title":"foreseer_riemann_solver_compressible_object.f90 – FORESEER"},{"text":"Define the abstract primitive state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_primitive_object.f90~~EfferentGraph sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileforeseer_primitive_objectf90EfferentGraph = svgPanZoom('#sourcefileforeseer_primitive_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_primitive_object.f90~~AfferentGraph sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_primitive_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_primitive_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_primitive_object Source Code foreseer_primitive_object.f90 Source Code !< Define the abstract primitive state of a Riemann Problem for FORESEER library. module foreseer_primitive_object !< Define the abstract primitive state of a Riemann Problem for FORESEER library. use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: primitive_object type , abstract :: primitive_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of primitive. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy primitive. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return energy value. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize primitive. procedure ( momentum_interface ), pass ( self ), deferred :: momentum !< Return momentum vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: prim_assign_prim !< Operator `=`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_divide_real !< Operator `prim / real`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_multiply_real !< Operator `prim * real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: prim_multiply_prim !< Operator `*`. procedure ( real_operator_prim ), pass ( rhs ), deferred :: real_multiply_prim !< Operator `real * prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- prim`. ! operators generic :: assignment ( = ) => prim_assign_prim !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => prim_multiply_prim , prim_multiply_real , real_multiply_prim !< Overload `*`. generic :: operator ( / ) => prim_divide_real !< Overload `/`. endtype primitive_object abstract interface !< Abstract interfaces of deferred methods of [[primitive_object]]. pure function array_interface ( self ) result ( array_ ) !< Return serialized array of primitive. import :: primitive_object , R8P class ( primitive_object ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of primitive. endfunction array_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: primitive_object class ( primitive_object ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental subroutine destroy_interface ( self ) !< Destroy primitive. import :: primitive_object class ( primitive_object ), intent ( inout ) :: self !< Primitive. endsubroutine destroy_interface elemental function energy_interface ( self , eos ) result ( energy_ ) !< Return energy value. import :: primitive_object , eos_object , R8P class ( primitive_object ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. endfunction energy_interface subroutine initialize_interface ( self , initial_state ) !< Initialize primitive. import :: primitive_object class ( primitive_object ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), optional , intent ( in ) :: initial_state !< Initial state. endsubroutine initialize_interface elemental function momentum_interface ( self ) result ( momentum_ ) !< Return momentum vector. import :: primitive_object , vector class ( primitive_object ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. endfunction momentum_interface pure subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: primitive_object class ( primitive_object ), intent ( inout ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface function prim_operator_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim.op.real`. import :: primitive_object , R8P class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction prim_operator_real function real_operator_prim ( lhs , rhs ) result ( operator_result ) !< Operator `real * prim`. import :: primitive_object , R8P real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction real_operator_prim function symmetric_operator ( lhs , rhs ) result ( operator_result ) !< Symmetric operator `prim.op.prim`. import :: primitive_object class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction symmetric_operator function unary_operator ( self ) result ( operator_result ) !< Unary operator `.op.prim`. import :: primitive_object class ( primitive_object ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction unary_operator endinterface endmodule foreseer_primitive_object","tags":"","loc":"sourcefile/foreseer_primitive_object.f90.html","title":"foreseer_primitive_object.f90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible PVL class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_pvl.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 var pansourcefileforeseer_test_riemann_solver_compressible_pvlf90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_pvlf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_pvl Source Code foreseer_test_riemann_solver_compressible_pvl.f90 Source Code !< FORESEER test: Riemann solver compressible PVL class test. program foreseer_test_riemann_solver_compressible_pvl !< FORESEER test: Riemann solver compressible PVL class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_pvl use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_pvl","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_pvl.f90.html","title":"foreseer_test_riemann_solver_compressible_pvl.f90 – FORESEER"},{"text":"FORESEER test: conservative compressible class test. This File Depends On sourcefile~~foreseer_test_conservative_compressible.f90~~EfferentGraph sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 var pansourcefileforeseer_test_conservative_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_conservative_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_conservative_compressible Source Code foreseer_test_conservative_compressible.F90 Source Code !< FORESEER test: conservative compressible class test. program foreseer_test_conservative_compressible !< FORESEER test: conservative compressible class test. use foreseer , only : eos_compressible , conservative_compressible , conservative_compressible_pointer use penf , only : R8P , ZeroR8 use vecfor , only : ex , vector implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( conservative_compressible ) :: u !< A conservative compressible instance. type ( conservative_compressible ), pointer :: u_pointer !< A conservative compressible pointer. type ( conservative_compressible ) :: f !< Conservative fluxes. type ( vector ) :: velocity !< Velocity vector. real ( R8P ), allocatable :: u_serialized (:) !< Conservative variable serialized. #ifdef __GFORTRAN__ logical :: are_tests_passed ( 11 ) !< List of passed tests. #else logical :: are_tests_passed ( 7 ) !< List of passed tests. #endif are_tests_passed = . false . call u % initialize are_tests_passed ( 1 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'u = 0, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) are_tests_passed ( 1 ) = ( u % pressure ( eos = eos ) >= 1._R8P - ZeroR8 ). and .( u % pressure ( eos = eos ) <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%pressure() = 1, is right? ' , are_tests_passed ( 1 ) velocity = u % velocity () are_tests_passed ( 2 ) = ( u % velocity () >= 0._R8P - ZeroR8 ). and .( u % velocity () <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%velocity() = 0, is right? ' , are_tests_passed ( 2 ) u_serialized = u % array () are_tests_passed ( 3 ) = ( size ( u_serialized , dim = 1 ) == 5 ). and . & ( u_serialized ( 1 ) == 1._R8P ). and . & ( u_serialized ( 2 ) == 0._R8P ). and . & ( u_serialized ( 3 ) == 0._R8P ). and . & ( u_serialized ( 4 ) == 0._R8P ). and . & ( u_serialized ( 5 ) == 2.5_R8P ) print \"(A,L1)\" , 'u => serialized, is done right? ' , are_tests_passed ( 3 ) call u % destroy are_tests_passed ( 4 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'u destroyed, is right? ' , are_tests_passed ( 4 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) call u % compute_fluxes ( eos = eos , normal = ex , fluxes = f ) are_tests_passed ( 5 ) = ( f % density >= 1._R8P - ZeroR8 ). and .( f % density <= 1._R8P + ZeroR8 ). and . & ( f % momentum >= 1.8_R8P - ZeroR8 ). and .( f % momentum <= 1.8_R8P + ZeroR8 ). and . & ( f % energy >= 3.3_R8P - ZeroR8 ). and .( f % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'compute fluxes along X, is done right? ' , are_tests_passed ( 5 ) u = f are_tests_passed ( 6 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 1.8_R8P - ZeroR8 ). and .( u % momentum <= 1.8_R8P + ZeroR8 ). and . & ( u % energy >= 3.3_R8P - ZeroR8 ). and .( u % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = f, is done right? ' , are_tests_passed ( 6 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u_pointer => conservative_compressible_pointer ( to = u ) are_tests_passed ( 7 ) = ( u_pointer % density >= 1._R8P - ZeroR8 ). and .( u_pointer % density <= 1._R8P + ZeroR8 ). and . & ( u_pointer % momentum >= 1._R8P - ZeroR8 ). and .( u_pointer % momentum <= 1._R8P + ZeroR8 ). and . & ( u_pointer % energy >= 2.5_R8P - ZeroR8 ). and .( u_pointer % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u => u, is done right? ' , are_tests_passed ( 7 ) #ifdef __GFORTRAN__ u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u = 2._R8P * u are_tests_passed ( 8 ) = ( u % density >= 2._R8P - ZeroR8 ). and .( u % density <= 2._R8P + ZeroR8 ). and . & ( u % momentum >= 2._R8P - ZeroR8 ). and .( u % momentum <= 2._R8P + ZeroR8 ). and . & ( u % energy >= 5._R8P - ZeroR8 ). and .( u % energy <= 5._R8P + ZeroR8 ) print \"(A,L1)\" , '2 * u, is done right? ' , are_tests_passed ( 8 ) u = u * u are_tests_passed ( 9 ) = ( u % density >= 4._R8P - ZeroR8 ). and .( u % density <= 4._R8P + ZeroR8 ). and . & ( u % momentum >= 4._R8P - ZeroR8 ). and .( u % momentum <= 4._R8P + ZeroR8 ). and . & ( u % energy >= 2 5._R8P - ZeroR8 ). and .( u % energy <= 2 5._R8P + ZeroR8 ) print \"(A,L1)\" , 'u * u, is done right? ' , are_tests_passed ( 9 ) u = u + u are_tests_passed ( 10 ) = ( u % density >= 8._R8P - ZeroR8 ). and .( u % density <= 8._R8P + ZeroR8 ). and . & ( u % momentum >= 8._R8P - ZeroR8 ). and .( u % momentum <= 8._R8P + ZeroR8 ). and . & ( u % energy >= 5 0._R8P - ZeroR8 ). and .( u % energy <= 5 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u + u, is done right? ' , are_tests_passed ( 10 ) u = u - u are_tests_passed ( 11 ) = ( u % density >= 0._R8P - ZeroR8 ). and .( u % density <= 0._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 0._R8P - ZeroR8 ). and .( u % energy <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u - u, is done right? ' , are_tests_passed ( 11 ) #endif print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_conservative_compressible","tags":"","loc":"sourcefile/foreseer_test_conservative_compressible.f90.html","title":"foreseer_test_conservative_compressible.F90 – FORESEER"},{"text":"FORESEER test: shock tube tester, 1D Euler equation. This File Depends On sourcefile~~foreseer_test_shock_tube.f90~~EfferentGraph sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~penf.f90->sourcefile~wenoof.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~face.f90 face.f90 sourcefile~face.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth.f90 var pansourcefileforeseer_test_shock_tubef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_shock_tubef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_shock_tube Modules foreseer_euler_1d Source Code foreseer_test_shock_tube.f90 Source Code !< FORESEER test: shock tube tester, 1D Euler equation. module foreseer_euler_1d !< Definition of Euler 1D class for FORESEER test. use foreseer , only : conservative_object , conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible , & eos_object , eos_compressible , & riemann_solver_object , riemann_solver_compressible_llf , riemann_solver_compressible_pvl use penf , only : I4P , R8P use foodie , only : integrand use vecfor , only : ex , vector use wenoof , only : interpolator_object , wenoof_create implicit none private public :: euler_1d type , extends ( integrand ) :: euler_1d !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an !< ideal (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). integer ( I4P ) :: weno_order = 0 !< WENO reconstruction order. integer ( I4P ) :: Ni = 0 !< Space dimension. integer ( I4P ) :: Ng = 0 !< Ghost cells number. real ( R8P ) :: Dx = 0._R8P !< Space step. type ( eos_compressible ) :: eos !< Equation of state. type ( conservative_compressible ), allocatable :: U (:) !< Integrand (state) variables. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. procedure ( reconstruct_interfaces_ ), pointer :: reconstruct_interfaces => & reconstruct_interfaces_characteristic !< Reconstruct interface states. procedure ( riemann_solver_ ), pointer :: riemann_solver => riemann_solver_llf !< Actual Riemann Problem solver. contains ! auxiliary methods procedure , pass ( self ) :: initialize !< Initialize field. procedure , pass ( self ) :: destroy !< Destroy field. procedure , pass ( self ) :: output !< Extract Euler field. procedure , pass ( self ) :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ) :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ) :: local_error => euler_local_error !< Operator `||euler-euler||`. procedure , pass ( lhs ) :: integrand_multiply_integrand => euler_multiply_euler !< Operator `*`. procedure , pass ( lhs ) :: integrand_multiply_real => euler_multiply_real !< Operator `euler * real`. procedure , pass ( rhs ) :: real_multiply_integrand => real_multiply_euler !< Operator `real * euler`. procedure , pass ( lhs ) :: add => add_euler !< Operator `+`. procedure , pass ( lhs ) :: sub => sub_euler !< Operator `-`. procedure , pass ( lhs ) :: assign_integrand => euler_assign_euler !< Operator `=`. procedure , pass ( lhs ) :: assign_real => euler_assign_real !< Operator `euler = real`. ! private methods procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_characteristic !< Reconstruct (charc.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_conservative !< Reconstruct (cons.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_primitive !< Reconstruct (prim.) interface states. procedure , pass ( self ), private :: riemann_solver_llf !< LLF Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_pvl !< PVL Riemann Problem solver. endtype euler_1d abstract interface !< Abstract interfaces of [[euler_1d]] pointer methods. subroutine riemann_solver_ ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver. import :: conservative_compressible , eos_compressible , euler_1d , vector class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. endsubroutine riemann_solver_ subroutine reconstruct_interfaces_ ( self , conservative , r_conservative ) !< Reconstruct interface states. import :: conservative_compressible , euler_1d , primitive_compressible class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative variables. endsubroutine reconstruct_interfaces_ endinterface contains ! auxiliary methods subroutine initialize ( self , Ni , Dx , BC_L , BC_R , initial_state , eos , weno_order , weno_variables , riemann_solver_scheme ) !< Initialize field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: Ni !< Space dimension. real ( R8P ), intent ( in ) :: Dx !< Space step. character ( * ), intent ( in ) :: BC_L !< Left boundary condition type. character ( * ), intent ( in ) :: BC_R !< Right boundary condition type. type ( primitive_compressible ), intent ( in ) :: initial_state ( 1 :) !< Initial state of primitive variables. type ( eos_compressible ), intent ( in ) :: eos !< Equation of state. integer ( I4P ), intent ( in ), optional :: weno_order !< WENO reconstruction order. character ( * ), intent ( in ), optional :: weno_variables !< Variables on which WENO reconstruction is done. character ( * ), intent ( in ), optional :: riemann_solver_scheme !< Riemann solver scheme. character (:), allocatable :: weno_variables_ !< WENO Variables, local variable. character (:), allocatable :: riemann_solver_scheme_ !< Riemann solver scheme, local variable. integer ( I4P ) :: i !< Space couner. call self % destroy self % weno_order = 1 ; if ( present ( weno_order )) self % weno_order = weno_order self % Ni = Ni self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = Dx self % eos = eos if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 - self % Ng : self % Ni + self % Ng )) do i = 1 , Ni self % U ( i ) = primitive_to_conservative_compressible ( primitive = initial_state ( i ), eos = eos ) enddo self % BC_L = BC_L self % BC_R = BC_R if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = self % interpolator ) weno_variables_ = 'llf' if ( present ( weno_variables )) weno_variables_ = trim ( adjustl ( weno_variables )) select case ( weno_variables_ ) case ( 'characteristic' ) self % reconstruct_interfaces => reconstruct_interfaces_characteristic case ( 'conservative' ) self % reconstruct_interfaces => reconstruct_interfaces_conservative case ( 'primitive' ) self % reconstruct_interfaces => reconstruct_interfaces_primitive case default error stop 'error: WENO reconstruction variables set \"' // weno_variables_ // '\" unknown!' endselect riemann_solver_scheme_ = 'llf' if ( present ( riemann_solver_scheme )) riemann_solver_scheme_ = trim ( adjustl ( riemann_solver_scheme )) select case ( riemann_solver_scheme_ ) case ( 'llf' ) self % riemann_solver => riemann_solver_llf case ( 'pvl' ) self % riemann_solver => riemann_solver_pvl case default error stop 'error: Riemann Solver scheme \"' // riemann_solver_scheme_ // '\" unknown!' endselect endsubroutine initialize pure subroutine destroy ( self ) !< Destroy field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. self % weno_order = 0 self % Ni = 0 self % Ng = 0 self % Dx = 0._R8P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) if ( allocated ( self % interpolator )) deallocate ( self % interpolator ) endsubroutine destroy pure function output ( self , is_primitive ) result ( state ) !< Output the Euler field state. class ( euler_1d ), intent ( in ) :: self !< Euler field. logical , intent ( in ), optional :: is_primitive !< Output in primitive variables. real ( R8P ), allocatable :: state (:,:) !< Euler state vector. real ( R8P ), allocatable :: state_ (:) !< Euler state vector, local variable. logical :: is_primitive_ !< Output in primitive variables, local variable. type ( primitive_compressible ) :: primitive !< Primitive state. integer ( I4P ) :: i !< Counter. is_primitive_ = . false . ; if ( present ( is_primitive )) is_primitive_ = is_primitive if ( is_primitive_ ) then allocate ( state ( 1 : size ( primitive % array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni primitive = conservative_to_primitive_compressible ( conservative = self % U ( i ), eos = self % eos ) state_ = primitive % array () enddo else allocate ( state ( 1 : size ( self % U ( 1 )% array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni state_ = self % U ( i )% array () state (:, i ) = state_ enddo endif endfunction output pure function compute_dt ( self , steps_max , t_max , t , CFL ) result ( Dt ) !< Compute the current time step by means of CFL condition. class ( euler_1d ), intent ( in ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: steps_max !< Maximun number of time steps. real ( R8P ), intent ( in ) :: t_max !< Maximum integration time. real ( R8P ), intent ( in ) :: t !< Time. real ( R8P ), intent ( in ) :: CFL !< CFL value. real ( R8P ) :: Dt !< Time step. type ( vector ) :: u !< Velocity vector. real ( R8P ) :: a !< Speed of sound. real ( R8P ) :: vmax !< Maximum propagation speed of signals. integer ( I4P ) :: i !< Counter. associate ( Ni => self % Ni , Dx => self % Dx ) vmax = 0._R8P do i = 1 , Ni u = self % U ( i )% velocity () a = self % eos % speed_of_sound ( density = self % U ( i )% density , pressure = self % U ( i )% pressure ( eos = self % eos )) vmax = max ( vmax , u % normL2 () + a ) enddo Dt = Dx * CFL / vmax if ( steps_max <= 0 . and . t_max > 0._R8P ) then if (( t + Dt ) > t_max ) Dt = t_max - t endif endassociate endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !< Time derivative of Euler field, the residuals function. class ( euler_1d ), intent ( in ) :: self !< Euler field. real ( R8P ), intent ( in ), optional :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. type ( conservative_compressible ) :: U ( 1 - self % Ng : self % Ni + self % Ng ) !< Conservative variables. type ( conservative_compressible ) :: UR ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed conservative variables. type ( conservative_compressible ) :: F ( 0 : self % Ni ) !< Fluxes of conservative variables. integer ( I4P ) :: i !< Counter. do i = 1 , self % Ni U ( i ) = self % U ( i ) enddo call self % impose_boundary_conditions ( U = U ) call self % reconstruct_interfaces ( conservative = U , r_conservative = UR ) do i = 0 , self % Ni call self % riemann_solver ( eos_left = self % eos , state_left = UR ( 2 , i ), & eos_right = self % eos , state_right = UR ( 1 , i + 1 ), normal = ex , fluxes = F ( i )) enddo allocate ( euler_1d :: dState_dt ) select type ( dState_dt ) class is ( euler_1d ) dState_dt = self do i = 1 , self % Ni dState_dt % U ( i ) = ( F ( i - 1 ) - F ( i )) / self % Dx enddo endselect endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. real ( R8P ) :: error !< Error estimation. real ( R8P ), allocatable :: U_lhs (:) !< Serialized conservative variables. real ( R8P ), allocatable :: U_rhs (:) !< Serialized conservative variables. integer ( I4P ) :: i !< Space counter. integer ( I4P ) :: v !< Variables counter. select type ( rhs ) class is ( euler_1d ) error = 0._R8P do i = 1 , lhs % Ni U_lhs = lhs % U ( i )% array () U_rhs = rhs % U ( i )% array () do v = 1 , size ( U_lhs , dim = 1 ) error = error + ( U_lhs ( v ) - U_rhs ( v )) ** 2 / U_lhs ( v ) ** 2 enddo enddo error = sqrt ( error ) endselect endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by another one. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) * rhs % U ( i ) enddo endselect endselect endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by a real scalar. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs do i = 1 , lhs % Ni opr % U ( i ) = rhs * lhs % U ( i ) enddo endselect endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply a real scalar by an Euler field. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( euler_1d ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = rhs do i = 1 , rhs % Ni opr % U ( i ) = lhs * rhs % U ( i ) enddo endselect endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !< Add two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) + rhs % U ( i ) enddo endselect endselect endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !< Subtract two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) - rhs % U ( i ) enddo endselect endselect endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !< Assign one Euler field to another. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. select type ( rhs ) class is ( euler_1d ) lhs % weno_order = rhs % weno_order lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Dx = rhs % Dx lhs % eos = rhs % eos if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Ni )) select type ( rhs ) class is ( euler_1d ) if ( allocated ( rhs % U )) then do i = 1 , lhs % Ni lhs % U ( i ) = rhs % U ( i ) enddo endif endselect endif if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R if ( allocated ( rhs % interpolator )) then if ( allocated ( lhs % interpolator )) deallocate ( lhs % interpolator ) allocate ( lhs % interpolator , source = rhs % interpolator ) endif if ( associated ( rhs % reconstruct_interfaces )) lhs % reconstruct_interfaces => rhs % reconstruct_interfaces if ( associated ( rhs % riemann_solver )) lhs % riemann_solver => rhs % riemann_solver endselect endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !< Assign one real to an Euler field. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. if ( allocated ( lhs % U )) then do i = 1 , lhs % Ni lhs % U ( i )% density = rhs lhs % U ( i )% momentum = rhs lhs % U ( i )% energy = rhs enddo endif endsubroutine euler_assign_real ! private methods ! pure subroutine impose_boundary_conditions(self, P) pure subroutine impose_boundary_conditions ( self , U ) !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( inout ) :: U ( 1 - self % Ng :) !< Conservative variables. ! type(primitive_compressible), intent(inout) :: P(1-self%Ng:) !< Primitive variables. integer ( I4P ) :: i !< Space counter. select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 ! P(i) = P(-i+1) U ( i ) = U ( - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 ! P(i)%density  =   P(-i+1)%density ! P(i)%velocity = - P(-i+1)%velocity ! P(i)%pressure =   P(-i+1)%pressure U ( i )% density = U ( - i + 1 )% density U ( i )% momentum = - U ( - i + 1 )% momentum U ( i )% energy = U ( - i + 1 )% energy enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i) = P(self%Ni-(i-self%Ni-1)) U ( i ) = U ( self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i)%density  =   P(self%Ni-(i-self%Ni-1))%density ! P(i)%velocity = - P(self%Ni-(i-self%Ni-1))%velocity ! P(i)%pressure =   P(self%Ni-(i-self%Ni-1))%pressure U ( i )% density = U ( self % Ni - ( i - self % Ni - 1 ))% density U ( i )% momentum = - U ( self % Ni - ( i - self % Ni - 1 ))% momentum U ( i )% energy = U ( self % Ni - ( i - self % Ni - 1 ))% energy enddo endselect endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_characteristic ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in pseudo characteristic variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. type ( primitive_compressible ) :: Pm ( 1 : 2 ) !< Mean of primitive variables. real ( R8P ) :: LPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R8P ) :: RPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean right eigenvectors matrix. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. real ( R8P ) :: buffer ( 1 : 3 ) !< Dummy buffer. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm ( f ) = 0.5_R8P * ( primitive ( i + f - 2 ) + primitive ( i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = Pm ( f )% left_eigenvectors ( eos = self % eos ) RPm (:, :, f ) = Pm ( f )% right_eigenvectors ( eos = self % eos ) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , 3 C ( f , j - i , v ) = dot_product ( LPm ( v , :, f ), [ primitive ( j )% density , primitive ( j )% velocity % x , primitive ( j )% pressure ]) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , 3 buffer ( v ) = dot_product ( RPm ( v , :, f ), CR ( f , :)) enddo r_primitive ( f , i )% density = buffer ( 1 ) r_primitive ( f , i )% velocity = buffer ( 2 ) * ex r_primitive ( f , i )% pressure = buffer ( 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_characteristic subroutine reconstruct_interfaces_conservative ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in conservative variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. real ( R8P ), allocatable :: U (:) !< Serialized conservative variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng U = conservative ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = U ( 1 ) C ( f , j - i , 2 ) = U ( 2 ) C ( f , j - i , 3 ) = U ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_conservative ( f , i )% density = CR ( f , 1 ) r_conservative ( f , i )% momentum = CR ( f , 2 ) * ex r_conservative ( f , i )% energy = CR ( f , 3 ) enddo enddo endselect endsubroutine reconstruct_interfaces_conservative subroutine reconstruct_interfaces_primitive ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in primitive variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R8P ), allocatable :: P (:) !< Serialized primitive variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng P = primitive ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = P ( 1 ) C ( f , j - i , 2 ) = P ( 2 ) C ( f , j - i , 3 ) = P ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_primitive ( f , i )% density = CR ( f , 1 ) r_primitive ( f , i )% velocity = CR ( f , 2 ) * ex r_primitive ( f , i )% pressure = CR ( f , 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_primitive subroutine riemann_solver_llf ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_llf subroutine riemann_solver_pvl ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_pvl endmodule foreseer_euler_1d program foreseer_test_shock_tube !< FORESEER test: shock tube tester, 1D Euler equation. use flap , only : command_line_interface use foodie , only : tvd_runge_kutta_integrator use foreseer , only : conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible , & eos_compressible use foreseer_euler_1d , only : euler_1d use penf , only : cton , FR8P , I4P , R8P , str use vecfor , only : ex , vector implicit none integer ( I4P ) :: weno_order !< WENO reconstruction order. character ( len = :), allocatable :: weno_variables !< Variables set on which WENO reconstruction is done. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer ( I4P ) :: rk_stages_number !< Runge-Kutta stages number. type ( euler_1d ), allocatable :: rk_stage (:) !< Runge-Kutta stages. real ( R8P ) :: dt !< Time step. real ( R8P ) :: t !< Time. integer ( I4P ) :: step !< Time steps counter. type ( euler_1d ) :: domain !< Domain of Euler equations. real ( R8P ) :: CFL !< CFL value. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I4P ) :: Ni !< Number of grid cells. real ( R8P ) :: Dx !< Space step discretization. real ( R8P ), allocatable :: x (:) !< Cell center x-abscissa values. integer ( I4P ) :: steps_max !< Maximum number of time steps. real ( R8P ) :: t_max !< Maximum integration time. character ( 99 ) :: riemann_solver_scheme !< Riemann Problem solver scheme. character ( 99 ) :: s_scheme !< Space integration scheme. character ( 99 ) :: t_scheme !< Time integration scheme. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. call initialize call save_time_serie ( filename = 'euler_1D-' // trim ( adjustl ( s_scheme )) // '-' // trim ( adjustl ( t_scheme )) // '.dat' , t = t ) step = 0 time_loop : do step = step + 1 dt = domain % dt ( steps_max = steps_max , t_max = t_max , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) if ( verbose ) print \"(A)\" , 'step = ' // str ( n = step ) // ', time step = ' // str ( n = dt ) // ', time = ' // str ( n = t ) if (( t == t_max ). or .( step == steps_max )) exit time_loop enddo time_loop contains subroutine initialize () !< Initialize the test. type ( primitive_compressible ), allocatable :: initial_state (:) !< Initial state of primitive variables. integer ( I4P ) :: i !< Space counter. call parse_command_line_interface allocate ( rk_stage ( 1 : rk_stages_number )) call rk_integrator % init ( stages = rk_stages_number ) t = 0._R8P allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Ni )) Dx = 1._R8P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 1._R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 1._R8P enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 0.125_R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 0.1_R8P enddo call domain % initialize ( Ni = Ni , Dx = Dx , & BC_L = BC_L , BC_R = BC_R , & initial_state = initial_state , & eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ), & weno_order = weno_order , & weno_variables = weno_variables , & riemann_solver_scheme = riemann_solver_scheme ) endsubroutine initialize subroutine parse_command_line_interface () !< Parse Command Line Interface (CLI). type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I4P ) :: error !< Error handler. character ( len = :), allocatable :: buffer !< String buffer. call cli % init ( description = 'FORESEER test: shock tube tester, 1D Euler equations' , & examples = [ \"foreseer_test_shock_tube         \" , & \"foreseer_test_shock_tube --tserie\" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '60' ) call cli % add ( switch = '--t-max' , help = 'Maximum integration time' , required = . false ., act = 'store' , def = '0.' ) call cli % add ( switch = '--riemann' , help = 'Riemann Problem solver' , required = . false ., act = 'store' , def = 'llf' , choices = 'llf,pvl' ) call cli % add ( switch = '--s-scheme' , help = 'Space intergation scheme' , required = . false ., act = 'store' , def = 'weno-char-1' , & choices = 'weno-char-1,weno-char-3,weno-char-5,weno-char-7,weno-char-9,weno-char-11,weno-char-13,weno-char-15,weno-char-17,' // & 'weno-cons-1,weno-cons-3,weno-cons-5,weno-cons-7,weno-cons-9,weno-cons-11,weno-cons-13,weno-cons-15,weno-cons-17,' // & 'weno-prim-1,weno-prim-3,weno-prim-5,weno-prim-7,weno-prim-9,weno-prim-11,weno-prim-13,weno-prim-15,weno-prim-17' ) call cli % add ( switch = '--t-scheme' , help = 'Time intergation scheme' , required = . false ., act = 'store' , def = 'tvd-rk-1' , & choices = 'tvd-rk-1,tvd-rk-2,tvd-rk-3,tvd-rk-5' ) call cli % add ( switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.7' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-max' , val = t_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--riemann' , val = riemann_solver_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--s-scheme' , val = s_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-scheme' , val = t_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--cfl' , val = CFL , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop if ( t_max > 0._R8P ) steps_max = 0 buffer = trim ( adjustl ( s_scheme )) select case ( buffer ( 6 : 9 )) case ( 'char' ) weno_variables = 'characteristic' case ( 'cons' ) weno_variables = 'conservative' case ( 'prim' ) weno_variables = 'primitive' endselect weno_order = cton ( buffer ( 11 :), knd = 1_I4P ) select case ( trim ( adjustl ( t_scheme ))) case ( 'tvd-rk-1' ) rk_stages_number = 1 case ( 'tvd-rk-2' ) rk_stages_number = 2 case ( 'tvd-rk-3' ) rk_stages_number = 3 case ( 'tvd-rk-5' ) rk_stages_number = 5 endselect endsubroutine parse_command_line_interface subroutine save_time_serie ( filename , finish , t ) !< Save time-serie results. character ( * ), intent ( in ), optional :: filename !< Output filename. logical , intent ( in ), optional :: finish !< Flag for triggering the file closing. real ( R8P ), intent ( in ) :: t !< Current integration time. integer ( I4P ), save :: tsfile !< File unit for saving time serie results. type ( primitive_compressible ) :: primitive !< Primitive variables. integer ( I4P ) :: i !< Counter. if ( time_serie ) then if ( present ( filename )) then open ( newunit = tsfile , file = filename ) endif write ( tsfile , '(A)' ) 'VARIABLES = \"x\" \"rho\" \"u\" \"p\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni primitive = conservative_to_primitive_compressible ( conservative = domain % U ( i ), eos = domain % eos ) write ( tsfile , '(4' // '(' // FR8P // ',1X))' ) x ( i ), primitive % density , primitive % velocity % x , primitive % pressure enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif endsubroutine save_time_serie endprogram foreseer_test_shock_tube","tags":"","loc":"sourcefile/foreseer_test_shock_tube.f90.html","title":"foreseer_test_shock_tube.f90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible LLF class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_llf.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 var pansourcefileforeseer_test_riemann_solver_compressible_llff90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_llff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_llf Source Code foreseer_test_riemann_solver_compressible_llf.f90 Source Code !< FORESEER test: Riemann solver compressible LLF class test. program foreseer_test_riemann_solver_compressible_llf !< FORESEER test: Riemann solver compressible LLF class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_llf use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_llf","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_llf.f90.html","title":"foreseer_test_riemann_solver_compressible_llf.f90 – FORESEER"},{"text":"FORESEER test: equation of state compressible class test. This File Depends On sourcefile~~foreseer_test_eos_compressible.f90~~EfferentGraph sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 var pansourcefileforeseer_test_eos_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_eos_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_eos_compressible Source Code foreseer_test_eos_compressible.f90 Source Code !< FORESEER test: equation of state compressible class test. program foreseer_test_eos_compressible !< FORESEER test: equation of state compressible class test. use foreseer , only : eos_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. logical :: are_tests_passed ( 14 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 1 ) = ( eos % gam () >= 1.4_R8P - ZeroR8 ). and .( eos % gam () <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%gam() = 1.4, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , gam = 1.4_R8P ) are_tests_passed ( 2 ) = ( eos % cv () >= 74 2.86_R8P - ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 2 ) eos = eos_compressible ( cv = 74 2.86_R8P , gam = 1.4_R8P ) are_tests_passed ( 3 ) = ( eos % R () >= 29 7.144_R8P - 1000 * ZeroR8 ). and .( eos % R () <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%R() = 297.144, is right? ' , are_tests_passed ( 3 ) eos = eos_compressible ( cv = 74 2.86_R8P , R = 29 7.144_R8P ) are_tests_passed ( 4 ) = ( eos % cp () >= 104 0.004_R8P - ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 4 ) eos = eos_compressible ( cp = 104 0.004_R8P , R = 29 7.144_R8P ) are_tests_passed ( 5 ) = ( eos % cv () >= 74 2.86_R8P - 1000 * ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 5 ) eos = eos_compressible ( gam = 1.4_R8P , R = 29 7.144_R8P ) are_tests_passed ( 6 ) = ( eos % cp () >= 104 0.004_R8P - 1000 * ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 6 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 7 ) = ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) >= 0.4_R8P - ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) <= 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, energy=1) = 0.4, is right? ' , are_tests_passed ( 7 ) are_tests_passed ( 8 ) = ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) >= 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, temperature=1) = 297.144, is right? ' , are_tests_passed ( 8 ) are_tests_passed ( 9 ) = ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) >= 1._R8P / 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) <= 1._R8P / 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, temperature=1) = 1/297.144, is right? ' , are_tests_passed ( 9 ) are_tests_passed ( 10 ) = ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, energy=1) = 1/0.4, is right? ' , are_tests_passed ( 10 ) are_tests_passed ( 11 ) = ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(density=1, pressure=1) = 1/0.4, is right? ' , are_tests_passed ( 11 ) are_tests_passed ( 12 ) = ( eos % energy ( temperature = 1._R8P ) >= 74 2.86_R8P - ZeroR8 ). and .& ( eos % energy ( temperature = 1._R8P ) <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(temperature=1) = 742.86, is right? ' , are_tests_passed ( 12 ) are_tests_passed ( 13 ) = ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 29 7.144_R8P - ZeroR8 ). and .& ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 29 7.144_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(density=1, pressure=1) = 1/297.144, is right? ' , are_tests_passed ( 13 ) are_tests_passed ( 14 ) = ( eos % temperature ( energy = 1._R8P ) >= 1._R8P / 74 2.86_R8P - ZeroR8 ). and .& ( eos % temperature ( energy = 1._R8P ) <= 1._R8P / 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(energy=1) = 1/742.86, is right? ' , are_tests_passed ( 14 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_eos_compressible","tags":"","loc":"sourcefile/foreseer_test_eos_compressible.f90.html","title":"foreseer_test_eos_compressible.f90 – FORESEER"},{"text":"FACE, Fortran Ansi Colors Environment Files Dependent On This One sourcefile~~face.f90~~AfferentGraph sourcefile~face.f90 face.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~face.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~face.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilefacef90AfferentGraph = svgPanZoom('#sourcefilefacef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules face Source Code face.f90 Source Code !< FACE, Fortran Ansi Colors Environment module face !----------------------------------------------------------------------------------------------------------------------------------- !< FACE, Fortran Ansi Colors Environment !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: colorize public :: colors_samples public :: styles_samples !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! parameters character ( 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. character ( 1 ), parameter :: ESCAPE = achar ( 27 ) !< \"\\\" character. ! codes character ( 2 ), parameter :: CODE_START = ESCAPE // '[' !< Start ansi code, \"\". character ( 1 ), parameter :: CODE_END = 'm' !< End ansi code, \"m\". character ( 4 ), parameter :: CODE_CLEAR = CODE_START // '0' // CODE_END !< Clear all styles, \"0m\". ! styles codes character ( 17 ), parameter :: STYLES ( 1 : 2 , 1 : 16 ) = reshape ([& 'BOLD_ON          ' , '1                ' , & !  Bold on. 'ITALICS_ON       ' , '3                ' , & !  Italics on. 'UNDERLINE_ON     ' , '4                ' , & !  Underline on. 'INVERSE_ON       ' , '7                ' , & !  Inverse on: reverse foreground and background colors. 'STRIKETHROUGH_ON ' , '9                ' , & !  Strikethrough on. 'BOLD_OFF         ' , '22               ' , & !  Bold off. 'ITALICS_OFF      ' , '23               ' , & !  Italics off. 'UNDERLINE_OFF    ' , '24               ' , & !  Underline off. 'INVERSE_OFF      ' , '27               ' , & !  Inverse off: reverse foreground and background colors. 'STRIKETHROUGH_OFF' , '29               ' , & !  Strikethrough off. 'FRAMED_ON        ' , '51               ' , & !  Framed on. 'ENCIRCLED_ON     ' , '52               ' , & !  Encircled on. 'OVERLINED_ON     ' , '53               ' , & !  Overlined on. 'FRAMED_OFF       ' , '54               ' , & !  Framed off. 'ENCIRCLED_OFF    ' , '54               ' , & !  Encircled off. 'OVERLINED_OFF    ' , '55               ' & !  Overlined off. ], [ 2 , 16 ]) !< Styles. ! colors codes character ( 15 ), parameter :: COLORS_FG ( 1 : 2 , 1 : 17 ) = reshape ([& 'BLACK          ' , '30             ' , & !  Black. 'RED            ' , '31             ' , & !  Red. 'GREEN          ' , '32             ' , & !  Green. 'YELLOW         ' , '33             ' , & !  Yellow. 'BLUE           ' , '34             ' , & !  Blue. 'MAGENTA        ' , '35             ' , & !  Magenta. 'CYAN           ' , '36             ' , & !  Cyan. 'WHITE          ' , '37             ' , & !  White. 'DEFAULT        ' , '39             ' , & !  Default (white). 'BLACK_INTENSE  ' , '90             ' , & !  Black intense. 'RED_INTENSE    ' , '91             ' , & !  Red intense. 'GREEN_INTENSE  ' , '92             ' , & !  Green intense. 'YELLOW_INTENSE ' , '93             ' , & !  Yellow intense. 'BLUE_INTENSE   ' , '94             ' , & !  Blue intense. 'MAGENTA_INTENSE' , '95             ' , & !  Magenta intense. 'CYAN_INTENSE   ' , '96             ' , & !  Cyan intense. 'WHITE_INTENSE  ' , '97             ' & !  White intense. ], [ 2 , 17 ]) !< Foreground colors. character ( 15 ), parameter :: COLORS_BG ( 1 : 2 , 1 : 17 ) = reshape ([& 'BLACK          ' , '40             ' , & !  Black. 'RED            ' , '41             ' , & !  Red. 'GREEN          ' , '42             ' , & !  Green. 'YELLOW         ' , '43             ' , & !  Yellow. 'BLUE           ' , '44             ' , & !  Blue. 'MAGENTA        ' , '45             ' , & !  Magenta. 'CYAN           ' , '46             ' , & !  Cyan. 'WHITE          ' , '47             ' , & !  White. 'DEFAULT        ' , '49             ' , & !  Default (black). 'BLACK_INTENSE  ' , '100            ' , & !  Black intense. 'RED_INTENSE    ' , '101            ' , & !  Red intense. 'GREEN_INTENSE  ' , '102            ' , & !  Green intense. 'YELLOW_INTENSE ' , '103            ' , & !  Yellow intense. 'BLUE_INTENSE   ' , '104            ' , & !  Blue intense. 'MAGENTA_INTENSE' , '105            ' , & !  Magenta intense. 'CYAN_INTENSE   ' , '106            ' , & !  Cyan intense. 'WHITE_INTENSE  ' , '107            ' & !  White intense. ], [ 2 , 17 ]) !< Background colors. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods pure function colorize ( string , color_fg , color_bg , style ) result ( colorized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Colorize and stylize strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. integer ( int32 ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) colorized = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction colorize subroutine colors_samples () !--------------------------------------------------------------------------------------------------------------------------------- !< Print to standard output all colors samples. !--------------------------------------------------------------------------------------------------------------------------------- integer ( int32 ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print '(A)' , colorize ( 'Foreground colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_FG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_FG ( 1 , c ) // '\", color_fg=\"' // COLORS_FG ( 1 , c ) // '\") => ' // & colorize ( COLORS_FG ( 1 , c ), color_fg = COLORS_FG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_FG ( 2 , c )), color_fg = COLORS_FG ( 1 , c ), style = 'inverse_on' ) enddo print '(A)' , colorize ( 'Background colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_BG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_BG ( 1 , c ) // '\", color_bg=\"' // COLORS_BG ( 1 , c ) // '\") => ' // & colorize ( COLORS_BG ( 1 , c ), color_bg = COLORS_BG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_BG ( 2 , c )), color_bg = COLORS_BG ( 1 , c ), style = 'inverse_on' ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine colors_samples subroutine styles_samples () !--------------------------------------------------------------------------------------------------------------------------------- !< Print to standard output all styles samples. !--------------------------------------------------------------------------------------------------------------------------------- integer ( int32 ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print '(A)' , colorize ( 'Styles samples' , color_fg = 'red_intense' ) do s = 1 , size ( STYLES , dim = 2 ) print '(A)' , '  colorize(\"' // STYLES ( 1 , s ) // '\", style=\"' // STYLES ( 1 , s ) // '\") => ' // & colorize ( STYLES ( 1 , s ), style = STYLES ( 1 , s )) // & ' code: ' // colorize ( trim ( STYLES ( 2 , s )), color_fg = 'magenta' , style = 'inverse_on' ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine styles_samples ! private methods elemental function color_index ( color ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the array-index corresponding to the queried color. !< !< @note Because Foreground and backround colors lists share the same name, no matter what array is used to find the color index. !< Thus, the foreground array is used. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: color !< Color definition. integer ( int32 ) :: color_index !< Index into the colors arrays. integer ( int32 ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- color_index = 0 do c = 1 , size ( COLORS_FG , dim = 2 ) if ( trim ( COLORS_FG ( 1 , c )) == trim ( adjustl ( color ))) then color_index = c exit endif enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction color_index elemental function style_index ( style ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the array-index corresponding to the queried style. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: style !< Style definition. integer ( int32 ) :: style_index !< Index into the styles array. integer ( int32 ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- style_index = 0 do s = 1 , size ( STYLES , dim = 2 ) if ( trim ( STYLES ( 1 , s )) == trim ( adjustl ( style ))) then style_index = s exit endif enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction style_index elemental function upper ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< Input string. character ( len = len ( string )) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- upper = string do n1 = 1 , len ( string ) n2 = index ( LOWER_ALPHABET , string ( n1 : n1 )) if ( n2 > 0 ) upper ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper endmodule face","tags":"","loc":"sourcefile/face.f90.html","title":"face.f90 – FORESEER"},{"text":"Command Line Interface (CLI) class. This File Depends On sourcefile~~flap_command_line_interface_t.f90~~EfferentGraph sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~face.f90 face.f90 sourcefile~face.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~face.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileflap_command_line_interface_tf90EfferentGraph = svgPanZoom('#sourcefileflap_command_line_interface_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_command_line_interface_t.f90~~AfferentGraph sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_command_line_interface_t Source Code flap_command_line_interface_t.F90 Source Code !< Command Line Interface (CLI) class. module flap_command_line_interface_t !< Command Line Interface (CLI) class. use face , only : colorize use flap_command_line_argument_t , only : command_line_argument , action_store use flap_command_line_arguments_group_t , only : command_line_arguments_group , STATUS_PRINT_H , STATUS_PRINT_V use flap_object_t , only : object use flap_utils_m use penf implicit none private save type , extends ( object ), public :: command_line_interface !< Command Line Interface (CLI) class. private type ( command_line_arguments_group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. logical :: is_parsed_ = . false . !< Parse status. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined_group !< Check if a CLAs group has been defined. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: is_parsed !< Check if CLI has been parsed. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => is_called_group !< Check if a CLAs group has been run. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from CLAs list parsed, varying size list. procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. procedure , public :: save_usage_to_markdown !< Save parts of the CLI as markdown. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check !< Check data consistency. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => & get_args_from_string , & get_args_from_invocation !< Get CLAs. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: cli_assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => cli_assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_interface integer ( I4P ), parameter , public :: MAX_VAL_LEN = 1000 !< Maximum number of characters of CLA value. ! errors codes integer ( I4P ), parameter , public :: ERROR_MISSING_CLA = 25 !< CLA not found in CLI. integer ( I4P ), parameter , public :: ERROR_MISSING_GROUP = 26 !< Group not found in CLI. integer ( I4P ), parameter , public :: ERROR_MISSING_SELECTION_CLA = 27 !< CLA selection in CLI failing. integer ( I4P ), parameter , public :: ERROR_TOO_FEW_CLAS = 28 !< Insufficient arguments for CLI. contains ! public methods elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ) :: g !< Counter. ! object members call self % free_object ! command_line_interface members if ( allocated ( self % clasg )) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 call self % clasg ( g )% free enddo deallocate ( self % clasg ) endif if ( allocated ( self % args )) deallocate ( self % args ) if ( allocated ( self % examples )) deallocate ( self % examples ) self % disable_hv = . false . self % is_parsed_ = . false . endsubroutine free subroutine init ( self , progname , version , help , description , license , authors , examples , epilog , disable_hv , & usage_lun , error_lun , version_lun , error_color , error_style ) !< Initialize CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: progname !< Program name. character ( * ), optional , intent ( in ) :: version !< Program version. character ( * ), optional , intent ( in ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( in ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( in ) :: license !< License description. character ( * ), optional , intent ( in ) :: authors !< Authors list. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( in ) :: epilog !< Epilog message. logical , optional , intent ( in ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. integer ( I4P ), optional , intent ( in ) :: usage_lun !< Unit number to print usage/help. integer ( I4P ), optional , intent ( in ) :: version_lun !< Unit number to print version/license info. integer ( I4P ), optional , intent ( in ) :: error_lun !< Unit number to print error info. character ( * ), optional , intent ( in ) :: error_color !< ANSI color of error messages. character ( * ), optional , intent ( in ) :: error_style !< ANSI style of error messages. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. call self % free if ( present ( progname )) then self % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then self % progname = prog_invocation else self % progname = 'program' endif endif self % version = 'unknown' ; if ( present ( version )) self % version = version self % help = 'usage: ' ; if ( present ( help )) self % help = help self % description = '' ; if ( present ( description )) self % description = description self % license = '' ; if ( present ( license )) self % license = license self % authors = '' ; if ( present ( authors )) self % authors = authors if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( self % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: self % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif self % examples = examples endif self % epilog = '' ; if ( present ( epilog )) self % epilog = epilog if ( present ( disable_hv )) self % disable_hv = disable_hv ! default set by self%free if ( present ( usage_lun )) self % usage_lun = usage_lun ! default set by self%free if ( present ( version_lun )) self % version_lun = version_lun ! default set by self%free if ( present ( error_lun )) self % error_lun = error_lun ! default set by self%free self % error_color = '' ; if ( present ( error_color )) self % error_color = error_color self % error_style = '' ; if ( present ( error_style )) self % error_style = error_style ! initialize only the first default group allocate ( self % clasg ( 0 : 0 )) call self % clasg ( 0 )% assign_object ( self ) self % clasg ( 0 )% group = '' endsubroutine init subroutine add_group ( self , help , description , exclude , group ) !< Add CLAs group to CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: help !< Help message. character ( * ), optional , intent ( in ) :: description !< Detailed description. character ( * ), optional , intent ( in ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( in ) :: group !< Name of the grouped CLAs. type ( command_line_arguments_group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index if (. not . self % is_defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( self % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = self%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = self % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( self ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( self % clasg ) allocate ( self % clasg ( 0 : Ng )) self % clasg = clasg_list_new deallocate ( clasg_list_new ) endif endsubroutine add_group subroutine set_mutually_exclusive_groups ( self , group1 , group2 ) !< Set two CLAs group ad mutually exclusive. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( in ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. if ( self % is_defined_group ( group = group1 , g = g1 ). and . self % is_defined_group ( group = group2 , g = g2 )) then self % clasg ( g1 )% m_exclude = group2 self % clasg ( g2 )% m_exclude = group1 endif endsubroutine set_mutually_exclusive_groups subroutine add ( self , pref , group , group_index , switch , switch_ab , help , help_markdown , help_color , help_style , & required , positional , position , hidden , act , def , nargs , choices , exclude , envvar , error ) !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( in ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( in ) :: help !< Help message describing the CLA. character ( * ), optional , intent ( in ) :: help_color !< ANSI color of help messages. character ( * ), optional , intent ( in ) :: help_style !< ANSI style of help messages. character ( * ), optional , intent ( in ) :: help_markdown !< Longer help message, markdown formatted. logical , optional , intent ( in ) :: required !< Flag for set required argument. logical , optional , intent ( in ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical , optional , intent ( in ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( in ) :: act !< CLA value action. character ( * ), optional , intent ( in ) :: def !< Default value. character ( * ), optional , intent ( in ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( in ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( in ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( in ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. type ( command_line_argument ) :: cla !< CLA data. integer ( I4P ) :: g !< Counter. ! initialize CLA call cla % assign_object ( self ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % help_color = '' ; if ( present ( help_color )) cla % help_color = help_color cla % help_style = '' ; if ( present ( help_style )) cla % help_style = help_style cla % help_markdown = '' ; if ( present ( help_markdown )) cla % help_markdown = help_markdown cla % is_required = . false . ; if ( present ( required )) cla % is_required = required cla % is_positional = . false . ; if ( present ( positional )) cla % is_positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % is_hidden = . false . ; if ( present ( hidden )) cla % is_hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar call cla % check ( pref = pref ) ; self % error = cla % error if ( self % error /= 0 ) then if ( present ( error )) error = self % error return endif ! add CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call self % clasg ( 0 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( 0 )% error elseif ( present ( group )) then if ( self % is_defined_group ( group = group , g = g )) then call self % clasg ( g )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( g )% error else call self % add_group ( group = group ) call self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( self % clasg , dim = 1 ) - 1 ) then call self % clasg ( group_index )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( group_index )% error endif endif if ( present ( error )) error = self % error endsubroutine add subroutine check ( self , pref , error ) !< Check data consistency. class ( command_line_interface ), intent ( INOUT ) :: self !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 0 , size ( self % clasg , dim = 1 ) - 1 ! check group consistency call self % clasg ( g )% check ( pref = pref ) self % error = self % clasg ( g )% error if ( present ( error )) error = self % error if ( self % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( self % clasg ( g )% m_exclude /= '' ) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) self % clasg ( gg )% m_exclude = self % clasg ( g )% group endif endif enddo endsubroutine check subroutine check_m_exclusive ( self , pref ) !< Check if two mutually exclusive CLAs group have been called. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 1 , size ( self % clasg , dim = 1 ) - 1 if ( self % clasg ( g )% is_called . and .( self % clasg ( g )% m_exclude /= '' )) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) then if ( self % clasg ( gg )% is_called ) then call self % clasg ( g )% raise_error_m_exclude ( pref = pref ) self % error = self % clasg ( g )% error exit endif endif endif enddo endsubroutine check_m_exclusive function is_passed ( self , group , switch , position ) !< Check if a CLA has been passed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. is_passed = . false . if (. not . present ( group )) then if ( present ( switch )) then is_passed = self % clasg ( 0 )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( 0 )% is_passed ( position = position ) endif else if ( self % is_defined_group ( group = group , g = g )) then if ( present ( switch )) then is_passed = self % clasg ( g )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( g )% is_passed ( position = position ) endif endif endif endfunction is_passed function is_defined_group ( self , group , g ) result ( defined ) !< Check if a CLAs group has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( out ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. defined = . false . do gg = 0 , size ( self % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( self % clasg ( gg )% group )) defined = ( self % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg endfunction is_defined_group function is_called_group ( self , group ) result ( called ) !< Check if a CLAs group has been run. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. called = . false . if ( self % is_defined_group ( group = group , g = g )) called = self % clasg ( g )% is_called endfunction is_called_group function is_defined ( self , switch , group ) !< Check if a CLA has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLAs. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. is_defined = . false . if (. not . present ( group )) then is_defined = self % clasg ( 0 )% is_defined ( switch = switch ) else if ( self % is_defined_group ( group = group , g = g )) is_defined = self % clasg ( g )% is_defined ( switch = switch ) endif endfunction is_defined elemental function is_parsed ( self ) !< Check if CLI has been parsed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical :: is_parsed !< Parsed status. is_parsed = self % is_parsed_ endfunction is_parsed subroutine parse ( self , pref , args , error ) !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. if ( present ( error )) error = 0 if ( self % is_parsed_ ) return ! add help and version switches if not done by user if (. not . self % disable_hv ) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--help' ). and .& self % is_defined ( group = self % clasg ( g )% group , switch = '-h' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--version' ). and . & self % is_defined ( group = self % clasg ( g )% group , switch = '-v' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not . self % is_defined ( group = self % clasg ( g )% group , switch = '--' )) & call self % add ( pref = pref , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parse passed CLAs grouping in indexes if ( present ( args )) then call self % get_args ( args = args , ai = ai ) else call self % get_args ( ai = ai ) endif ! check CLI consistency call self % check ( pref = pref ) if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! parse CLI do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) then call self % clasg ( g )% parse ( args = self % args ( ai ( g , 1 ): ai ( g , 2 )), pref = pref ) else call self % clasg ( g )% sanitize_defaults endif self % error = self % clasg ( g )% error if ( self % error /= 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! trap the special cases of version/help printing if ( self % error == STATUS_PRINT_V ) then call self % print_version ( pref = pref ) stop elseif ( self % error == STATUS_PRINT_H ) then write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = g ) stop endif ! check if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call self % clasg ( g )% is_required_passed ( pref = pref ) self % error = self % clasg ( g )% error if ( self % error > 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! check mutually exclusive interaction call self % check_m_exclusive ( pref = pref ) self % is_parsed_ = . true . if ( present ( error )) error = self % error endsubroutine parse subroutine get_clasg_indexes ( self , ai ) !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. allocate ( ai ( 0 : size ( self % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( self % args )) then Na = size ( self % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( self % is_defined_group ( group = trim ( self % args ( a )), g = g )) then found = . true . self % clasg ( g )% is_called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( self % is_defined_group ( group = trim ( self % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 self % clasg ( 0 )% is_called = . true . elseif ( all ( ai == 0 )) then self % clasg ( 0 )% is_called = . true . endif else self % clasg ( 0 )% is_called = . true . endif endsubroutine get_clasg_indexes subroutine get_args_from_string ( self , args , ai ) !< Get CLAs from string. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif ! prepare CLI arguments list if ( allocated ( self % args )) deallocate ( self % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate CLI arguments list #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: self % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 self % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call self % get_clasg_indexes ( ai = ai ) contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. character ( * ), intent ( in ) :: argsin !< Arguments string. character ( * ), intent ( in ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( self , ai ) !< Get CLAs from CLI invocation. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. if ( allocated ( self % args )) deallocate ( self % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: self % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) self % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call self % get_clasg_indexes ( ai = ai ) endsubroutine get_args_from_invocation subroutine get_cla ( self , val , pref , args , group , switch , position , error ) !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( self % error == 0 ) then if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( position )% error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif endif if ( self % error == 0. and .(. not . self % clasg ( g )% is_called )) then ! TODO warn (if liked) for non invoked group querying endif if ( present ( error )) error = self % error endsubroutine get_cla subroutine get_cla_list ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list subroutine get_cla_list_varying_R16P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_char function usage ( self , g , pref , no_header , no_examples , no_epilog , markdown ) result ( usaged ) !< Print correct usage of CLI. class ( command_line_interface ), intent ( in ) :: self !< CLI data. integer ( I4P ), intent ( in ) :: g !< Group index. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( in ) :: no_epilog !< Avoid insert epilogue to usage. logical , optional , intent ( in ) :: markdown !< Format things with markdown character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. logical :: markdownd !< Format for markdown. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = self % clasg ( g )% usage ( pref = prefd , no_header = no_headerd , markdown = markdownd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // self % help // self % progname // ' ' // self % signature () if ( self % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description endif if ( self % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // self % clasg ( 0 )% usage ( pref = prefd , no_header = . true ., markdown = markdownd ) if ( size ( self % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // self % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % progname // ' ' // self % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( self % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( self % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( self % examples ( e )) enddo endif if ( self % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // self % epilog endfunction usage function signature ( self ) !< Get signature. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: g !< Counter. signature = self % clasg ( 0 )% signature () if ( size ( self % clasg , dim = 1 ) > 1 ) then signature = signature // ' {' // self % clasg ( 1 )% group do g = 2 , size ( self % clasg , dim = 1 ) - 1 signature = signature // ',' // self % clasg ( g )% group enddo signature = signature // '} ...' endif endfunction signature subroutine print_usage ( self , pref ) !< Print correct usage. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = 0 ) endsubroutine print_usage subroutine save_man_page ( self , man_file , error ) !< Save man page build on the CLI. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. call date_and_time ( values = idate ) man = '.TH ' // self % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // self % version // & '\" \"' // self % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // self % progname // ' - manual page for ' // self % progname // ' version ' // self % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // self % progname // new_line ( 'a' ) // trim ( adjustl ( self % signature ())) if ( self % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( self % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( self % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // self % authors if ( self % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // self % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) endsubroutine save_man_page subroutine save_usage_to_markdown ( self , markdown_file , error ) !< Save the CLI as a markdown page, for inclusion into the documentation. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: markdown_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. ! add the other tags here. man = '' ! add the short description if ( self % description /= '' ) man = man // new_line ( 'a' ) // '### Short description' // new_line ( 'a' ) // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // new_line ( 'a' ) // '### Command line options:' man = man // new_line ( 'a' ) // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 , markdown = . true .) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '### Examples' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) man = man // new_line ( 'a' ) // '`' // trim ( self % examples ( e )) // '` ' enddo endif open ( newunit = u , file = trim ( adjustl ( markdown_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) endsubroutine save_usage_to_markdown ! private methods subroutine errored ( self , error , pref , group , switch ) !< Trig error occurrence and print meaningful message. class ( command_line_interface ), intent ( inout ) :: self !< Object data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Group name. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_MISSING_CLA ) self % error_message = prefd // ': there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( ERROR_MISSING_SELECTION_CLA ) self % error_message = prefd // ': to get an option value one of switch \"name\" or \"position\" must be provided!' case ( ERROR_MISSING_GROUP ) self % error_message = prefd // ': ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( ERROR_TOO_FEW_CLAS ) ! self%error_message = prefd//': too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,self%Na_required))//')' endselect write ( self % error_lun , '(A)' ) call self % print_error_message endif endsubroutine errored elemental subroutine cli_assign_cli ( lhs , rhs ) !< Assignment operator. class ( command_line_interface ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_interface ), intent ( in ) :: rhs !< Right hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv endsubroutine cli_assign_cli elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_interface ), intent ( inout ) :: self !< CLI data. call self % free endsubroutine finalize endmodule flap_command_line_interface_t","tags":"","loc":"sourcefile/flap_command_line_interface_t.f90.html","title":"flap_command_line_interface_t.F90 – FORESEER"},{"text":"Command Line Arguments Group (CLAsG) class. This File Depends On sourcefile~~flap_command_line_arguments_group_t.f90~~EfferentGraph sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~face.f90 face.f90 sourcefile~face.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 var pansourcefileflap_command_line_arguments_group_tf90EfferentGraph = svgPanZoom('#sourcefileflap_command_line_arguments_group_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_command_line_arguments_group_t.f90~~AfferentGraph sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefileflap_command_line_arguments_group_tf90AfferentGraph = svgPanZoom('#sourcefileflap_command_line_arguments_group_tf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_command_line_arguments_group_t Source Code flap_command_line_arguments_group_t.f90 Source Code !< Command Line Arguments Group (CLAsG) class. module flap_command_line_arguments_group_t !< Command Line Arguments Group (CLAsG) class. use face , only : colorize use flap_command_line_argument_t , only : command_line_argument , & ACTION_PRINT_HELP , & ACTION_PRINT_VERS , & ACTION_STORE , & ACTION_STORE_STAR , & ARGS_SEP use flap_object_t , only : object use penf implicit none private save public :: command_line_arguments_group public :: STATUS_PRINT_V public :: STATUS_PRINT_H type , extends ( object ) :: command_line_arguments_group !< Command Line Arguments Group (CLAsG) class. !< !< CLAsG are useful for building nested commands. private character ( len = :), allocatable , public :: group !< Group name (command). integer ( I4P ), public :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of required command line arguments. integer ( I4P ) :: Na_optional = 0_I4P !< Number of optional command line arguments. type ( command_line_argument ), allocatable , public :: cla (:) !< CLA list [1:Na]. logical , public :: is_called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLAs are passed. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: add !< Add CLA to CLAsG. procedure , public :: parse !< Parse CLAsG arguments. procedure , public :: usage !< Get correct CLAsG usage. procedure , public :: signature !< Get CLAsG signature. procedure , public :: sanitize_defaults !< Sanitize default values. ! private methods procedure , private :: errored !< Trig error occurrence and print meaningful message. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs have been passed. procedure , private :: clasg_assign_clasg !< Assignment operator. generic , private :: assignment ( = ) => clasg_assign_clasg !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_arguments_group ! status codes integer ( I4P ), parameter :: STATUS_PRINT_V = - 1 !< Print version status. integer ( I4P ), parameter :: STATUS_PRINT_H = - 2 !< Print help status. ! errors codes integer ( I4P ), parameter :: ERROR_CONSISTENCY = 23 !< CLAs group consistency error. integer ( I4P ), parameter :: ERROR_M_EXCLUDE = 24 !< Two mutually exclusive CLAs group have been called. contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_arguments_group members if ( allocated ( self % group )) deallocate ( self % group ) if ( allocated ( self % cla )) then call self % cla % free deallocate ( self % cla ) endif self % Na = 0_I4P self % Na_required = 0_I4P self % Na_optional = 0_I4P self % is_called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! verify if CLAs switches are unique CLA_unique : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then do aa = 1 , self % Na if (( a /= aa ). and .(. not . self % cla ( aa )% is_positional )) then if (( self % cla ( a )% switch == self % cla ( aa )% switch ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch ). or .& ( self % cla ( a )% switch == self % cla ( aa )% switch_ab ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch_ab )) then call self % errored ( pref = pref , error = ERROR_CONSISTENCY , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! update mutually exclusive relations CLA_exclude : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_defined ( switch = self % cla ( a )% m_exclude , pos = aa )) then self % cla ( aa )% m_exclude = self % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine is_required_passed ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_required_passed ( pref = pref )) then self % error = self % cla ( a )% error write ( self % usage_lun , '(A)' ) self % usage ( pref = pref ) return endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine is_required_passed pure function is_passed ( self , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_passed = . false . if ( self % Na > 0 ) then if ( present ( switch )) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_passed = self % cla ( a )% is_passed exit endif endif enddo elseif ( present ( position )) then is_passed = self % cla ( position )% is_passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_passed function is_defined ( self , switch , pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( out ) :: pos !< CLA position. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_defined = . false . if ( present ( pos )) pos = 0 if ( self % Na > 0 ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude subroutine add ( self , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. type ( command_line_argument ), intent ( in ) :: cla !< CLA data. type ( command_line_argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % Na > 0_I4P ) then if (. not . cla % is_positional ) then allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , self % Na cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( self % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , self % Na + 1 cla_list_new ( c ) = self % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = self % cla ) self % Na = self % Na + 1 if ( cla % is_required ) then self % Na_required = self % Na_required + 1 else self % Na_optional = self % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) call self % check ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine parse ( self , args , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAsG arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), intent ( in ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , self % Na ! loop over CLAs group clas named options if (. not . self % cla ( a )% is_positional ) then if ( trim ( adjustl ( self % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( self % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then found_val = . false . if ( self % cla ( a )% act == action_store ) then if ( allocated ( self % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = self % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then self % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( self % cla ( a )% def )) then self % cla ( a )% val = self % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( self % cla ( a )% nargs )) then self % cla ( a )% val = '' select case ( self % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( self % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) enddo found_val = . true . arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call self % cla ( a )% raise_error_value_missing ( pref = pref ) self % error = self % cla ( a )% error return endif arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( self % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! flush default to val if default is set if ( allocated ( self % cla ( a )% def )) self % cla ( a )% val = self % cla ( a )% def endif elseif ( self % cla ( a )% act == action_print_help ) then self % error = STATUS_PRINT_H elseif ( self % cla ( a )% act == action_print_vers ) then self % error = STATUS_PRINT_V endif self % cla ( a )% is_passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . self % cla ( arg )% is_positional ) then ! current argument (arg-th) is not positional... there is a problem! call self % cla ( arg )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error return else ! positional CLA always stores a value self % cla ( arg )% val = trim ( adjustl ( args ( arg ))) self % cla ( arg )% is_passed = . true . endif endif enddo call self % check_m_exclusive ( pref = pref ) call self % sanitize_defaults endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse function usage ( self , pref , no_header , markdown ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAsG usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: markdown !< Format things form markdown. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: markdownd !< Markdonw format, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref usage = self % progname ; if ( self % group /= '' ) usage = self % progname // ' ' // self % group usage = prefd // self % help // ' ' // usage // self % signature () if ( self % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( self % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , self % Na if ( self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif if ( self % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , self % Na if (. not . self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAsG signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signature = '' do a = 1 , self % Na signature = signature // self % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature ! private methods subroutine errored ( self , error , pref , a1 , a2 ) !< Trig error occurrence and print meaningful message. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( in ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( in ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_CONSISTENCY ) if ( self % group /= '' ) then self % error_message = prefd // ': group (command) name: \"' // self % group // '\" consistency error:' else self % error_message = prefd // ': consistency error:' endif self % error_message = self % error_message // ' \"' // trim ( str ( a1 , . true .)) // & '-th\" option has the same switch or abbreviated switch of \"' // & trim ( str ( a2 , . true .)) // '-th\" option:' // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a1 , . true .)) // ') switches = ' // self % cla ( a1 )% switch // ' ' // & self % cla ( a1 )% switch_ab // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a2 , . true .)) // ') switches = ' // self % cla ( a2 )% switch // ' ' // & self % cla ( a2 )% switch_ab case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the group \"' // self % group // '\" and \"' // self % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect call self % print_error_message endif endsubroutine errored subroutine check_m_exclusive ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if ( self % cla ( a )% is_passed ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_passed ( switch = self % cla ( a )% m_exclude )) then call self % cla ( a )% raise_error_m_exclude ( pref = pref ) self % error = self % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na call self % cla ( a )% sanitize_defaults enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults elemental subroutine clasg_assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( INOUT ) :: lhs !< Left hand side. type ( command_line_arguments_group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_arguments_group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % is_called = rhs % is_called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine clasg_assign_clasg elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule flap_command_line_arguments_group_t","tags":"","loc":"sourcefile/flap_command_line_arguments_group_t.f90.html","title":"flap_command_line_arguments_group_t.f90 – FORESEER"},{"text":"FLAP utils. This File Depends On sourcefile~~flap_utils_m.f90~~EfferentGraph sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileflap_utils_mf90EfferentGraph = svgPanZoom('#sourcefileflap_utils_mf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_utils_m.f90~~AfferentGraph sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 var pansourcefileflap_utils_mf90AfferentGraph = svgPanZoom('#sourcefileflap_utils_mf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_utils_m Source Code flap_utils_m.f90 Source Code !< FLAP utils. module flap_utils_m !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP utils. !----------------------------------------------------------------------------------------------------------------------------------- use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: count public :: replace public :: replace_all public :: tokenize public :: unique public :: upper_case public :: wstrip !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface count !< Overload intrinsic function count for counting substring occurences into strings. module procedure count_substring endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function count_substring ( string , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string )) return c1 = 1 do c2 = index ( string = string ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring pure function replace ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (only first occurrence) into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. integer ( I4P ) :: pos !< Position from which replace the substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos = index ( string = string , substring = substring ) newstring = string if ( pos > 0 ) then if ( pos == 1 ) then newstring = restring // string ( len ( substring ) + 1 :) else newstring = string ( 1 : pos - 1 ) // restring // string ( pos + len ( substring ):) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace pure function replace_all ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (all occurrences) into a string. !< !< @note Leading and trailing white spaces are stripped out. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- newstring = wstrip ( string ) do if ( index ( newstring , substring ) > 0 ) then newstring = replace ( string = newstring , substring = substring , restring = restring ) else exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_all pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to input string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: strin !< String to be tokenized. character ( len =* ), intent ( in ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( out ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( out ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = strin ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize elemental function unique ( string , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be parsed. character ( len =* ), intent ( in ) :: substring !< Substring which multiple occurences must be reduced to one. character ( len = len ( string )) :: uniq !< String parsed. integer ( I4P ) :: Lsub !< Lenght of substring. integer ( I4P ) :: c1 !< Counter. integer ( I4P ) :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- uniq = string Lsub = len ( substring ) if ( Lsub > len ( string )) return c1 = 1 Loop1 : do if ( c1 >= len_trim ( uniq )) exit Loop1 if ( uniq ( c1 : c1 + Lsub - 1 ) == substring . and . uniq ( c1 + Lsub : c1 + 2 * Lsub - 1 ) == substring ) then c2 = c1 + Lsub Loop2 : do if ( c2 >= len_trim ( uniq )) exit Loop2 if ( uniq ( c2 : c2 + Lsub - 1 ) == substring ) then c2 = c2 + Lsub else exit Loop2 endif enddo Loop2 uniq = uniq ( 1 : c1 ) // uniq ( c2 :) else c1 = c1 + Lsub endif enddo Loop1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique elemental function upper_case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be converted. character ( len = len ( string )) :: upper_case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- upper_case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) upper_case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper_case pure function wstrip ( string ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Strip out leading and trailing white spaces from a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( newstring , source = trim ( adjustl ( string ))) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction wstrip endmodule flap_utils_m","tags":"","loc":"sourcefile/flap_utils_m.f90.html","title":"flap_utils_m.f90 – FORESEER"},{"text":"Command Line Argument (CLA) class. This File Depends On sourcefile~~flap_command_line_argument_t.f90~~EfferentGraph sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~face.f90 face.f90 sourcefile~face.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileflap_command_line_argument_tf90EfferentGraph = svgPanZoom('#sourcefileflap_command_line_argument_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_command_line_argument_t.f90~~AfferentGraph sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 var pansourcefileflap_command_line_argument_tf90AfferentGraph = svgPanZoom('#sourcefileflap_command_line_argument_tf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_command_line_argument_t Source Code flap_command_line_argument_t.F90 Source Code !< Command Line Argument (CLA) class. module flap_command_line_argument_t !< Command Line Argument (CLA) class. use face , only : colorize use flap_object_t , only : object use flap_utils_m use penf implicit none private save public :: command_line_argument public :: ACTION_STORE public :: ACTION_STORE_STAR public :: ACTION_STORE_TRUE public :: ACTION_STORE_FALSE public :: ACTION_PRINT_HELP public :: ACTION_PRINT_VERS public :: ARGS_SEP type , extends ( object ) :: command_line_argument !< Command Line Argument (CLA) class. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable , public :: switch !< Switch name. character ( len = :), allocatable , public :: switch_ab !< Abbreviated switch name. logical , public :: is_required = . false . !< Flag for set required argument. logical , public :: is_positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), public :: position = 0_I4P !< Position of positional CLA. logical , public :: is_passed = . false . !< Flag for checking if CLA has been passed to CLI. logical , public :: is_hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable , public :: act !< CLA value action. character ( len = :), allocatable , public :: def !< Default value. character ( len = :), allocatable , public :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable , public :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable , public :: val !< CLA value. character ( len = :), allocatable , public :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLA is passed. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: raise_error_nargs_insufficient !< Raise error insufficient number of argument values passed. procedure , public :: raise_error_value_missing !< Raise error missing value. procedure , public :: raise_error_switch_unknown !< Raise error switch_unknown. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s). generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from varying size list. procedure , public :: sanitize_defaults !< Sanitize default values. procedure , public :: usage !< Get correct usage. procedure , public :: signature !< Get signature. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check_envvar_consistency !< Check data consistency for envvar CLA. procedure , private :: check_action_consistency !< Check CLA action consistency. procedure , private :: check_optional_consistency !< Check optional CLA consistency. procedure , private :: check_m_exclude_consistency !< Check mutually exclusion consistency. procedure , private :: check_named_consistency !< Check named CLA consistency. procedure , private :: check_positional_consistency !< Check positional CLA consistency. procedure , private :: check_choices !< Check if CLA value is in allowed choices. procedure , private :: check_list_size !< Check CLA multiple values list size consistency. procedure , private :: get_cla !< Get CLA (single) value. procedure , private :: get_cla_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list !< Get CLA multiple values. procedure , private :: get_cla_list_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values, varying size, char. procedure , private :: cla_assign_cla !< Assignment operator. generic , private :: assignment ( = ) => cla_assign_cla !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_argument ! parameters character ( len =* ), parameter :: ACTION_STORE = 'STORE' !< Store value (if invoked a value must be passed). character ( len =* ), parameter :: ACTION_STORE_STAR = 'STORE*' !< Store value or revert on default is invoked alone. character ( len =* ), parameter :: ACTION_STORE_TRUE = 'STORE_TRUE' !< Store .true. without the necessity of a value. character ( len =* ), parameter :: ACTION_STORE_FALSE = 'STORE_FALSE' !< Store .false. without the necessity of a value. character ( len =* ), parameter :: ACTION_PRINT_HELP = 'PRINT_HELP' !< Print help message. character ( len =* ), parameter :: ACTION_PRINT_VERS = 'PRINT_VERSION' !< Print version. character ( len =* ), parameter :: ARGS_SEP = '||!||' !< Arguments separator for multiple valued (list) CLA. ! errors codes integer ( I4P ), parameter :: ERROR_OPTIONAL_NO_DEF = 1 !< Optional CLA without default value. integer ( I4P ), parameter :: ERROR_REQUIRED_M_EXCLUDE = 2 !< Required CLA cannot exclude others. integer ( I4P ), parameter :: ERROR_POSITIONAL_M_EXCLUDE = 3 !< Positional CLA cannot exclude others. integer ( I4P ), parameter :: ERROR_NAMED_NO_NAME = 4 !< Named CLA without switch name. integer ( I4P ), parameter :: ERROR_POSITIONAL_NO_POSITION = 5 !< Positional CLA without position. integer ( I4P ), parameter :: ERROR_POSITIONAL_NO_STORE = 6 !< Positional CLA without action_store. integer ( I4P ), parameter :: ERROR_NOT_IN_CHOICES = 7 !< CLA value out of a specified choices. integer ( I4P ), parameter :: ERROR_MISSING_REQUIRED = 8 !< Missing required CLA. integer ( I4P ), parameter :: ERROR_M_EXCLUDE = 9 !< Two mutually exclusive CLAs have been passed. integer ( I4P ), parameter :: ERROR_CASTING_LOGICAL = 10 !< Error casting CLA value to logical type. integer ( I4P ), parameter :: ERROR_CHOICES_LOGICAL = 11 !< Error adding choices check for CLA val of logical type. integer ( I4P ), parameter :: ERROR_NO_LIST = 12 !< Actual CLA is not list-values. integer ( I4P ), parameter :: ERROR_NARGS_INSUFFICIENT = 13 !< Multi-valued CLA with insufficient arguments. integer ( I4P ), parameter :: ERROR_VALUE_MISSING = 14 !< Missing value of CLA. integer ( I4P ), parameter :: ERROR_UNKNOWN = 15 !< Unknown CLA (switch name). integer ( I4P ), parameter :: ERROR_ENVVAR_POSITIONAL = 16 !< Envvar not allowed for positional CLA. integer ( I4P ), parameter :: ERROR_ENVVAR_NOT_STORE = 17 !< Envvar not allowed action different from store; integer ( I4P ), parameter :: ERROR_ENVVAR_NARGS = 18 !< Envvar not allowed for list-values CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_POSITIONAL = 19 !< Action store* not allowed for positional CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_NARGS = 20 !< Action store* not allowed for list-values CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_ENVVAR = 21 !< Action store* not allowed for environment variable CLA. integer ( I4P ), parameter :: ERROR_ACTION_UNKNOWN = 22 !< Unknown CLA (switch name). contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_argument members if ( allocated ( self % switch )) deallocate ( self % switch ) if ( allocated ( self % switch_ab )) deallocate ( self % switch_ab ) if ( allocated ( self % act )) deallocate ( self % act ) if ( allocated ( self % def )) deallocate ( self % def ) if ( allocated ( self % nargs )) deallocate ( self % nargs ) if ( allocated ( self % choices )) deallocate ( self % choices ) if ( allocated ( self % val )) deallocate ( self % val ) if ( allocated ( self % envvar )) deallocate ( self % envvar ) self % is_required = . false . self % is_positional = . false . self % position = 0_I4P self % is_passed = . false . self % is_hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % check_envvar_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_action_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_optional_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_m_exclude_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_named_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_positional_consistency ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check function is_required_passed ( self , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLA is passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if (((. not . self % is_passed ). and . self % is_required ). or .((. not . self % is_passed ). and .(. not . allocated ( self % def )))) then call self % errored ( pref = pref , error = ERROR_MISSING_REQUIRED ) is_ok = . false . endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_required_passed subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude subroutine raise_error_nargs_insufficient ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error insufficient number of argument values passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_nargs_insufficient subroutine raise_error_value_missing ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error missing value. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_VALUE_MISSING ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_value_missing subroutine raise_error_switch_unknown ( self , switch , pref ) !< Raise error switch_unknown. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_UNKNOWN , switch = switch ) endsubroutine raise_error_switch_unknown subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_passed ) then if ( allocated ( self % def )) then ! strip leading and trailing white spaces self % def = wstrip ( self % def ) if ( allocated ( self % nargs )) then ! replace white space separator with FLAP ARGS_SEP self % def = unique ( string = self % def , substring = ' ' ) self % def = replace_all ( string = self % def , substring = ' ' , restring = ARGS_SEP ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults function usage ( self , pref , markdown ) !< Get correct usage. class ( command_line_argument ), intent ( in ) :: self !< CLAs group data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: markdown !< Format for markdown character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: switch_ !< Switch name, local variable. character ( len = :), allocatable :: switch_ab_ !< Abbreviated switch name, local variable. integer ( I4P ) :: a !< Counter. logical :: markdownd !< Format for markdown integer :: indent !< how many spaces to indent markdownd = . false . ; if ( present ( markdown )) markdownd = markdown indent = 4 switch_ = colorize ( trim ( adjustl ( self % switch )), color_fg = self % help_color , style = self % help_style ) switch_ab_ = colorize ( trim ( adjustl ( self % switch_ab )), color_fg = self % help_color , style = self % help_style ) if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then usage = '' select case ( self % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str ( a , . true .)) enddo endselect if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`, `' // trim ( adjustl ( self % switch_ab )) // usage // '`' else usage = '   ' // switch_ // usage // ', ' // switch_ab_ // usage endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`' else usage = '   ' // switch_ // usage endif endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`, `' // trim ( adjustl ( self % switch_ab )) // ' value' // '`' else usage = '   ' // switch_ // ' value, ' // switch_ab_ // ' value' endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`' else usage = '   ' // switch_ // ' value' endif endif endif else usage = '  value' endif if ( allocated ( self % choices )) then usage = usage // ', value in: `' // self % choices // '`' endif elseif ( self % act == action_store_star ) then usage = '  [value]' if ( allocated ( self % choices )) then usage = usage // ', value in: (' // self % choices // ')' endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`, `' // trim ( adjustl ( self % switch_ab )) // '`' else usage = '   ' // switch_ // ', ' // switch_ab_ endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`' else usage = '   ' // switch_ endif endif endif prefd = '' ; if ( present ( pref )) prefd = pref usage = prefd // usage if ( self % is_positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( str ( self % position , . true .)) // & '-th argument' if ( allocated ( self % envvar )) then if ( self % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( self % envvar )) // '\"' endif endif if (. not . self % is_required ) then if ( self % def /= '' ) then if ( markdownd ) then ! two spaces make a line break in markdown. usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) endif endif endif if ( self % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'mutually exclude \"' // self % m_exclude // '\"' if ( markdownd ) then usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // trim ( adjustl ( self % help )) if ( self % help_markdown /= '' ) then usage = usage // trim ( adjustl ( self % help_markdown )) endif else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( adjustl ( self % help )) endif else usage = '' endif endfunction usage function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( in ) :: self !< CLA data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then select case ( self % nargs ) case ( '+' ) signature = ' value#1 [value#2 value#3...]' case ( '*' ) signature = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) signature = '' do a = 1 , nargs signature = signature // ' value#' // trim ( str ( a , . true .)) enddo endselect else signature = ' value' endif if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) // signature else signature = ' [' // trim ( adjustl ( self % switch )) // signature // ']' endif else if ( self % is_required ) then signature = ' value' else signature = ' [value]' endif endif elseif ( self % act == action_store_star ) then signature = ' [value]' else if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) else signature = ' [' // trim ( adjustl ( self % switch )) // ']' endif endif else signature = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature ! private methods subroutine errored ( self , error , pref , switch , val_str , log_value ) !< Trig error occurence and print meaningful message. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: val_str !< Value string. character ( * ), optional , intent ( in ) :: log_value !< Logical value to be casted. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_OPTIONAL_NO_DEF ) if ( self % is_positional ) then self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // '-th\" positional option has not a default value!' else self % error_message = prefd // ': named option \"' // self % switch // '\" has not a default value!' endif case ( ERROR_REQUIRED_M_EXCLUDE ) self % error_message = prefd // ': named option \"' // self % switch // '\" cannot exclude others' // & ', it being required, only optional ones can!' case ( ERROR_POSITIONAL_M_EXCLUDE ) self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( ERROR_NAMED_NO_NAME ) self % error_message = prefd // ': a non positional optiona must have a switch name!' case ( ERROR_POSITIONAL_NO_POSITION ) self % error_message = prefd // ': a positional option must have a position number different from 0!' case ( ERROR_POSITIONAL_NO_STORE ) self % error_message = prefd // ': a positional option must have action set to \"' // action_store // '\"!' case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the options \"' // self % switch // '\" and \"' // self % m_exclude // & '\" are mutually exclusive, but both have been passed!' case ( ERROR_NOT_IN_CHOICES ) if ( self % is_positional ) then self % error_message = prefd // ': value of \"' // trim ( str ( n = self % position )) // & '-th\" positional option must be chosen in:' else self % error_message = prefd // ': value of named option \"' // self % switch // '\" must be chosen in: ' endif self % error_message = self % error_message // '(' // self % choices // ')' self % error_message = self % error_message // ' but \"' // trim ( val_str ) // '\" has been passed!' case ( ERROR_MISSING_REQUIRED ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" is required!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option is required!' endif case ( ERROR_CASTING_LOGICAL ) self % error_message = prefd // ': cannot convert \"' // log_value // '\" of option \"' // self % switch // '\" to logical type!' case ( ERROR_CHOICES_LOGICAL ) self % error_message = prefd // ': cannot use \"choices\" value check for option \"' // self % switch // & '\" it being of logical type! The choices are limited to \".true.\" or \".false.\" by definition!' case ( ERROR_NO_LIST ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has not \"nargs\" value but an array has been passed to \"get\" method!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( ERROR_NARGS_INSUFFICIENT ) if (. not . self % is_positional ) then if ( self % nargs == '+' ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" requires at least 1 argument but no one remains!' else self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif else if ( self % nargs == '+' ) then self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires at least 1 argument but no one remains' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif endif case ( ERROR_VALUE_MISSING ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" needs a value that is not passed!' case ( ERROR_UNKNOWN ) self % error_message = prefd // ': switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( ERROR_ENVVAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( ERROR_ENVVAR_NOT_STORE ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( ERROR_ENVVAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( ERROR_STORE_STAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( ERROR_STORE_STAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( ERROR_STORE_STAR_ENVVAR ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( ERROR_ACTION_UNKNOWN ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" has unknown \"' // self % act // '\" action!' endselect call self % print_error_message endif endsubroutine errored subroutine check_envvar_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency for envvar CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % envvar )) then if ( self % is_positional ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_POSITIONAL ) return endif if (. not . allocated ( self % act )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return else if ( self % act /= action_store ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return endif endif if ( allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NARGS ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_envvar_consistency subroutine check_action_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA action consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % act )) then if ( self % act == ACTION_STORE_STAR . and . self % is_positional ) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_POSITIONAL ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_NARGS ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % envvar )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_ENVVAR ) return endif if ( self % act /= ACTION_STORE . and . & self % act /= ACTION_STORE_STAR . and . & self % act /= ACTION_STORE_TRUE . and . & self % act /= ACTION_STORE_FALSE . and .& self % act /= ACTION_PRINT_HELP . and . & self % act /= ACTION_PRINT_VERS ) then call self % errored ( pref = pref , error = ERROR_ACTION_UNKNOWN ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_action_consistency subroutine check_optional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check optional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_required ). and .(. not . allocated ( self % def ))) call self % errored ( pref = pref , error = ERROR_OPTIONAL_NO_DEF ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_optional_consistency subroutine check_m_exclude_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check mutually exclusion consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_required ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_REQUIRED_M_EXCLUDE ) return endif if (( self % is_positional ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_M_EXCLUDE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclude_consistency subroutine check_named_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check named CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_positional ). and .(. not . allocated ( self % switch ))) call self % errored ( pref = pref , error = ERROR_NAMED_NO_NAME ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_named_consistency subroutine check_positional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check positional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_positional ). and .( self % position == 0_I4P )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_POSITION ) return elseif (( self % is_positional ). and .( self % act /= action_store )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_STORE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_positional_consistency subroutine check_choices ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( in ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len ( self % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = self % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) call self % errored ( pref = pref , error = ERROR_CHOICES_LOGICAL ) endselect if (. not . val_in . and .( self % error == 0 )) then call self % errored ( pref = pref , error = ERROR_NOT_IN_CHOICES , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices function check_list_size ( self , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: Nv !< Number of values. character ( * ), intent ( in ) :: val !< First value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size subroutine get_cla ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if ( self % act == action_store . or . self % act == action_store_star ) then if ( self % is_passed . and . allocated ( self % val )) then call self % get_cla_from_buffer ( buffer = self % val , val = val , pref = pref ) elseif ( allocated ( self % def )) then ! using default value call self % get_cla_from_buffer ( buffer = self % def , val = val , pref = pref ) endif if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val , pref = pref ) elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from parsed value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I1P ) type is ( logical ) read ( buffer , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = buffer ) type is ( character ( * )) val = buffer endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_from_buffer subroutine get_cla_list ( self , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call self % get_cla_list_from_buffer ( buffer = self % val , val = val , pref = pref ) else ! using default value call self % get_cla_list_from_buffer ( buffer = self % def , val = val , pref = pref ) endif elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list subroutine get_cla_list_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from a buffer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val ( 1 :) !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( buffer )), allocatable :: vals (:) !< String array of values based on buffer value. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = buffer , delimiter = args_sep , toks = vals , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R16P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I2P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I1P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( vals ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = vals ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = vals ( v ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_from_buffer subroutine get_cla_list_varying_R16P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( INOUT ) :: self !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char elemental subroutine cla_assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_argument ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % is_required = rhs % is_required lhs % is_positional = rhs % is_positional lhs % position = rhs % position lhs % is_passed = rhs % is_passed lhs % is_hidden = rhs % is_hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine cla_assign_cla elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule flap_command_line_argument_t","tags":"","loc":"sourcefile/flap_command_line_argument_t.f90.html","title":"flap_command_line_argument_t.F90 – FORESEER"},{"text":"Base (abstract) class upon which FLAP's concrete classes are built. This File Depends On sourcefile~~flap_object_t.f90~~EfferentGraph sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileflap_object_tf90EfferentGraph = svgPanZoom('#sourcefileflap_object_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_object_t.f90~~AfferentGraph sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefileflap_object_tf90AfferentGraph = svgPanZoom('#sourcefileflap_object_tf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_object_t Source Code flap_object_t.f90 Source Code !< Base (abstract) class upon which FLAP's concrete classes are built. module flap_object_t !< Base (abstract) class upon which FLAP's concrete classes are built. use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stderr => error_unit use penf implicit none private save type , abstract , public :: object !< Base (abstract) class upon which FLAP's concrete classes are built. character ( len = :), allocatable :: progname !< Program name. character ( len = :), allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), allocatable :: help_color !< ANSI color of help messages. character ( len = :), allocatable :: help_style !< ANSI style of help messages. character ( len = :), allocatable :: help_markdown !< Longer help message, markdown formatted. character ( len = :), allocatable :: description !< Detailed description. character ( len = :), allocatable :: license !< License description. character ( len = :), allocatable :: authors !< Authors list. character ( len = :), allocatable :: epilog !< Epilogue message. character ( len = :), allocatable :: m_exclude !< Mutually exclude other CLA(s group). character ( len = :), allocatable :: error_message !< Meaningful error message to standard-error. character ( len = :), allocatable :: error_color !< ANSI color of error messages. character ( len = :), allocatable :: error_style !< ANSI style of error messages. integer ( I4P ) :: error = 0_I4P !< Error trapping flag. integer ( I4P ) :: usage_lun = stderr !< Output unit to print help/usage messages integer ( I4P ) :: version_lun = stdout !< Output unit to print version message integer ( I4P ) :: error_lun = stderr !< Error unit to print error messages contains ! public methods procedure , pass ( self ) :: free_object !< Free dynamic memory. procedure , pass ( self ) :: print_version !< Print version. procedure , pass ( self ) :: print_error_message !< Print meaningful error message. procedure , pass ( lhs ) :: assign_object !< Assignment overloading. endtype object contains ! public methods elemental subroutine free_object ( self ) !< Free dynamic memory. class ( object ), intent ( inout ) :: self !< Object data. if ( allocated ( self % progname )) deallocate ( self % progname ) if ( allocated ( self % version )) deallocate ( self % version ) if ( allocated ( self % help )) deallocate ( self % help ) if ( allocated ( self % help_color )) deallocate ( self % help_color ) if ( allocated ( self % help_style )) deallocate ( self % help_style ) if ( allocated ( self % help_markdown )) deallocate ( self % help_markdown ) if ( allocated ( self % description )) deallocate ( self % description ) if ( allocated ( self % license )) deallocate ( self % license ) if ( allocated ( self % authors )) deallocate ( self % authors ) if ( allocated ( self % epilog )) deallocate ( self % epilog ) if ( allocated ( self % m_exclude )) deallocate ( self % m_exclude ) if ( allocated ( self % error_message )) deallocate ( self % error_message ) if ( allocated ( self % error_color )) deallocate ( self % error_color ) if ( allocated ( self % error_style )) deallocate ( self % error_style ) self % error = 0_I4P self % usage_lun = stderr self % version_lun = stdout self % error_lun = stderr endsubroutine free_object subroutine print_version ( self , pref ) !< Print version. class ( object ), intent ( in ) :: self !< Object data. character ( * ), intent ( in ), optional :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. prefd = '' ; if ( present ( pref )) prefd = pref write ( self % version_lun , '(A)' ) prefd // self % progname // ' version ' // self % version if ( self % license /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % license endif if ( self % authors /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % authors endif endsubroutine print_version subroutine print_error_message ( self ) !< Print meaningful error message to standard-error. class ( object ), intent ( in ) :: self !< Object data. write ( self % error_lun , '(A)' ) self % error_message write ( self % error_lun , '(A)' ) endsubroutine print_error_message elemental subroutine assign_object ( lhs , rhs ) !< Assign two abstract objects. class ( object ), intent ( inout ) :: lhs !< Left hand side. class ( object ), intent ( in ) :: rhs !< Rigth hand side. if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % help_color )) lhs % help_color = rhs % help_color if ( allocated ( rhs % help_style )) lhs % help_style = rhs % help_style if ( allocated ( rhs % help_markdown )) lhs % help_markdown = rhs % help_markdown if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude if ( allocated ( rhs % error_message )) lhs % error_message = rhs % error_message if ( allocated ( rhs % error_color )) lhs % error_color = rhs % error_color if ( allocated ( rhs % error_style )) lhs % error_style = rhs % error_style lhs % error = rhs % error lhs % usage_lun = rhs % usage_lun lhs % version_lun = rhs % version_lun lhs % error_lun = rhs % error_lun endsubroutine assign_object endmodule flap_object_t","tags":"","loc":"sourcefile/flap_object_t.f90.html","title":"flap_object_t.f90 – FORESEER"},{"text":"FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~flap.f90~~EfferentGraph sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~face.f90 face.f90 sourcefile~face.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~face.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefileflapf90EfferentGraph = svgPanZoom('#sourcefileflapf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap.f90~~AfferentGraph sourcefile~flap.f90 flap.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap Source Code flap.f90 Source Code !< FLAP, Fortran command Line Arguments Parser for poor people module flap !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP, Fortran command Line Arguments Parser for poor people !<{!README-FLAP.md!} !----------------------------------------------------------------------------------------------------------------------------------- use flap_command_line_argument_t , only : command_line_argument use flap_command_line_arguments_group_t , only : command_line_arguments_group use flap_command_line_interface_t , only : command_line_interface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: command_line_argument public :: command_line_arguments_group public :: command_line_interface !----------------------------------------------------------------------------------------------------------------------------------- endmodule flap","tags":"","loc":"sourcefile/flap.f90.html","title":"flap.f90 – FORESEER"},{"text":"FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. This File Depends On sourcefile~~foodie_integrator_backward_differentiation_formula.f90~~EfferentGraph sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_backward_differentiation_formula.f90~~AfferentGraph sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_backward_differentiation_formula Source Code foodie_integrator_backward_differentiation_formula.f90 Source Code !< FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. module foodie_integrator_backward_differentiation_formula !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Backward Differentiation Formula class scheme implemented is: !< !<  U&#94;{n+N_s} + \\sum_{s=1}&#94;{N_s} \\alpha_s U&#94;{n+N_s-s} = \\Delta t \\left[ \\beta R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !< where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients \\alpha_s and \\beta define the actual scheme, that is selected accordingly !< to the number of *steps* used. !< !< Currently, the following schemes are available: !< !< | ` Step ` | ` beta `   | ` alpha 1 `  | ` alpha 2 ` | ` alpha 3 `  | ` alpha 4 ` | ` alpha 5 ` | ` alpha 6 ` | !< |----------|------------|--------------|-------------|--------------|-------------|-------------|-------------| !< | ` 1 `    | `  1 `     | ` -1 `       |             |              |             |             |             | !< | ` 2 `    | ` 2/3 `    | ` -4/3 `     | ` 1/3 `     |              |             |             |             | !< | ` 3 `    | ` 6/11 `   | ` -18/11 `   | ` 9/11  `   | ` -2/11 `    |             |             |             | !< | ` 4 `    | ` 12/25 `  | ` -48/25 `   | ` 36/25 `   | ` -16/25 `   | ` 3/25 `    |             |             | !< | ` 5 `    | ` 60/137 ` | ` -300/137 ` | ` 300/137 ` | ` -200/137 ` | ` 75/137 `  | ` -12/137 ` |             | !< | ` 6 `    | ` 60/147 ` | ` -360/147 ` | ` 450/147 ` | ` -400/147 ` | ` 225/147 ` | ` -72/147 ` | ` 10/147 `  | !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: back_df_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '1-6' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 6 !< Maximum number of steps supported. type :: back_df_integrator !< FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order !< accurate. !< !< @note The integrator must be created or initialized (initialize the *alpha* and *beta* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: a (:) !< \\alpha coefficients. real ( R_P ) :: b = 0.0_R_P !< \\beta coefficient. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype back_df_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual BDF integrator: initialize the *alpha* and *beta* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % a )) deallocate ( self % a ) ; allocate ( self % a ( 1 : steps )) ; self % a = 0.0_R_P select case ( steps ) case ( 1 ) self % a ( 1 ) = - 1.0_R_P self % b = 1.0_R_P case ( 2 ) self % a ( 1 ) = 1.0_R_P / 3.0_R_P self % a ( 2 ) = - 4.0_R_P / 3.0_R_P self % b = 2.0_R_P / 3.0_R_P case ( 3 ) self % a ( 1 ) = - 2.0_R_P / 1 1.0_R_P self % a ( 2 ) = 9.0_R_P / 1 1.0_R_P self % a ( 3 ) = - 1 8.0_R_P / 1 1.0_R_P self % b = 6.0_R_P / 1 1.0_R_P case ( 4 ) self % a ( 1 ) = 3.0_R_P / 2 5.0_R_P self % a ( 2 ) = - 1 6.0_R_P / 2 5.0_R_P self % a ( 3 ) = 3 6.0_R_P / 2 5.0_R_P self % a ( 4 ) = - 4 8.0_R_P / 2 5.0_R_P self % b = 1 2.0_R_P / 2 5.0_R_P case ( 5 ) self % a ( 1 ) = - 1 2.0_R_P / 13 7.0_R_P self % a ( 2 ) = 7 5.0_R_P / 13 7.0_R_P self % a ( 3 ) = - 20 0.0_R_P / 13 7.0_R_P self % a ( 4 ) = 30 0.0_R_P / 13 7.0_R_P self % a ( 5 ) = - 30 0.0_R_P / 13 7.0_R_P self % b = 6 0.0_R_P / 13 7.0_R_P case ( 6 ) self % a ( 1 ) = 1 0.0_R_P / 14 7.0_R_P self % a ( 2 ) = - 7 2.0_R_P / 14 7.0_R_P self % a ( 3 ) = 22 5.0_R_P / 14 7.0_R_P self % a ( 4 ) = - 40 0.0_R_P / 14 7.0_R_P self % a ( 5 ) = 45 0.0_R_P / 14 7.0_R_P self % a ( 6 ) = - 36 0.0_R_P / 14 7.0_R_P self % b = 6 0.0_R_P / 14 7.0_R_P case default ! bad (unsupported) number of required time steps self % error = 1 endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 1 if ( allocated ( self % a )) deallocate ( self % a ) self % b = 0.0_R_P self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with BDF class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. integer ( I_P ) :: iterations_ !< Fixed point iterations. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate iterations_ = 1 ; if ( present ( iterations )) iterations_ = iterations allocate ( delta , source = previous ( self % steps ) * ( - self % a ( self % steps ))) do s = 1 , self % steps - 1 delta = delta + previous ( s ) * ( - self % a ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous endmodule foodie_integrator_backward_differentiation_formula","tags":"","loc":"sourcefile/foodie_integrator_backward_differentiation_formula.f90.html","title":"foodie_integrator_backward_differentiation_formula.f90 – FORESEER"},{"text":"Define the abstract type integrand for building FOODIE ODE integrators. This File Depends On sourcefile~~foodie_adt_integrand.f90~~EfferentGraph sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_adt_integrand.f90~~AfferentGraph sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 var pansourcefilefoodie_adt_integrandf90AfferentGraph = svgPanZoom('#sourcefilefoodie_adt_integrandf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_adt_integrand Source Code foodie_adt_integrand.f90 Source Code !< Define the abstract type *integrand* for building FOODIE ODE integrators. module foodie_adt_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODIE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). function time_derivative ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: self !< Integrand field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative function local_error_operator ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 solution approximations. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. !--------------------------------------------------------------------------------------------------------------------------------- endfunction local_error_operator function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator #ifdef PURE ! declare this pure should not be necessary, but this is a temporary workaround for a possible GNU gfortran bug. pure subroutine assignment_integrand ( lhs , rhs ) #else subroutine assignment_integrand ( lhs , rhs ) #endif !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_adt_integrand","tags":"","loc":"sourcefile/foodie_adt_integrand.f90.html","title":"foodie_adt_integrand.f90 – FORESEER"},{"text":"FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. This File Depends On sourcefile~~foodie_integrator_tvd_runge_kutta.f90~~EfferentGraph sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_tvd_runge_kutta.f90~~AfferentGraph sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_tvd_runge_kutta Source Code foodie_integrator_tvd_runge_kutta.f90 Source Code !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !<``` !<  0 | 0 !< ---|--- !<    | 1 !<``` !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. !<``` !<  0 | 0     0 !<  1 | 1     0 !< ---|----------- !<    | 1/2   1/2 !<``` !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. !<``` !<  0   | 0     0     0 !<  1   | 1     0     0 !<  1/2 | 1/4   1/4   0 !< -----|----------------- !<      | 1/6   1/6   1/3 !<``` !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. !<``` !<  0                | 0                  0                  0                  0                  0 !<  0.39175222700392 | 0.39175222700392   0                  0                  0                  0 !<  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0 !<  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0 !<  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0 !< ------------------|--------------------------------------------------------------------------------------------- !<                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 !<``` !< !<#### Bibliography !< !< [1] *Coefficients for the study of Runge-Kutta integration processes*, Butcher, J.C., J. Austral. Math. Soc., Vol. 3, !< pages: 185--201, 1963. !< !< [2] *High Order Strong Stability Preserving Time Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of !< Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : R_P , I_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_stages = '1-3,5' !< List of supported stages number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of stages supported. integer ( I_P ), parameter :: max_ss = 5 !< Maximum number of stages supported. type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages pure function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – FORESEER"},{"text":"FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. This File Depends On sourcefile~~foodie_integrator_euler_explicit.f90~~EfferentGraph sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_euler_explicit.f90~~AfferentGraph sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_euler_explicit Source Code foodie_integrator_euler_explicit.f90 Source Code !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 1 ), parameter :: supported_stages_steps = '1' !< List of supported stages/steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of stages/steps supported. integer ( I_P ), parameter :: max_ss = 1 !< Maximum number of stages/steps supported. type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. private contains private procedure , nopass , public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages_steps !< Return the minimum number of stages/steps supported. procedure , nopass , public :: max_stages_steps !< Return the maximum number of stages/steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages/steps is supported or not. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function min_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages_steps !< Minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages_steps pure function max_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages_steps !< Maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages_steps elemental function is_supported ( stages_steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages/steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages_steps !< Number of stages/steps used. logical :: is_supported !< Is true is the stages number is in *supported_stages_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages_steps , adm_range = trim ( supported_stages_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FORESEER"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Files Dependent On This One sourcefile~~foodie_kinds.f90~~AfferentGraph sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilefoodie_kindsf90AfferentGraph = svgPanZoom('#sourcefilefoodie_kindsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_kinds Source Code foodie_kinds.f90 Source Code !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. module foodie_kinds !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie_kinds","tags":"","loc":"sourcefile/foodie_kinds.f90.html","title":"foodie_kinds.f90 – FORESEER"},{"text":"FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. This File Depends On sourcefile~~foodie_integrator_leapfrog.f90~~EfferentGraph sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_leapfrog.f90~~AfferentGraph sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_leapfrog Source Code foodie_integrator_leapfrog.f90 Source Code !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. module foodie_integrator_leapfrog !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is: !< !<  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  !< !< Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps: !<  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2})  !<  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha  !<  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1)  !< Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme. !< The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are !< !<  + \\nu=0.01 !<  + \\alpha=0.53 !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. !< !<#### Bibliography !< !< [1] *The integration of a low order spectral form of the primitive meteorological equations*, Robert, A. J., J. Meteor. Soc. !< Japan,vol. 44, pages 237--245, 1966. !< !< [2] *Frequency filter for time integrations*, Asselin, R., Monthly Weather Review, vol. 100, pages 487--490, 1972. !< !< [3] *The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations*, Williams, P.D., Monthly !< Weather Review, vol. 139(6), pages 1996--2007, June 2011. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '2' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 2 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 2 !< Maximum number of steps supported. type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_leapfrog","tags":"","loc":"sourcefile/foodie_integrator_leapfrog.f90.html","title":"foodie_integrator_leapfrog.f90 – FORESEER"},{"text":"FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. This File Depends On sourcefile~~foodie_integrator_adams_bashforth.f90~~EfferentGraph sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_adams_bashforth.f90~~AfferentGraph sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilefoodie_integrator_adams_bashforthf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_bashforthf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_adams_bashforth Source Code foodie_integrator_adams_bashforth.f90 Source Code !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. module foodie_integrator_adams_bashforth !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients *b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[1, 16]*. Note that the scheme using only 1 step reverts !< to Explicit Forward Euler. The formal order of accuracy varies consistently in *[1st, 16th]* order. !< !<#### Bibliography !< [1] *Cowell Type Numerical Integration As Applied to Satellite Orbit Computation*, J. L. Maury Jr., !< G. P. Segal, X-553-69-46, April 1969, [NASA-TM-X-63542](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19690017325.pdf). !< !< [2] *Linear multistep method*, [wikipedia article](https://en.wikipedia.org/wiki/Linear_multistep_method). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '1-16' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 16 !< Maximum number of steps supported. type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< *b* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1.0_R_P case ( 2 ) self % b ( 1 ) = - 1.0_R_P / 2.0_R_P self % b ( 2 ) = 3.0_R_P / 2.0_R_P case ( 3 ) self % b ( 1 ) = 5.0_R_P / 1 2.0_R_P self % b ( 2 ) = - 1 6.0_R_P / 1 2.0_R_P self % b ( 3 ) = 2 3.0_R_P / 1 2.0_R_P case ( 4 ) self % b ( 1 ) = - 9.0_R_P / 2 4.0_R_P self % b ( 2 ) = 3 7.0_R_P / 2 4.0_R_P self % b ( 3 ) = - 5 9.0_R_P / 2 4.0_R_P self % b ( 4 ) = 5 5.0_R_P / 2 4.0_R_P case ( 5 ) self % b ( 1 ) = 25 1.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 127 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 261 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = - 277 4.0_R_P / 72 0.0_R_P self % b ( 5 ) = 190 1.0_R_P / 72 0.0_R_P case ( 6 ) self % b ( 1 ) = - 47 5.0_R_P / 144 0.0_R_P self % b ( 2 ) = 287 7.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 729 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 998 2.0_R_P / 144 0.0_R_P self % b ( 5 ) = - 792 3.0_R_P / 144 0.0_R_P self % b ( 6 ) = 427 7.0_R_P / 144 0.0_R_P case ( 7 ) self % b ( 1 ) = 1908 7.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 13447 2.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 40713 9.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 68825 6.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 70554 9.0_R_P / 6048 0.0_R_P self % b ( 6 ) = - 44728 8.0_R_P / 6048 0.0_R_P self % b ( 7 ) = 19872 1.0_R_P / 6048 0.0_R_P case ( 8 ) self % b ( 1 ) = - 3679 9.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 29576 7.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 104172 3.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 210224 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 266447 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 218387 7.0_R_P / 12096 0.0_R_P self % b ( 7 ) = - 115216 9.0_R_P / 12096 0.0_R_P self % b ( 8 ) = 43424 1.0_R_P / 12096 0.0_R_P case ( 9 ) self % b ( 1 ) = 107001 7.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 966410 6.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 3883348 6.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 9117264 2.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 13796848 0.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 13985526 2.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 9547678 6.0_R_P / 362880 0.0_R_P self % b ( 8 ) = - 4312520 6.0_R_P / 362880 0.0_R_P self % b ( 9 ) = 1409724 7.0_R_P / 362880 0.0_R_P case ( 10 ) self % b ( 1 ) = - 208275 3.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 2088481 1.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 9430732 0.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 25261822 4.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 44477216 2.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 53836383 8.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 45466177 6.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 26593268 0.0_R_P / 725760 0.0_R_P self % b ( 9 ) = - 10499518 9.0_R_P / 725760 0.0_R_P self % b ( 10 ) = 3027724 7.0_R_P / 725760 0.0_R_P case ( 11 ) self % b ( 1 ) = 13421126 5.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 147957434 8.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 741790445 1.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 2232963492 0.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 4485716843 4.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 6317620147 2.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 6371637895 8.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 4611302901 6.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 2359106380 5.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = - 827179512 4.0_R_P / 47900160 0.0_R_P self % b ( 11 ) = 213250956 7.0_R_P / 47900160 0.0_R_P case ( 12 ) self % b ( 1 ) = - 26274726 5.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 315864244 5.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 1741024827 1.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 5818910762 7.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 13136586729 0.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 21110357329 8.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 24774163937 4.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 21413935536 6.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 13557935675 7.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 6163322718 5.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = - 1943381016 3.0_R_P / 95800320 0.0_R_P self % b ( 12 ) = 452776639 9.0_R_P / 95800320 0.0_R_P case ( 13 ) self % b ( 1 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 916055108573 4.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 5506097466241 2.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 20232291373837 0.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 50714036972842 5.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 91588338715244 4.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 122644308612940 8.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 123358924494176 4.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 93288454605589 5.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 52492457990515 0.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 21469659100261 2.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = - 6149755279727 4.0_R_P / 261534873600 0.0_R_P self % b ( 13 ) = 1306440652362 7.0_R_P / 261534873600 0.0_R_P case ( 14 ) self % b ( 1 ) = - 138274192962 1.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 1938285359378 7.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 12617497268190 6.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 50558614119643 0.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 139330630715575 5.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 279386960287907 7.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 420455192553452 4.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 482567132348845 2.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 424676735330575 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 285442957179080 5.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 144531335168190 6.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 53724705251566 2.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = - 14097075067962 1.0_R_P / 523069747200 0.0_R_P self % b ( 14 ) = 2751155497687 5.0_R_P / 523069747200 0.0_R_P case ( 15 ) self % b ( 1 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 12259481390411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 85923647668423 1.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 372880725657747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 1120584975351517 9.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 2470450365560772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 4128021633628425 9.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 5324673866064691 2.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 5347102665994050 9.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 4182526993250772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 2529891033708142 9.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 1164363753057747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 396642167021548 1.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = - 96012286640411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 15 ) = 17323349859884 9.0_R_P / 3138418483200 0.0_R_P case ( 16 ) self % b ( 1 ) = - 1608812922937 5.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 25765027591582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 193444319689259 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 903857175273408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 2941791091125181 9.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 7072435158284348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 12993009410423733 1.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 18608754426359664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 21002058891232194 9.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 18746314011290289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 13196319194082858 1.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 7255811707225973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 3060737386052056 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 962209690951533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = - 216156767124884 9.0_R_P / 6276836966400 0.0_R_P self % b ( 16 ) = 36255512642707 3.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – FORESEER"},{"text":"FOODIE utils: module of (possible) unrelated utilities of FOODIE library. This File Depends On sourcefile~~foodie_utils.f90~~EfferentGraph sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_utils.f90~~AfferentGraph sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilefoodie_utilsf90AfferentGraph = svgPanZoom('#sourcefilefoodie_utilsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_utils Source Code foodie_utils.f90 Source Code !< FOODIE utils: module of (possible) unrelated utilities of FOODIE library. module foodie_utils !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE utils: module of (possible) unrelated utilities of FOODIE library. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_kinds , only : I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_admissible !----------------------------------------------------------------------------------------------------------------------------------- contains ! public procedures elemental function is_admissible ( n , adm_range ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number *n* is admitted by the *admissible* range list *adm_range*. !< !< The admissible range list must be formatted as string containing admissible numbers; valid list are: !<+ `adm_range = '1-5'` => 1, 2, 3, 4, 5 are admissible numbers; !<+ `adm_range = '1,3,5,10-12'` => 1, 3, 5, 10, 11, 12 are admissible numbers; !<+ `adm_range = '1-4,8,21-22'` => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; !< !< You can mix any number of range (`min-max` format) and/or single number (`,` comma separated) entries. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: n !< Number queried. character ( * ), intent ( IN ) :: adm_range !< Admissible range string. logical :: is_admissible !< Is true is the number is in *adm_range*. character ( len ( adm_range )), allocatable :: tokens (:) !< Tokens for parsing *adm_range* string. character ( len ( adm_range )), allocatable :: subtokens (:) !< Tokens for parsing *adm_range* string. integer ( I_P ) :: t !< Counter. integer ( I_P ) :: n_parsed ( 1 : 2 ) !< Values parsed from *adm_range*.. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_admissible = . false . call tokenize ( string = adm_range , delimiter = ',' , toks = tokens ) search_me : do t = 1 , size ( tokens ) if ( index ( tokens ( t ), '-' ) > 0 ) then call tokenize ( string = tokens ( t ), delimiter = '-' , toks = subtokens ) read ( subtokens ( 1 ), * ) n_parsed ( 1 ) read ( subtokens ( 2 ), * ) n_parsed ( 2 ) is_admissible = ( n_parsed ( 1 ) <= n . and . n <= n_parsed ( 2 )) else read ( tokens ( t ), * ) n_parsed ( 1 ) is_admissible = ( n_parsed ( 1 ) == n ) endif if ( is_admissible ) exit search_me enddo search_me return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_admissible ! private procedures pure subroutine tokenize ( string , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: string !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( string )), allocatable , intent ( OUT ) :: toks (:) !< Tokens. integer ( I_P ), optional , intent ( OUT ) :: Nt !< Number of tokens. character ( len = len ( string )) :: strsub !< Temporary string. integer ( I_P ) :: dlen !< Delimiter length. integer ( I_P ) :: c !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize if ( allocated ( toks )) deallocate ( toks ) strsub = string dlen = len ( delimiter ) if ( dlen > len ( string )) then allocate ( toks ( 1 : 1 )) toks ( 1 ) = char ( 0 ) if ( present ( Nt )) Nt = 1 return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenize do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize endmodule foodie_utils","tags":"","loc":"sourcefile/foodie_utils.f90.html","title":"foodie_utils.f90 – FORESEER"},{"text":"FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. This File Depends On sourcefile~~foodie_integrator_adams_moulton.f90~~EfferentGraph sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_adams_moulton.f90~~AfferentGraph sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilefoodie_integrator_adams_moultonf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_moultonf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_adams_moulton Source Code foodie_integrator_adams_moulton.f90 Source Code !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. module foodie_integrator_adams_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Moulton class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } + !< b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients *b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[0, 15]*. Note that the scheme using only 1 step reverts !< to Implciti Backwarad Euler. The formal order of accuracy varies consistently in *[1st, 16th]* order. !< !<#### Bibliography !< [1] *Cowell Type Numerical Integration As Applied to Satellite Orbit Computation*, J. L. Maury Jr., !< G. P. Segal, X-553-69-46, April 1969, [NASA-TM-X-63542](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19690017325.pdf). !< !< [2] *Linear multistep method*, [wikipedia article](https://en.wikipedia.org/wiki/Linear_multistep_method). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '0-15' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 0 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 15 !< Maximum number of steps supported. type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype adams_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1.0_R_P case ( 1 ) self % b ( 0 ) = 1.0_R_P / 2.0_R_P self % b ( 1 ) = 1.0_R_P / 2.0_R_P case ( 2 ) self % b ( 0 ) = - 1.0_R_P / 1 2.0_R_P self % b ( 1 ) = 8.0_R_P / 1 2.0_R_P self % b ( 2 ) = 5.0_R_P / 1 2.0_R_P case ( 3 ) self % b ( 0 ) = 1.0_R_P / 2 4.0_R_P self % b ( 1 ) = - 5.0_R_P / 2 4.0_R_P self % b ( 2 ) = 1 9.0_R_P / 2 4.0_R_P self % b ( 3 ) = 9.0_R_P / 2 4.0_R_P case ( 4 ) self % b ( 0 ) = - 1 9.0_R_P / 72 0.0_R_P self % b ( 1 ) = 10 6.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 26 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 64 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = 25 1.0_R_P / 72 0.0_R_P case ( 5 ) self % b ( 0 ) = 2 7.0_R_P / 144 0.0_R_P self % b ( 1 ) = - 17 3.0_R_P / 144 0.0_R_P self % b ( 2 ) = 48 2.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 79 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 142 7.0_R_P / 144 0.0_R_P self % b ( 5 ) = 47 5.0_R_P / 144 0.0_R_P case ( 6 ) self % b ( 0 ) = - 86 3.0_R_P / 6048 0.0_R_P self % b ( 1 ) = 631 2.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 2021 1.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 3750 4.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 4646 1.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 6511 2.0_R_P / 6048 0.0_R_P self % b ( 6 ) = 1908 7.0_R_P / 6048 0.0_R_P case ( 7 ) self % b ( 0 ) = 137 5.0_R_P / 12096 0.0_R_P self % b ( 1 ) = - 1135 1.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 4149 9.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 8854 7.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 12313 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 12179 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 13984 9.0_R_P / 12096 0.0_R_P self % b ( 7 ) = 3679 9.0_R_P / 12096 0.0_R_P case ( 8 ) self % b ( 0 ) = - 3395 3.0_R_P / 362880 0.0_R_P self % b ( 1 ) = 31287 4.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 129121 4.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 314633 8.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 503312 0.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 559535 8.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 460459 4.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 446709 4.0_R_P / 362880 0.0_R_P self % b ( 8 ) = 107001 7.0_R_P / 362880 0.0_R_P case ( 9 ) self % b ( 0 ) = 5728 1.0_R_P / 725760 0.0_R_P self % b ( 1 ) = - 58343 5.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 268786 4.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 739403 2.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 1351008 2.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 1728364 6.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 1600232 0.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 1127130 4.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 944971 7.0_R_P / 725760 0.0_R_P self % b ( 9 ) = 208275 3.0_R_P / 725760 0.0_R_P case ( 10 ) self % b ( 0 ) = - 325043 3.0_R_P / 47900160 0.0_R_P self % b ( 1 ) = 3628487 6.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 18477619 5.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 56745098 4.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 117059704 2.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 171077452 8.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 182331156 6.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 144620508 0.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 89017554 9.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 65618565 2.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = 13421126 5.0_R_P / 47900160 0.0_R_P case ( 11 ) self % b ( 0 ) = 567526 5.0_R_P / 95800320 0.0_R_P self % b ( 1 ) = - 6892878 1.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 38470932 7.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 130597111 5.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 300773941 8.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 496316651 4.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 604352148 6.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 551946058 2.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 382882888 5.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 209249067 3.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 137479921 9.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = 26274726 5.0_R_P / 95800320 0.0_R_P case ( 12 ) self % b ( 0 ) = - 1369577909 3.0_R_P / 261534873600 0.0_R_P self % b ( 1 ) = 17984282256 6.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 109209699226 8.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 406332786317 0.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 1034471179498 5.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 1905818565279 6.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 2620434446515 2.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 2734587069843 6.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 2184753803989 5.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 1346577425651 0.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 661642095742 8.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 391755121698 6.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P case ( 13 ) self % b ( 0 ) = 2446657909 3.0_R_P / 523069747200 0.0_R_P self % b ( 1 ) = - 34545708639 5.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 226807881438 6.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 918163560513 4.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 2562025977783 5.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 5217791088266 1.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 8010102102918 0.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 9439333865389 2.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 8618022868956 3.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 6118868013128 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 3392899013361 8.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 1514123508411 0.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 815316796218 1.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = 138274192962 1.0_R_P / 523069747200 0.0_R_P case ( 14 ) self % b ( 0 ) = - 13228284012 7.0_R_P / 3138418483200 0.0_R_P self % b ( 1 ) = 199875923633 6.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 1411048096992 7.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 6175942669254 4.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 18750493659793 1.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 41855180460126 4.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 71031283419734 7.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 93460083349094 4.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 96360540082473 3.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 78191161807163 2.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 49954720375483 7.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 25172489460793 6.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 10288514895621 7.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 5077096753486 4.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P case ( 15 ) self % b ( 0 ) = 24020824582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 1 ) = - 386768936759 9.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 2921938428408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 13751571378931 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 45140310893348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 109635523540233 1.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 203934587954664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 296636573026569 9.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 341494172885289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 312945307199358 1.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 228516859834973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 132697866305806 9.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 61274454106533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 23099216372384 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 10514505875707 3.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = 1608812922937 5.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_adams_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_moulton.f90.html","title":"foodie_integrator_adams_moulton.f90 – FORESEER"},{"text":"FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. This File Depends On sourcefile~~foodie_integrator_low_storage_runge_kutta.f90~~EfferentGraph sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_low_storage_runge_kutta.f90~~AfferentGraph sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_low_storage_runge_kutta Source Code foodie_integrator_low_storage_runge_kutta.f90 Source Code !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_low_storage_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the low storage property allowing for an efficient use of the memory. !< Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<\\begin{matrix} !< K_1 = U&#94;n \\\\ !< K_2 = 0 \\\\ !<\\left.\\begin{matrix} !< K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\ !< K_1 = K_1 + B_s K_2 !<\\end{matrix}\\right\\} s=1,2,...N_s\\\\ !<U&#94;{n+1} = K_1 !<\\end{matrix} !< !< where *Ns* is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table !< form. !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<#### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being !< meaningless for a first order scheme. However it is added for safety reason. !< !< | ` Stage ` | ` A ` | ` B ` | ` C ` | !< |-----------|-------|-------|-------| !< | ` 1 `     | ` 0 ` | ` 1 ` | ` 0 ` | !< !<#### 5 stages, SSP, 4th order !< This scheme is a low storage RK(5, 4), based on the *solution 3* proposed in [2]. !< !< | ` Stage ` | ` A `                            | ` B `                            | ` C `                           | !< |-----------|----------------------------------|----------------------------------|---------------------------------| !< | ` 1 `     | `  0                           ` | ` 1432997174477/9575080441755  ` | ` 0                           ` | !< | ` 2 `     | ` -567301805773 /1357537059087 ` | ` 5161836677717/13612068292357 ` | ` 1432997174477/9575080441755 ` | !< | ` 3 `     | ` -2404267990393/2016746695238 ` | ` 1720146321549/2090206949498  ` | ` 2526269341429/6820363962896 ` | !< | ` 4 `     | ` -3550918686646/2091501179385 ` | ` 3134564353537/4481467310338  ` | ` 2006345519317/3224310063776 ` | !< | ` 5 `     | ` -1275806237668/842570457699  ` | ` 2277821191437/14882151754819 ` | ` 2802321613138/2924317926251 ` | !< !< !<#### 6 stages, 4th order !< This scheme is a low storage RK(6, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.122000000000 ` | ` 0              ` | !< | ` 2 `     | ` -0.691750960670 ` | ` 0.477263056358 ` | ` 0.122000000000 ` | !< | ` 3 `     | ` -1.727127405211 ` | ` 0.381941220320 ` | ` 0.269115878630 ` | !< | ` 4 `     | ` -0.694890150986 ` | ` 0.447757195744 ` | ` 0.447717183551 ` | !< | ` 5 `     | ` -1.039942756197 ` | ` 0.498614246822 ` | ` 0.749979795490 ` | !< | ` 6 `     | ` -1.531977447611 ` | ` 0.186648570846 ` | ` 0.898555413085 ` | !< !<#### 7 stages, 4th order !< This scheme is a low storage RK(7, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.117322146869 ` | ` 0              ` | !< | ` 2 `     | ` -0.647900745934 ` | ` 0.503270262127 ` | ` 0.117322146869 ` | !< | ` 3 `     | ` -2.704760863204 ` | ` 0.233663281658 ` | ` 0.294523230758 ` | !< | ` 4 `     | ` -0.460080550118 ` | ` 0.283419634625 ` | ` 0.305658622131 ` | !< | ` 5 `     | ` -0.500581787785 ` | ` 0.540367414023 ` | ` 0.582864148403 ` | !< | ` 6 `     | ` -1.906532255913 ` | ` 0.371499414620 ` | ` 0.858664273599 ` | !< | ` 7 `     | ` -1.450000000000 ` | ` 0.136670099385 ` | ` 0.868664273599 ` | !< !<#### 12 stages, 4th order !< This scheme is a low storage RK(12, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0650008435125904 ` | ` 0                  ` | !< | ` 2  `    | ` -0.0923311242368072 ` | ` 0.0161459902249842 ` | ` 0.0650008435125904 ` | !< | ` 3  `    | ` -0.9441056581158819 ` | ` 0.5758627178358159 ` | ` 0.0796560563081853 ` | !< | ` 4  `    | ` -4.3271273247576394 ` | ` 0.1649758848361671 ` | ` 0.1620416710085376 ` | !< | ` 5  `    | ` -2.1557771329026072 ` | ` 0.3934619494248182 ` | ` 0.2248877362907778 ` | !< | ` 6  `    | ` -0.9770727190189062 ` | ` 0.0443509641602719 ` | ` 0.2952293985641261 ` | !< | ` 7  `    | ` -0.7581835342571139 ` | ` 0.2074504268408778 ` | ` 0.3318332506149405 ` | !< | ` 8  `    | ` -1.7977525470825499 ` | ` 0.6914247433015102 ` | ` 0.4094724050198658 ` | !< | ` 9  `    | ` -2.6915667972700770 ` | ` 0.3766646883450449 ` | ` 0.6356954475753369 ` | !< | ` 10 `    | ` -4.6466798960268143 ` | ` 0.0757190350155483 ` | ` 0.6806551557645497 ` | !< | ` 11 `    | ` -0.1539613783825189 ` | ` 0.2027862031054088 ` | ` 0.7143773712418350 ` | !< | ` 12 `    | ` -0.5943293901830616 ` | ` 0.2167029365631842 ` | ` 0.9032588871651854 ` | !< !<#### 13 stages, 4th order !< This scheme is a low storage RK(13, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0271990297818803 ` | ` 0                  ` | !< | ` 2  `    | ` -0.6160178650170565 ` | ` 0.1772488819905108 ` | ` 0.0271990297818803 ` | !< | ` 3  `    | ` -0.4449487060774118 ` | ` 0.0378528418949694 ` | ` 0.0952594339119365 ` | !< | ` 4  `    | ` -1.0952033345276178 ` | ` 0.6086431830142991 ` | ` 0.1266450286591127 ` | !< | ` 5  `    | ` -1.2256030785959187 ` | ` 0.2154313974316100 ` | ` 0.1825883045699772 ` | !< | ` 6  `    | ` -0.2740182222332805 ` | ` 0.2066152563885843 ` | ` 0.3737511439063931 ` | !< | ` 7  `    | ` -0.0411952089052647 ` | ` 0.0415864076069797 ` | ` 0.5301279418422206 ` | !< | ` 8  `    | ` -0.1797084899153560 ` | ` 0.0219891884310925 ` | ` 0.5704177433952291 ` | !< | ` 9  `    | ` -1.1771530652064288 ` | ` 0.9893081222650993 ` | ` 0.5885784947099155 ` | !< | ` 10 `    | ` -0.4078831463120878 ` | ` 0.0063199019859826 ` | ` 0.6160769826246714 ` | !< | ` 11 `    | ` -0.8295636426191777 ` | ` 0.3749640721105318 ` | ` 0.6223252334314046 ` | !< | ` 12 `    | ` -4.7895970584252288 ` | ` 1.6080235151003195 ` | ` 0.6897593128753419 ` | !< | ` 13 `    | ` -0.6606671432964504 ` | ` 0.0961209123818189 ` | ` 0.9126827615920843 ` | !< !<#### 14 stages, 4th order !< This scheme is a low storage RK(14, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0367762454319673 ` | ` 0                  ` | !< | ` 2  `    | ` -0.7188012108672410 ` | ` 0.3136296607553959 ` | ` 0.0367762454319673 ` | !< | ` 3  `    | ` -0.7785331173421570 ` | ` 0.1531848691869027 ` | ` 0.1249685262725025 ` | !< | ` 4  `    | ` -0.0053282796654044 ` | ` 0.0030097086818182 ` | ` 0.2446177702277698 ` | !< | ` 5  `    | ` -0.8552979934029281 ` | ` 0.3326293790646110 ` | ` 0.2476149531070420 ` | !< | ` 6  `    | ` -3.9564138245774565 ` | ` 0.2440251405350864 ` | ` 0.2969311120382472 ` | !< | ` 7  `    | ` -1.5780575380587385 ` | ` 0.3718879239592277 ` | ` 0.3978149645802642 ` | !< | ` 8  `    | ` -2.0837094552574054 ` | ` 0.6204126221582444 ` | ` 0.5270854589440328 ` | !< | ` 9  `    | ` -0.7483334182761610 ` | ` 0.1524043173028741 ` | ` 0.6981269994175695 ` | !< | ` 10 `    | ` -0.7032861106563359 ` | ` 0.0760894927419266 ` | ` 0.8190890835352128 ` | !< | ` 11 `    | `  0.0013917096117681 ` | ` 0.0077604214040978 ` | ` 0.8527059887098624 ` | !< | ` 12 `    | ` -0.0932075369637460 ` | ` 0.0024647284755382 ` | ` 0.8604711817462826 ` | !< | ` 13 `    | ` -0.9514200470875948 ` | ` 0.0780348340049386 ` | ` 0.8627060376969976 ` | !< | ` 14 `    | ` -7.1151571693922548 ` | ` 5.5059777270269628 ` | ` 0.8734213127600976 ` | !< !<#### Bibliography !< !< [1] *Low-Storage Runge-Kutta Schemes*, J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48--56. !< !< [2] *Fourth-Order 2N-Storage Runge-Kutta Schemes*, Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, !< June 1994. !< !< [3] *High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics*, Vasanth Allampalli and !< Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837--3850. !< !< [4] *Efficient low-storage Runge–Kutta schemes with optimized stability regions*, Jens Niegemann and Richard Diehl and Kurt !< Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364--372. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , I8P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), parameter :: registers = 2 !< Registers used (2N schemes). character ( len = 99 ), parameter :: supported_stages = '1,5-7,12-14' !< List of supported stages number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of stages supported. integer ( I_P ), parameter :: max_ss = 14 !< Maximum number of stages supported. type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: used_registers !< Return the number of registers used. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. endtype ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : registers ) !< Runge-Kutta registers. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function used_registers () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: used_registers !< Number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- used_registers = registers return !--------------------------------------------------------------------------------------------------------------------------------- endfunction used_registers pure function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages pure function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_low_storage_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_low_storage_runge_kutta.f90.html","title":"foodie_integrator_low_storage_runge_kutta.f90 – FORESEER"},{"text":"FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. This File Depends On sourcefile~~foodie.f90~~EfferentGraph sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90 foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90 foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_low_storage_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_tvd_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_low_storage_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_tvd_runge_kutta.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth.f90 var pansourcefilefoodief90EfferentGraph = svgPanZoom('#sourcefilefoodief90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie.f90~~AfferentGraph sourcefile~foodie.f90 foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie Source Code foodie.f90 Source Code !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *explicit Adams-Bashforth* class of schemes: !<    + 1 step, namely the explicit forward Euler scheme, 1st order accurate; !<    + 2 steps, 2nd order accurate; !<    + 3 steps, 3rd order accurate; !<    + 4 steps, 4th order accurate; !<+ *forward explicit Euler* scheme, a 1st order accurate; !<+ *explicit Leapfrog*: !<    + Unfiltered, 2nd order accurate, (mostly) unstable; !<    + Robert-Asselin filtered, 1st order accurate; !<    + Robert-Asselin-Williams filter, 2nd order accurate; !<+ *explicit low storage Runge-Kutta 2N* class schemes: !<    + LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + LS(5,4): 5 stages, 4th order accurate; !<+ *explicit TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order accurate; !<    + SSP(3,3): 3 stages, 3rd order accurate; !<    + SSP(5,4): 5 stages, 4th order accurate; !<+ *explicit embedded Runge-Kutta* class schemes: !<    + DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; !<+ *implicit Adams-Moulton* class of schemes: !<    + 0 step, namely the implicit backward Euler scheme, 1st order accurate; !<    + 1 step, 2nd order accurate; !<    + 2 steps, 3rd order accurate; !<    + 3 steps, 4th order accurate; !<+ *predictor-corrector Adams-Bashforth-Moulton* class of schemes: !<    + P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; !<    + P=AB(2)-C=AM(1) step, 2nd order accurate; !<    + P=AB(3)-C=AM(2) steps, 3rd order accurate; !<    + P=AB(4)-C=AM(3) steps, 4th order accurate; !< !<### Usage !< !< FOODIE schemes must be applied to only subclass extensions of the abstract class *integrand*. !< !< To use FOODIE you must: !< !<#### extend integrand abstract class provided by FOODIE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODIE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !<     ... !< endtype lorenz !<``` !< !<#### use one of the provided FOODIE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_bashforth_moulton , only : adams_bashforth_moulton_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator use foodie_integrator_backward_differentiation_formula , only : back_df_integrator use foodie_integrator_emd_runge_kutta , only : emd_runge_kutta_integrator use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_leapfrog , only : leapfrog_integrator use foodie_integrator_low_storage_runge_kutta , only : ls_runge_kutta_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: adams_bashforth_integrator public :: adams_bashforth_moulton_integrator public :: adams_moulton_integrator public :: back_df_integrator public :: emd_runge_kutta_integrator public :: euler_explicit_integrator public :: leapfrog_integrator public :: ls_runge_kutta_integrator public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FORESEER"},{"text":"FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. This File Depends On sourcefile~~foodie_integrator_embedded_runge_kutta.f90~~EfferentGraph sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_embedded_runge_kutta.f90~~AfferentGraph sourcefile~foodie_integrator_embedded_runge_kutta.f90 foodie_integrator_embedded_runge_kutta.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_embedded_runge_kutta.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_emd_runge_kutta Source Code foodie_integrator_embedded_runge_kutta.f90 Source Code !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. module foodie_integrator_emd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. !< !< The integrators provided have the embedded pairs property allowing for automatic step size control. !< The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s  !<  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  !< !< *p* is the lower accuracy order scheme and *p+1* is the higher one; Ns is the number of stages used and K&#94;s is !< the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the extended Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !< @bug Presently, the 2 stages Heun-Euler seems to not work, **do not use it**. !< !<##### 2 stages, 2th order !< This scheme is due to Heun-Euler. !<``` !<  0  | 0 !<  1  | 1     0 !< ---------------- !<     | 1/2   1/2 !<     | 1      0 !<``` !< !<##### 6 stages, 5th order !< This scheme is due to Cash and Karp, see [3]. !<``` !<  0    | 0 !<  1/5\t | 1/5 !<  3/10 | 3/40\t         9/40 !<  3/5\t | 3/10\t         -9/10\t      6/5 !<  1\t   | -11/54\t       5/2\t        -70/27\t    35/27 !<  7/8\t | 1631/55296    175/512      575/13824   44275/110592     253/4096     0 !< ---------------------------------------------------------------------------------------- !<       | 37/378        0           250/621      125/594          0            512/1771 !<       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 !<``` !< !<##### 7 stages, 4th order !< This scheme is due to Dormand and Prince, see [1]. !<``` !<  0    | 0 !<  1/5  | 1/5 !<  3/10 | 3/40          9/40 !<  4/5  | 44/45        -56/15        32/9 !<  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729 !<  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656 !<  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !< -------------------------------------------------------------------------------------------- !<       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40 !<       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !<``` !< !<##### 9 stages, 6th order !< This scheme is due to Calvo et al., see [2]. !<``` !<  0                 | 0 !<  2/15              | 2/15 !<  1/5               | 1/20                  3/20 !<  3/10              | 3/40                  0                      9/40 !<  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441 !<  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461 !<  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831 !<  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713 !<  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !< -------------------------------------------------------------------------------------------------------------- !<                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !<                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738 !< ...continued... !<  0                 | !<  2/15              | !<  1/5               | !<  3/10              | !<  14/25             | !<  19/25             | 73139862/60170633 !<  35226607/35688279 | -90453121/33722162     111179552/157155827 !<  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625 !<  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !< ----------------------------------------------------------------------------------------------------------------------- !<                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !<                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 !<``` !< !<##### 17 stages, 10th order !< This scheme is due to Feagin, see [4]. !<``` !<  0                        |  0 !<  0.1                      |  0.1 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052 !<  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974 !<  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068 !<  0.981074190219795268254  |  0.087900734020668133731  0                        0 !<  0.833333333333333333333  |  0.085970050490246030218  0                        0 !<  0.354017365856802376329  |  0.120930449125333720660  0                        0 !<  0.882527661964732346425  |  0.110854379580391483508  0                        0 !<  0.642615758240322548157  |  0.112054414752879004829  0                        0 !<  0.357384241759677451842  |  0.113976783964185986138  0                        0 !<  0.117472338035267653574  |  0.079831452828019604635  0                        0 !<  0.833333333333333333333  |  0.985115610164857280120  0                        0 !<  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0 !<  0.1                      |  0.1                      0                       -0.157178665799771163367 !<  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.033333333333333333333  0.025                    0.033333333333333333333 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | -0.072954784731363262918 !<  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678 !<  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015 !<  0.882527661964732346425  |  0                        0                       -0.060576148825500558762 !<  0.642615758240322548157  |  0                        0                       -0.144942775902865915672 !<  0.357384241759677451842  |  0                        0                       -0.076881336420335693858 !<  0.117472338035267653574  |  0                        0                       -0.052032968680060307651 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821 !<  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739 !<  0.539357840802981787532  |  0                       -0.777333643644968233538  0 !<  0.1                      |  0                        0                        0 !<  1                        |  0                        0.259111214548322744512 -0.358278966717952089048 !< ------------------------------------------------------------------------------------------------------ !<                           |  0                        0.05                     0 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | -0.059578021181736100156 !<  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577 !<  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236 !<  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555 !<  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727 !<  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904 !<  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653 !<  0.539357840802981787532  | -0.091089566215517606959  0                        0 !<  0.1                      |  0                        0                        0 !<  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.04                     0                        0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | -0.327769124164018874147 !<  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184 !<  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539 !<  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220 !<  0.539357840802981787532  |  0                        0                        0 !<  0.1                      |  0                        0                        0 !<  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | -0.024403640575012745213 !<  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538 !<  0.1                      |  0                        0                        0.157178665799771163367 !<  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675 !< ------------------------------------------------------------------------------------------------------------- !<                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | !<  0.539357840802981787532  | !<  0.1                      | !<  1                        | !< --------------------------------------------------- !<                           | 0.033333333333333333333 !<``` !< !<#### Bibliography !< !< [1] *A family of embedded Runge-Kutta formulae*, Dormand, J. R., Prince, P. J. (1980), Journal of Computational and !< Applied Mathematics 6 (1): 19--26, doi:10.1016/0771-050X(80)90013-3. !< !< [2] *A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6*, M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics !< with Applications, Volume 20, Issue 1, 1990, Pages 15--24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. !< !< [3] *A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides*, J. R. Cash, !< A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201--222, 1990, doi:10.1145/79505.79507. !< !< [4] *A tenth-order Runge-Kutta method with error estimate*, Feagin, T., Proceedings of the IAENG Conf. on Scientific !< Computing. 2007. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_stages = '6,7,9,17' !< List of supported stages number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 6 !< Minimum number of stages supported. integer ( I_P ), parameter :: max_ss = 17 !< Maximum number of stages supported. type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. endtype emd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! do not use, seems to not work! ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages pure function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported ! private methods elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt endmodule foodie_integrator_emd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_embedded_runge_kutta.f90.html","title":"foodie_integrator_embedded_runge_kutta.f90 – FORESEER"},{"text":"FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. This File Depends On sourcefile~~foodie_integrator_adams_bashforth_moulton.f90~~EfferentGraph sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_utils.f90 foodie_utils.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_utils.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_adt_integrand.f90 foodie_adt_integrand.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_adt_integrand.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90 foodie_kinds.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_utils.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_adt_integrand.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_kinds.f90->sourcefile~foodie_integrator_adams_bashforth.f90 var pansourcefilefoodie_integrator_adams_bashforth_moultonf90EfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_bashforth_moultonf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_adams_bashforth_moulton.f90~~AfferentGraph sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foodie.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_adams_bashforth_moulton Source Code foodie_integrator_adams_bashforth_moulton.f90 Source Code !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. module foodie_integrator_adams_bashforth_moulton !----------------------------------------------------------------------------------------------------------------------------------- !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: !< !<##### predictor !<  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !<##### corrector !<  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  !< !<where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps !<considered for the corrector. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of !< **steps** used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1 !< should hold. !< !< Currently, the following schemes are available: !<##### P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order !< This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order. !< The *b* coefficient is: !< b&#94;p = \\left[b_1\\right] = \\left[1\\right] !< b&#94;c = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n})  !<  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  !< !<##### P=AB(2)-C=AM(1) steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<##### P=AB(3)-C=AM(2) steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  !< !<##### P=AB(4)-C=AM(3) steps !< This scheme is 4th order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !<  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3}) !< -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie_adt_integrand , only : integrand use foodie_kinds , only : I_P , R_P use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_adams_moulton , only : adams_moulton_integrator use foodie_utils , only : is_admissible !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- character ( len = 99 ), parameter :: supported_steps = '1-16' !< List of supported steps number. Valid format is `1-2,4,9-23...`. integer ( I_P ), parameter :: min_ss = 1 !< Minimum number of steps supported. integer ( I_P ), parameter :: max_ss = 16 !< Maximum number of steps supported. type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype adams_bashforth_moulton_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported endmodule foodie_integrator_adams_bashforth_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth_moulton.f90.html","title":"foodie_integrator_adams_bashforth_moulton.f90 – FORESEER"},{"text":"This File Depends On sourcefile~~penf_b_size.f90~~EfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_b_size.f90~~AfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~penf.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~penf.f90->sourcefile~wenoof.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~penf.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilepenf_b_sizef90AfferentGraph = svgPanZoom('#sourcefilepenf_b_sizef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_b_size Source Code penf_b_size.F90 Source Code module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size","tags":"","loc":"sourcefile/penf_b_size.f90.html","title":"penf_b_size.F90 – FORESEER"},{"text":"Portability Environment for Fortran poor people. This File Depends On sourcefile~~penf.f90~~EfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf.f90~~AfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~penf.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~penf.f90->sourcefile~wenoof.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~penf.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilepenff90AfferentGraph = svgPanZoom('#sourcefilepenff90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf Source Code penf.F90 Source Code !< Portability Environment for Fortran poor people. module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – FORESEER"},{"text":"This File Depends On sourcefile~~penf_stringify.f90~~EfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_stringify.f90~~AfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~penf.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~penf.f90->sourcefile~wenoof.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~penf.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilepenf_stringifyf90AfferentGraph = svgPanZoom('#sourcefilepenf_stringifyf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_stringify Source Code penf_stringify.F90 Source Code module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify","tags":"","loc":"sourcefile/penf_stringify.f90.html","title":"penf_stringify.F90 – FORESEER"},{"text":"Files Dependent On This One sourcefile~~penf_global_parameters_variables.f90~~AfferentGraph sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~penf.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~penf.f90->sourcefile~wenoof.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~penf.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~penf.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~penf.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~penf.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~penf.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~penf.f90->sourcefile~foreseer_eos_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~flap.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilepenf_global_parameters_variablesf90AfferentGraph = svgPanZoom('#sourcefilepenf_global_parameters_variablesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_global_parameters_variables Source Code penf_global_parameters_variables.F90 Source Code module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables","tags":"","loc":"sourcefile/penf_global_parameters_variables.f90.html","title":"penf_global_parameters_variables.F90 – FORESEER"},{"text":"WenOOF, WENO interpolation Object Oriented Fortran library This File Depends On sourcefile~~wenoof.f90~~EfferentGraph sourcefile~wenoof.f90 wenoof.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 var pansourcefilewenooff90EfferentGraph = svgPanZoom('#sourcefilewenooff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof.f90~~AfferentGraph sourcefile~wenoof.f90 wenoof.F90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof Source Code wenoof.F90 Source Code !< WenOOF, WENO interpolation Object Oriented Fortran library module wenoof !< WenOOF, WENO interpolation Object Oriented Fortran library #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif use wenoof_interpolator_object use wenoof_objects_factory implicit none private public :: interpolator_object public :: wenoof_create contains subroutine wenoof_create ( interpolator_type , S , interpolator , face_left , face_right , eps ) !< WenOOF creator, create a concrete WENO interpolator object. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencil dimension. class ( interpolator_object ), allocatable , intent ( out ) :: interpolator !< The concrete WENO interpolator. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero-div. type ( objects_factory ) :: factory !< The factory. call factory % create ( interpolator_type = interpolator_type , & S = S , & interpolator = interpolator , & face_left = face_left , & face_right = face_right , & eps = eps ) endsubroutine wenoof_create endmodule wenoof","tags":"","loc":"sourcefile/wenoof.f90.html","title":"wenoof.F90 – FORESEER"},{"text":"Abstract interpolations object. This File Depends On sourcefile~~wenoof_interpolations_object.f90~~EfferentGraph sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_interpolations_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_interpolations_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_interpolations_object.f90~~AfferentGraph sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilewenoof_interpolations_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_interpolations_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_interpolations_object Source Code wenoof_interpolations_object.F90 Source Code !< Abstract interpolations object. module wenoof_interpolations_object !< Abstract interpolations object. #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_base_object implicit none private public :: interpolations_object public :: interpolations_object_constructor type , extends ( base_object_constructor ), abstract :: interpolations_object_constructor !< Abstract interpolations object constructor. endtype interpolations_object_constructor type , extends ( base_object ), abstract :: interpolations_object !< Abstract interpolations object. real ( RPP ), allocatable :: values (:,:) !< Stencil interpolations values [1:2,0:S-1]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute beta. endtype interpolations_object abstract interface !< Abstract interfaces of [[interpolations_object]]. pure subroutine compute_interface ( self , stencil ) !< Compute interpolations. import :: interpolations_object , RPP class ( interpolations_object ), intent ( inout ) :: self !< Interpolations. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. endsubroutine compute_interface endinterface endmodule wenoof_interpolations_object","tags":"","loc":"sourcefile/wenoof_interpolations_object.f90.html","title":"wenoof_interpolations_object.F90 – FORESEER"},{"text":"Abstract interpolator object. This File Depends On sourcefile~~wenoof_interpolator_object.f90~~EfferentGraph sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_interpolator_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_interpolator_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_interpolator_object.f90~~AfferentGraph sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_interpolator_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_interpolator_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_interpolator_object Source Code wenoof_interpolator_object.F90 Source Code !< Abstract interpolator object. module wenoof_interpolator_object !< Abstract interpolator object. #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_base_object use wenoof_interpolations_object use wenoof_weights_object implicit none private public :: interpolator_object public :: interpolator_object_constructor type , extends ( base_object_constructor ), abstract :: interpolator_object_constructor !< Abstract interpolator object constructor. !< !< @note Every concrete WENO interpolator implementations must define their own constructor type. class ( interpolations_object_constructor ), allocatable :: interpolations_constructor !< Stencil interpolations constructor. class ( weights_object_constructor ), allocatable :: weights_constructor !< Weights of interpolations constructor. endtype interpolator_object_constructor type , extends ( base_object ), abstract :: interpolator_object !< Abstract interpolator object. !< !< @note Do not implement any actual interpolator: provide the interface for the different interpolators implemented. class ( interpolations_object ), allocatable :: interpolations !< Stencil interpolations. class ( weights_object ), allocatable :: weights !< Weights of interpolations. contains ! public deferred methods procedure ( interpolate_debug_interface ), pass ( self ), deferred :: interpolate_debug !< Interpolate values, debug mode. procedure ( interpolate_standard_interface ), pass ( self ), deferred :: interpolate_standard !< Interpolate values, standard mode. ! public methods generic :: interpolate => interpolate_standard , interpolate_debug !< Interpolate values. endtype interpolator_object abstract interface !< Abstract interfaces of [[interpolator_object]]. pure subroutine interpolate_debug_interface ( self , stencil , interpolation , si , weights ) !< Interpolate values (providing also debug values). import :: interpolator_object , RPP class ( interpolator_object ), intent ( inout ) :: self !< Interpolator. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( RPP ), intent ( out ) :: si ( 1 :, 0 :) !< Computed values of smoothness indicators [1:2, 0:S-1]. real ( RPP ), intent ( out ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S-1]. endsubroutine interpolate_debug_interface pure subroutine interpolate_standard_interface ( self , stencil , interpolation ) !< Interpolate values (without providing debug values). import :: interpolator_object , RPP class ( interpolator_object ), intent ( inout ) :: self !< Interpolator. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. endsubroutine interpolate_standard_interface endinterface endmodule wenoof_interpolator_object","tags":"","loc":"sourcefile/wenoof_interpolator_object.f90.html","title":"wenoof_interpolator_object.F90 – FORESEER"},{"text":"Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. This File Depends On sourcefile~~wenoof_beta_object.f90~~EfferentGraph sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_beta_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_beta_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_beta_object.f90~~AfferentGraph sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilewenoof_beta_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_beta_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_beta_object Source Code wenoof_beta_object.F90 Source Code !< Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. module wenoof_beta_object !< Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_base_object implicit none private public :: beta_object public :: beta_object_constructor type , extends ( base_object_constructor ), abstract :: beta_object_constructor !< Abstract Beta coefficients object constructor. endtype beta_object_constructor type , extends ( base_object ), abstract :: beta_object !< Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. real ( RPP ), allocatable :: values (:,:) !< Beta values [1:2,0:S-1]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute beta. endtype beta_object abstract interface !< Abstract interfaces of [[beta_object]]. pure subroutine compute_interface ( self , stencil ) !< Compute beta. import :: beta_object , RPP class ( beta_object ), intent ( inout ) :: self !< Beta. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. endsubroutine compute_interface endinterface endmodule wenoof_beta_object","tags":"","loc":"sourcefile/wenoof_beta_object.f90.html","title":"wenoof_beta_object.F90 – FORESEER"},{"text":"Abstract weights object. This File Depends On sourcefile~~wenoof_weights_object.f90~~EfferentGraph sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_weights_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_weights_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_weights_object.f90~~AfferentGraph sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilewenoof_weights_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_weights_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_weights_object Source Code wenoof_weights_object.F90 Source Code !< Abstract weights object. module wenoof_weights_object !< Abstract weights object. #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_base_object implicit none private public :: weights_object public :: weights_object_constructor type , extends ( base_object_constructor ) :: weights_object_constructor !< Abstract weights object constructor. endtype weights_object_constructor type , extends ( base_object ), abstract :: weights_object !< Weights of stencil interpolations object. real ( RPP ), allocatable :: values (:,:) !< Weights values of stencil interpolations [1:2,0:S-1]. contains ! deferred public methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute weights. procedure ( smoothness_indicators_interface ), pass ( self ), deferred :: smoothness_indicators !< Return smoothness indicators. endtype weights_object abstract interface !< Abstract interfaces of [[weights_object]]. pure subroutine compute_interface ( self , stencil ) !< Compute beta. import :: weights_object , RPP class ( weights_object ), intent ( inout ) :: self !< Weights. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. endsubroutine compute_interface pure function smoothness_indicators_interface ( self ) result ( si ) !< Return smoothness indicators. import :: weights_object , RPP class ( weights_object ), intent ( in ) :: self !< Weights. real ( RPP ), allocatable :: si (:,:) !< Smoothness indicators. endfunction smoothness_indicators_interface endinterface endmodule wenoof_weights_object","tags":"","loc":"sourcefile/wenoof_weights_object.f90.html","title":"wenoof_weights_object.F90 – FORESEER"},{"text":"Abstract alpha (non linear weights) object. This File Depends On sourcefile~~wenoof_alpha_object.f90~~EfferentGraph sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_alpha_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_alpha_object.f90~~AfferentGraph sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_alpha_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_alpha_object Source Code wenoof_alpha_object.F90 Source Code !< Abstract alpha (non linear weights) object. module wenoof_alpha_object !< Abstract alpha (non linear weights) object. #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_base_object use wenoof_beta_object use wenoof_kappa_object implicit none private public :: alpha_object public :: alpha_object_constructor type , extends ( base_object_constructor ), abstract :: alpha_object_constructor !< Abstract alpha (non linear weights) object constructor. contains endtype alpha_object_constructor type , extends ( base_object ), abstract :: alpha_object !< Abstract alpha (non linear weights) object. real ( RPP ), allocatable :: values (:,:) !< Alpha coefficients [1:2,0:S-1]. real ( RPP ), allocatable :: values_sum (:) !< Sum of alpha coefficients [1:2]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute alpha. endtype alpha_object abstract interface !< Abstract interfaces of [[alpha_object]]. pure subroutine compute_interface ( self , beta , kappa ) !< Compute alpha. import :: alpha_object , beta_object , kappa_object class ( alpha_object ), intent ( inout ) :: self !< Alpha. class ( beta_object ), intent ( in ) :: beta !< Beta. class ( kappa_object ), intent ( in ) :: kappa !< Kappa. endsubroutine compute_interface endinterface endmodule wenoof_alpha_object","tags":"","loc":"sourcefile/wenoof_alpha_object.f90.html","title":"wenoof_alpha_object.F90 – FORESEER"},{"text":"Abstract base object, the ancestor of all. This File Depends On sourcefile~~wenoof_base_object.f90~~EfferentGraph sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_base_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_base_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_base_object.f90~~AfferentGraph sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_base_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_base_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_base_object Source Code wenoof_base_object.F90 Source Code !< Abstract base object, the ancestor of all. module wenoof_base_object !< Abstract base object, the ancestor of all. !< !< Define a minimal, base, object that is used as ancestor of all objects, e.g. smoothness indicator, optimal weights, etc... #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif implicit none private public :: base_object public :: base_object_constructor real ( RPP ), parameter :: EPS_DEF = 1 0._RPP ** ( - 6 ) !< Small epsilon to avoid division by zero, default value. type , abstract :: base_object_constructor !< Abstract base object constructor. integer ( I_P ) :: S = 0_I_P !< Stencils dimension. logical :: face_left = . true . !< Activate left-face interpolation computation. logical :: face_right = . true . !< Activate right-face interpolation computation. real ( RPP ) :: eps = EPS_DEF !< Small epsilon to avoid division by zero. contains procedure , pass ( self ) :: create => create_base_object_constructor endtype base_object_constructor type , abstract :: base_object !< Abstract base object, the ancestor of all. !< !< Define a minimal, base, object that is used as ancestor of all objects, e.g. smoothness indicator, optimal weights, etc... integer ( I_P ) :: S = 0_I_P !< Stencils dimension. integer ( I_P ) :: f1 = 1_I_P !< Lower bound of faces index. integer ( I_P ) :: f2 = 2_I_P !< Upper bound of faces index. integer ( I_P ) :: ff = 0_I_P !< Offset (step) of faces index. real ( RPP ) :: eps = EPS_DEF !< Small epsilon to avoid division by zero. contains ! public deferred methods procedure ( create_interface ), pass ( self ), deferred :: create !< Create object. procedure ( description_interface ), pass ( self ), deferred :: description !< Return object string-description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy object. ! public non overridable methods procedure , pass ( self ), non_overridable :: create_ !< Create object. procedure , pass ( self ), non_overridable :: destroy_ !< Destroy object. endtype base_object abstract interface !< Abstract interfaces of [[base_object]]. subroutine create_interface ( self , constructor ) !< Create object. !< !< @note Before call this method a concrete constructor must be instantiated. import :: base_object , base_object_constructor class ( base_object ), intent ( inout ) :: self !< Object. class ( base_object_constructor ), intent ( in ) :: constructor !< Object constructor. endsubroutine create_interface pure function description_interface ( self ) result ( string ) !< Return object string-description. import :: base_object class ( base_object ), intent ( in ) :: self !< Object. character ( len = :), allocatable :: string !< String-description. endfunction description_interface elemental subroutine destroy_interface ( self ) !< Destroy object. import :: base_object class ( base_object ), intent ( inout ) :: self !< Object. endsubroutine destroy_interface endinterface contains ! base object constructor ! public methods subroutine create_base_object_constructor ( self , S , face_left , face_right , eps ) !< Create alpha constructor. class ( base_object_constructor ), intent ( inout ) :: self !< Constructor. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid division by zero. self % S = S if ( present ( face_left )) self % face_left = face_left if ( present ( face_right )) self % face_right = face_right if ( present ( eps )) self % eps = eps endsubroutine create_base_object_constructor ! base object ! public non overridable methods subroutine create_ ( self , constructor ) !< Create object. class ( base_object ), intent ( inout ) :: self !< Object. class ( base_object_constructor ), intent ( in ) :: constructor !< Object constructor. call self % destroy_ select type ( constructor ) class is ( base_object_constructor ) self % S = constructor % S if ( constructor % face_left . and . constructor % face_right ) then self % f1 = 1_I_P ; self % f2 = 2_I_P ; self % ff = 0_I_P elseif ( constructor % face_left ) then self % f1 = 1_I_P ; self % f2 = 1_I_P ; self % ff = 0_I_P elseif ( constructor % face_right ) then self % f1 = 2_I_P ; self % f2 = 2_I_P ; self % ff = - 1_I_P endif self % eps = constructor % eps endselect endsubroutine create_ elemental subroutine destroy_ ( self ) !< Destroy object. class ( base_object ), intent ( inout ) :: self !< Object. self % S = 0_I_P self % f1 = 1_I_P self % f2 = 2_I_P self % ff = 0_I_P self % eps = EPS_DEF endsubroutine destroy_ endmodule wenoof_base_object","tags":"","loc":"sourcefile/wenoof_base_object.f90.html","title":"wenoof_base_object.F90 – FORESEER"},{"text":"Abstract Kappa (optimal, linear weights of stencil interpolations) object. This File Depends On sourcefile~~wenoof_kappa_object.f90~~EfferentGraph sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_kappa_objectf90EfferentGraph = svgPanZoom('#sourcefilewenoof_kappa_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_kappa_object.f90~~AfferentGraph sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilewenoof_kappa_objectf90AfferentGraph = svgPanZoom('#sourcefilewenoof_kappa_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_kappa_object Source Code wenoof_kappa_object.F90 Source Code !< Abstract Kappa (optimal, linear weights of stencil interpolations) object. module wenoof_kappa_object !< Abstract Kappa (optimal, linear weights of stencil interpolations) object. #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_base_object implicit none private public :: kappa_object public :: kappa_object_constructor type , extends ( base_object_constructor ), abstract :: kappa_object_constructor !< Abstract kappa object constructor. endtype kappa_object_constructor type , extends ( base_object ), abstract :: kappa_object !< Kappa (optimal, linear weights of stencil interpolations) object. real ( RPP ), allocatable :: values (:,:) !< Kappa coefficients values [1:2,0:S-1]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute kappa. endtype kappa_object abstract interface !< Abstract interfaces of [[kappa_object]]. pure subroutine compute_interface ( self ) !< Compute kappa. import :: kappa_object class ( kappa_object ), intent ( inout ) :: self !< Kappa. endsubroutine compute_interface endinterface endmodule wenoof_kappa_object","tags":"","loc":"sourcefile/wenoof_kappa_object.f90.html","title":"wenoof_kappa_object.F90 – FORESEER"},{"text":"Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. This File Depends On sourcefile~~wenoof_beta_rec_js.f90~~EfferentGraph sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_beta_rec_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_beta_rec_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_beta_rec_js.f90~~AfferentGraph sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_beta_rec_jsf90AfferentGraph = svgPanZoom('#sourcefilewenoof_beta_rec_jsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_beta_rec_js Source Code wenoof_beta_rec_js.F90 Source Code !< Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. module wenoof_beta_rec_js !< Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. !< !< @note The provided beta object implements the smoothness indicators defined in *Efficient Implementation !< of Weighted ENO Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif use wenoof_base_object use wenoof_beta_object implicit none private public :: beta_rec_js public :: beta_rec_js_constructor type , extends ( beta_object_constructor ) :: beta_rec_js_constructor !< Jiang-Shu and Gerolymos-Senechal-Vallet beta object constructor. endtype beta_rec_js_constructor type , extends ( beta_object ) :: beta_rec_js !< Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. !< !< @note The provided beta object implements the smoothness indicators defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 private real ( RPP ), allocatable :: coef (:,:,:) !< Beta coefficients [1:2,0:S-1,0:S-1]. contains ! public deferred methods procedure , pass ( self ) :: create !< Create beta. procedure , pass ( self ) :: compute !< Compute beta. procedure , pass ( self ) :: description !< Return beta string-description. procedure , pass ( self ) :: destroy !< Destroy beta. endtype beta_rec_js contains ! public deferred methods subroutine create ( self , constructor ) !< Create beta. class ( beta_rec_js ), intent ( inout ) :: self !< Beta. class ( base_object_constructor ), intent ( in ) :: constructor !< Beta constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP allocate ( self % coef ( 0 : self % S - 1 , 0 : self % S - 1 , 0 : self % S - 1 )) associate ( c => self % coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! stencil 0 !       i*i      ;     (i-1)*i c ( 0 , 0 , 0 ) = 1._RPP ; c ( 1 , 0 , 0 ) = - 2._RPP !      /         ;     (i-1)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 1._RPP ! stencil 1 !  (i+1)*(i+1)   ;     (i+1)*i c ( 0 , 0 , 1 ) = 1._RPP ; c ( 1 , 0 , 1 ) = - 2._RPP !      /         ;      i*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 1._RPP case ( 3 ) ! 5th order ! stencil 0 !      i*i                ;       (i-1)*i             ;       (i-2)*i c ( 0 , 0 , 0 ) = 1 0._RPP / 3._RPP ; c ( 1 , 0 , 0 ) = - 3 1._RPP / 3._RPP ; c ( 2 , 0 , 0 ) = 1 1._RPP / 3._RPP !      /                  ;       (i-1)*(i-1)         ;       (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 2 5._RPP / 3._RPP ; c ( 2 , 1 , 0 ) = - 1 9._RPP / 3._RPP !      /                  ;        /                  ;       (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 4._RPP / 3._RPP ! stencil 1 !     (i+1)*(i+1)         ;        i*(i+1)            ;       (i-1)*(i+1) c ( 0 , 0 , 1 ) = 4._RPP / 3._RPP ; c ( 1 , 0 , 1 ) = - 1 3._RPP / 3._RPP ; c ( 2 , 0 , 1 ) = 5._RPP / 3._RPP !      /                  ;        i*i                ;       (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 1 3._RPP / 3._RPP ; c ( 2 , 1 , 1 ) = - 1 3._RPP / 3._RPP !      /                  ;        /                  ;       (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 4._RPP / 3._RPP ! stencil 2 !     (i+2)*(i+2)         ;       (i+1)*(i+2)         ;        i*(i+2) c ( 0 , 0 , 2 ) = 4._RPP / 3._RPP ; c ( 1 , 0 , 2 ) = - 1 9._RPP / 3._RPP ; c ( 2 , 0 , 2 ) = 1 1._RPP / 3._RPP !      /                  ;       (i+1)*(i+1)         ;        i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 2 5._RPP / 3._RPP ; c ( 2 , 1 , 2 ) = - 3 1._RPP / 3._RPP !      /                  ;        /                  ;        i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 1 0._RPP / 3._RPP case ( 4 ) ! 7th order ! stencil 0 !              i*i              ;            (i-1)*i              ;            (i-2)*i c ( 0 , 0 , 0 ) = 210 7._RPP / 24 0._RPP ; c ( 1 , 0 , 0 ) = - 156 7._RPP / 4 0._RPP ; c ( 2 , 0 , 0 ) = 352 1._RPP / 12 0._RPP !          (i-3)*i c ( 3 , 0 , 0 ) = - 30 9._RPP / 4 0._RPP !               /               ;            (i-1)*(i-1)          ;            (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 1100 3._RPP / 24 0._RPP ; c ( 2 , 1 , 0 ) = - 862 3._RPP / 12 0._RPP !          (i-3)*(i-1) c ( 3 , 1 , 0 ) = 232 1._RPP / 12 0._RPP !               /               ;                 /               ;            (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 704 3._RPP / 24 0._RPP !          (i-3)*(i-2) c ( 3 , 2 , 0 ) = - 64 7._RPP / 4 0._RPP !               /               ;                 /               ;                 / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP ; c ( 2 , 3 , 0 ) = 0._RPP !          (i-3)*(i-3) c ( 3 , 3 , 0 ) = 54 7._RPP / 24 0._RPP ! stencil 1 !          (i+1)*(i+1)          ;                i*(i+1)          ;            (i-1)*(i+1) c ( 0 , 0 , 1 ) = 54 7._RPP / 24 0._RPP ; c ( 1 , 0 , 1 ) = - 126 1._RPP / 12 0._RPP ; c ( 2 , 0 , 1 ) = 96 1._RPP / 12 0._RPP !          (i-2)*(i+1) c ( 3 , 0 , 1 ) = - 24 7._RPP / 12 0._RPP !               /               ;                i*i              ;            (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 344 3._RPP / 24 0._RPP ; c ( 2 , 1 , 1 ) = - 298 3._RPP / 12 0._RPP !          (i-2)*i c ( 3 , 1 , 1 ) = 26 7._RPP / 4 0._RPP !               /               ;                 /               ;            (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 284 3._RPP / 24 0._RPP !          (i-2)*(i-1) c ( 3 , 2 , 1 ) = - 82 1._RPP / 12 0._RPP !               /               ;                 /               ;                 / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP ; c ( 2 , 3 , 1 ) = 0._RPP !          (i-2)*(i-2) c ( 3 , 3 , 1 ) = 8 9._RPP / 8 0._RPP ! stencil 2 !          (i+2)*(i+2)          ;            (i+1)*(i+2)          ;                i*(i+2) c ( 0 , 0 , 2 ) = 8 9._RPP / 8 0._RPP ; c ( 1 , 0 , 2 ) = - 82 1._RPP / 12 0._RPP ; c ( 2 , 0 , 2 ) = 26 7._RPP / 4 0._RPP !          (i-1)*(i+2) c ( 3 , 0 , 2 ) = - 24 7._RPP / 12 0._RPP !               /               ;            (i+1)*(i+1)          ;                i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 284 3._RPP / 24 0._RPP ; c ( 2 , 1 , 2 ) = - 298 3._RPP / 12 0._RPP !          (i-1)*(i+1) c ( 3 , 1 , 2 ) = 96 1._RPP / 12 0._RPP !               /               ;                 /               ;                i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 344 3._RPP / 24 0._RPP !          (i-1)*i c ( 3 , 2 , 2 ) = - 126 1._RPP / 12 0._RPP !               /               ;                 /               ;                 / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP ; c ( 2 , 3 , 2 ) = 0._RPP !          (i-1)*(i-1) c ( 3 , 3 , 2 ) = 54 7._RPP / 24 0._RPP ! stencil 3 !          (i+3)*(i+3)          ;            (i+2)*(i+3)          ;            (i+1)*(i+3) c ( 0 , 0 , 3 ) = 54 7._RPP / 24 0._RPP ; c ( 1 , 0 , 3 ) = - 64 7._RPP / 4 0._RPP ; c ( 2 , 0 , 3 ) = 232 1._RPP / 12 0._RPP !              i*(i+3) c ( 3 , 0 , 3 ) = - 30 9._RPP / 4 0._RPP !               /               ;            (i+2)*(i+2)          ;      (i+1)*(i+2) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 704 3._RPP / 24 0._RPP ; c ( 2 , 1 , 3 ) = - 862 3._RPP / 12 0._RPP !              i*(i+2) c ( 3 , 1 , 3 ) = 352 1._RPP / 12 0._RPP !               /               ;                 /               ;      (i+1)*(i+1) c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP ; c ( 2 , 2 , 3 ) = 1100 3._RPP / 24 0._RPP !              i*(i+1) c ( 3 , 2 , 3 ) = - 156 7._RPP / 4 0._RPP !               /               ;                 /               ;           / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP ; c ( 2 , 3 , 3 ) = 0._RPP !              i*i c ( 3 , 3 , 3 ) = 210 7._RPP / 24 0._RPP case ( 5 ) ! 9th order ! stencil 0 !              i*i                 ;             (i-1)*i                ;             (i-2)*i c ( 0 , 0 , 0 ) = 5395 9._RPP / 252 0._RPP ; c ( 1 , 0 , 0 ) = - 64950 1._RPP / 504 0._RPP ; c ( 2 , 0 , 0 ) = 25294 1._RPP / 168 0._RPP !          (i-3)*i                 ;             (i-4)*i c ( 3 , 0 , 0 ) = - 41148 7._RPP / 504 0._RPP ; c ( 4 , 0 , 0 ) = 8632 9._RPP / 504 0._RPP !               /                  ;             (i-1)*(i-1)            ;             (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 102056 3._RPP / 504 0._RPP ; c ( 2 , 1 , 0 ) = - 6839 1._RPP / 14 0._RPP !          (i-3)*(i-1)             ;             (i-4)*(i-1) c ( 3 , 1 , 0 ) = 67922 9._RPP / 252 0._RPP ; c ( 4 , 1 , 0 ) = - 28800 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 50713 1._RPP / 168 0._RPP !          (i-3)*(i-2)             ;             (i-4)*(i-2) c ( 3 , 2 , 0 ) = - 14203 3._RPP / 42 0._RPP ; c ( 4 , 2 , 0 ) = 12162 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP ; c ( 2 , 3 , 0 ) = 0._RPP !          (i-3)*(i-3)             ;             (i-4)*(i-3) c ( 3 , 3 , 0 ) = 48296 3._RPP / 504 0._RPP ; c ( 4 , 3 , 0 ) = - 20850 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP ; c ( 2 , 4 , 0 ) = 0._RPP !               /                  ;             (i-4)*(i-4) c ( 3 , 4 , 0 ) = 0._RPP ; c ( 4 , 4 , 0 ) = 1132 9._RPP / 252 0._RPP ! stencil 1 !          (i+1)*(i+1)             ;                 i*(i+1)            ;             (i-1)*(i+1) c ( 0 , 0 , 1 ) = 1132 9._RPP / 252 0._RPP ; c ( 1 , 0 , 1 ) = - 14025 1._RPP / 504 0._RPP ; c ( 2 , 0 , 1 ) = 5505 1._RPP / 168 0._RPP !          (i-2)*(i+1)             ;             (i-3)*(i+1) c ( 3 , 0 , 1 ) = - 8829 7._RPP / 504 0._RPP ; c ( 4 , 0 , 1 ) = 1807 9._RPP / 504 0._RPP !               /                  ;                 i*i                ;             (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 24272 3._RPP / 504 0._RPP ; c ( 2 , 1 , 1 ) = - 2549 9._RPP / 21 0._RPP !          (i-2)*i                 ;             (i-3)*i c ( 3 , 1 , 1 ) = 16850 9._RPP / 252 0._RPP ; c ( 4 , 1 , 1 ) = - 7023 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 13543 1._RPP / 168 0._RPP !          (i-2)*(i-1)             ;             (i-3)*(i-1) c ( 3 , 2 , 1 ) = - 322 9._RPP / 3 5._RPP ; c ( 4 , 2 , 1 ) = 3307 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP ; c ( 2 , 3 , 1 ) = 0._RPP !          (i-2)*(i-2)             ;             (i-3)*(i-2) c ( 3 , 3 , 1 ) = 13856 3._RPP / 504 0._RPP ; c ( 4 , 3 , 1 ) = - 6087 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP ; c ( 2 , 4 , 1 ) = 0._RPP !               /                  ;             (i-3)*(i-3) c ( 3 , 4 , 1 ) = 0._RPP ; c ( 4 , 4 , 1 ) = 172 7._RPP / 126 0._RPP ! stencil 2 !          (i+2)*(i+2)             ;             (i+1)*(i+2)            ;                 i*(i+2) c ( 0 , 0 , 2 ) = 172 7._RPP / 126 0._RPP ; c ( 1 , 0 , 2 ) = - 5100 1._RPP / 504 0._RPP ; c ( 2 , 0 , 2 ) = 754 7._RPP / 56 0._RPP !          (i-1)*(i+2)             ;             (i-2)*(i+2) c ( 3 , 0 , 2 ) = - 3894 7._RPP / 504 0._RPP ; c ( 4 , 0 , 2 ) = 820 9._RPP / 504 0._RPP !               /                  ;             (i+1)*(i+1)            ;                 i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 10496 3._RPP / 504 0._RPP ; c ( 2 , 1 , 2 ) = - 2492 3._RPP / 42 0._RPP !          (i-1)*(i+1)             ;             (i-2)*(i+1) c ( 3 , 1 , 2 ) = 8954 9._RPP / 252 0._RPP ; c ( 4 , 1 , 2 ) = - 3894 7._RPP / 504 0._RPP !               /                  ;                  /                 ;                 i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 7705 1._RPP / 168 0._RPP !          (i-1)*i                 ;             (i-2)*i c ( 3 , 2 , 2 ) = - 2492 3._RPP / 42 0._RPP ; c ( 4 , 2 , 2 ) = 754 7._RPP / 56 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP ; c ( 2 , 3 , 2 ) = 0._RPP !          (i-1)*(i-1)             ;             (i-2)*(i-1) c ( 3 , 3 , 2 ) = 10496 3._RPP / 504 0._RPP ; c ( 4 , 3 , 2 ) = - 5100 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP ; c ( 2 , 4 , 2 ) = 0._RPP !               /                  ;             (i-2)*(i-2) c ( 3 , 4 , 2 ) = 0._RPP ; c ( 4 , 4 , 2 ) = 172 7._RPP / 126 0._RPP ! stencil 3 !          (i+3)*(i+3)             ;             (i+2)*(i+3)            ;             (i+1)*(i+3) c ( 0 , 0 , 3 ) = 172 7._RPP / 126 0._RPP ; c ( 1 , 0 , 3 ) = - 6087 1._RPP / 504 0._RPP ; c ( 2 , 0 , 3 ) = 3307 1._RPP / 168 0._RPP !              i*(i+3)             ;             (i-1)*(i+3) c ( 3 , 0 , 3 ) = - 7023 7._RPP / 504 0._RPP ; c ( 4 , 0 , 3 ) = 1807 9._RPP / 504 0._RPP !               /                  ;             (i+2)*(i+2)            ;             (i+1)*(i+2) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 13856 3._RPP / 504 0._RPP ; c ( 2 , 1 , 3 ) = - 322 9._RPP / 3 5._RPP !              i*(i+2)             ;             (i-1)*(i+2) c ( 3 , 1 , 3 ) = 16850 9._RPP / 252 0._RPP ; c ( 4 , 1 , 3 ) = - 8829 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i+1)*(i+1) c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP ; c ( 2 , 2 , 3 ) = 13543 1._RPP / 168 0._RPP !              i*(i+1)             ;             (i-1)*(i+1) c ( 3 , 2 , 3 ) = - 2549 9._RPP / 21 0._RPP ; c ( 4 , 2 , 3 ) = 5505 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP ; c ( 2 , 3 , 3 ) = 0._RPP !              i*i                 ;             (i-1)*i c ( 3 , 3 , 3 ) = 24272 3._RPP / 504 0._RPP ; c ( 4 , 3 , 3 ) = - 14025 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP ; c ( 2 , 4 , 3 ) = 0._RPP !               /                  ;             (i-1)*(i-1) c ( 3 , 4 , 3 ) = 0._RPP ; c ( 4 , 4 , 3 ) = 1132 9._RPP / 252 0._RPP ! stencil 4 !          (i+4)*(i+4)             ;             (i+3)*(i+4)            ;             (i+2)*(i+4) c ( 0 , 0 , 4 ) = 1132 9._RPP / 252 0._RPP ; c ( 1 , 0 , 4 ) = - 20850 1._RPP / 504 0._RPP ; c ( 2 , 0 , 4 ) = 12162 1._RPP / 168 0._RPP !          (i+1)*(i+4)             ;                 i*(i+4) c ( 3 , 0 , 4 ) = - 28800 7._RPP / 504 0._RPP ; c ( 4 , 0 , 4 ) = 8632 9._RPP / 504 0._RPP !               /                  ;             (i+3)*(i+3)            ;             (i+2)*(i+3) c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 48296 3._RPP / 504 0._RPP ; c ( 2 , 1 , 4 ) = - 14203 3._RPP / 42 0._RPP !          (i+1)*(i+3)             ;                 i*(i+3) c ( 3 , 1 , 4 ) = 67922 9._RPP / 252 0._RPP ; c ( 4 , 1 , 4 ) = - 41148 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i+1)*(i+2) c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP ; c ( 2 , 2 , 4 ) = 50713 1._RPP / 168 0._RPP !          (i+1)*(i+2)             ;                 i*(i+2) c ( 3 , 2 , 4 ) = - 6839 1._RPP / 14 0._RPP ; c ( 4 , 2 , 4 ) = 25294 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP ; c ( 2 , 3 , 4 ) = 0._RPP !          (i+1)*(i+1)             ;                 i*(i+1) c ( 3 , 3 , 4 ) = 102056 3._RPP / 504 0._RPP ; c ( 4 , 3 , 4 ) = - 64950 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP ; c ( 2 , 4 , 4 ) = 0._RPP !               /                  ;                 i*i c ( 3 , 4 , 4 ) = 0._RPP ; c ( 4 , 4 , 4 ) = 5395 9._RPP / 252 0._RPP case ( 6 ) ! 11th order ! stencil 0 !                 i*i                  ;                (i-1)*i                 ;                 (i-2)*i c ( 0 , 0 , 0 ) = 615021 1._RPP / 12096 0._RPP ; c ( 1 , 0 , 0 ) = - 296627 9._RPP / 756 0._RPP ; c ( 2 , 0 , 0 ) = 476292 1._RPP / 756 0._RPP !             (i-3)*i                  ;                (i-4)*i                 ;                 (i-5)*i c ( 3 , 0 , 0 ) = - 1584853 1._RPP / 3024 0._RPP ; c ( 4 , 0 , 0 ) = 270601 7._RPP / 1209 6._RPP ; c ( 5 , 0 , 0 ) = - 23563 7._RPP / 604 8._RPP !                  /                   ;                (i-1)*(i-1)             ;                 (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 3161707 9._RPP / 4032 0._RPP ; c ( 2 , 1 , 0 ) = - 2598093 7._RPP / 1008 0._RPP !             (i-3)*(i-1)              ;                (i-4)*(i-1)             ;                 (i-5)*(i-1) c ( 3 , 1 , 0 ) = 3286270 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 0 ) = - 104821 1._RPP / 112 0._RPP ; c ( 5 , 1 , 0 ) = 66114 5._RPP / 403 2._RPP !                  /                   ;                     /                  ;                 (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 2170378 1._RPP / 1008 0._RPP !              (i-3)*(i-2)             ;                (i-4)*(i-2)             ;                 (i-5)*(i-2) c ( 3 , 2 , 0 ) = - 693756 1._RPP / 189 0._RPP ; c ( 4 , 2 , 0 ) = 267495 1._RPP / 168 0._RPP ; c ( 5 , 2 , 0 ) = - 31406 3._RPP / 112 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP ; c ( 2 , 3 , 0 ) = 0._RPP !             (i-3)*(i-3)              ;                (i-4)*(i-3)             ;                 (i-5)*(i-3) c ( 3 , 3 , 0 ) = 4768939 3._RPP / 3024 0._RPP ; c ( 4 , 3 , 0 ) = - 4161526 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 0 ) = 184014 1._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP ; c ( 2 , 4 , 0 ) = 0._RPP !                  /                   ;                (i-4)*(i-4)             ;                 (i-5)*(i-4) c ( 3 , 4 , 0 ) = 0._RPP ; c ( 4 , 4 , 0 ) = 1216022 9._RPP / 4032 0._RPP ; c ( 5 , 4 , 0 ) = - 53959 1._RPP / 504 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP ; c ( 2 , 5 , 0 ) = 0._RPP !                  /                   ;                     /                  ;                 (i-5)*(i-5) c ( 3 , 5 , 0 ) = 0._RPP ; c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 38418 7._RPP / 4032 0._RPP ! stencil 1 !             (i+1)*(i+1)              ;                    i*(i+1)             ;                 (i-1)*(i+1) c ( 0 , 0 , 1 ) = 38418 7._RPP / 4032 0._RPP ; c ( 1 , 0 , 1 ) = - 113974 9._RPP / 1512 0._RPP ; c ( 2 , 0 , 1 ) = 6142 7._RPP / 50 4._RPP ; !             (i-2)*(i+1)              ;                (i-3)*(i+1)             ;                 (i-4)*(i+1) c ( 3 , 0 , 1 ) = - 101530 3._RPP / 1008 0._RPP ; c ( 4 , 0 , 1 ) = 256728 7._RPP / 6048 0._RPP ; c ( 5 , 0 , 1 ) = - 7337 9._RPP / 1008 0._RPP ; !                  /                   ;                    i*i                 ;                 (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 1936596 7._RPP / 12096 0._RPP ; c ( 2 , 1 , 1 ) = - 1630606 1._RPP / 3024 0._RPP !             (i-2)*i                  ;                (i-3)*i                 ;                 (i-4)*i c ( 3 , 1 , 1 ) = 688171 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 1 ) = - 587761 7._RPP / 3024 0._RPP ; c ( 5 , 1 , 1 ) = 203350 9._RPP / 6048 0._RPP !                  /                   ;                     /                  ;                 (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 472185 1._RPP / 1008 0._RPP !             (i-2)*(i-1)              ;                (i-3)*(i-1)             ;                 (i-4)*(i-1) c ( 3 , 2 , 1 ) = - 16985 9._RPP / 21 0._RPP ; c ( 4 , 2 , 1 ) = 530062 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 1 ) = - 6860 1._RPP / 112 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP ; c ( 2 , 3 , 1 ) = 0._RPP !             (i-2)*(i-2)              ;                (i-3)*(i-2)             ;                 (i-4)*(i-2) c ( 3 , 3 , 1 ) = 119704 7._RPP / 336 0._RPP ; c ( 4 , 3 , 1 ) = - 947833 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 1 ) = 13947 1._RPP / 252 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP ; c ( 2 , 4 , 1 ) = 0._RPP !                  /                   ;                (i-3)*(i-3)             ;                 (i-4)*(i-3) c ( 3 , 4 , 1 ) = 0._RPP ; c ( 4 , 4 , 1 ) = 844995 7._RPP / 12096 0._RPP ; c ( 5 , 4 , 1 ) = - 18848 3._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP ; c ( 2 , 5 , 1 ) = 0._RPP !                  /                   ;                     /                  ;                 (i-4)*(i-4) c ( 3 , 5 , 1 ) = 0._RPP ; c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 9059 3._RPP / 4032 0._RPP ! stencil 2 !             (i+2)*(i+2)              ;                (i+1)*(i+2)             ;                     i*(i+2) c ( 0 , 0 , 2 ) = 9059 3._RPP / 4032 0._RPP ; c ( 1 , 0 , 2 ) = - 124 0._RPP / 6 3._RPP ; c ( 2 , 0 , 2 ) = 25539 7._RPP / 756 0._RPP !             (i-1)*(i+2)              ;                (i-2)*(i+2)             ;                 (i-3)*(i+2) c ( 3 , 0 , 2 ) = - 28852 1._RPP / 1008 0._RPP ; c ( 4 , 0 , 2 ) = 24312 7._RPP / 2016 0._RPP ; c ( 5 , 0 , 2 ) = - 1228 1._RPP / 604 8._RPP !                  /                   ;                (i+1)*(i+1)             ;                     i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 188443 9._RPP / 4032 0._RPP ; c ( 2 , 1 , 2 ) = - 510697 1._RPP / 3024 0._RPP !             (i-1)*(i+1)              ;                (i-2)*(i+1)             ;                (i-3)*(i+1) c ( 3 , 1 , 2 ) = 24868 1._RPP / 168 0._RPP ; c ( 4 , 1 , 2 ) = - 64399 9._RPP / 1008 0._RPP ; c ( 5 , 1 , 2 ) = 66250 3._RPP / 6048 0._RPP !                  /                   ;                     /                  ;                    i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 487774 3._RPP / 3024 0._RPP !             (i-1)*i                  ;                (i-2)*i                 ;                (i-3)*i c ( 3 , 2 , 2 ) = - 55965 1._RPP / 189 0._RPP ; c ( 4 , 2 , 2 ) = 199123 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 2 ) = - 13963 3._RPP / 604 8._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP ; c ( 2 , 3 , 2 ) = 0._RPP !             (i-1)*(i-1)              ;                (i-2)*(i-1)             ;                (i-3)*(i-1) c ( 3 , 3 , 2 ) = 15921 9._RPP / 112 0._RPP ; c ( 4 , 3 , 2 ) = - 132336 7._RPP / 1008 0._RPP ; c ( 5 , 3 , 2 ) = 17899 9._RPP / 756 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP ; c ( 2 , 4 , 2 ) = 0._RPP !                  /                   ;                (i-2)*(i-2)             ;                (i-3)*(i-2) c ( 3 , 4 , 2 ) = 0._RPP ; c ( 4 , 4 , 2 ) = 14166 1._RPP / 448 0._RPP ; c ( 5 , 4 , 2 ) = - 17874 7._RPP / 1512 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP ; c ( 2 , 5 , 2 ) = 0._RPP !                  /                   ;                     /                  ;                (i-3)*(i-3) c ( 3 , 5 , 2 ) = 0._RPP ; c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 13963 3._RPP / 12096 0._RPP ! stencil 3 !             (i+3)*(i+3)              ;                (i+2)*(i+3)             ;                 (i+1)*(i+3) c ( 0 , 0 , 3 ) = 13963 3._RPP / 12096 0._RPP ; c ( 1 , 0 , 3 ) = - 17874 7._RPP / 1512 0._RPP ; c ( 2 , 0 , 3 ) = 17899 9._RPP / 756 0._RPP !                 i*(i+3)              ;                (i-1)*(i+3)             ;                 (i-2)*(i+3) c ( 3 , 0 , 3 ) = - 13963 3._RPP / 604 8._RPP ; c ( 4 , 0 , 3 ) = 66250 3._RPP / 6048 0._RPP ; c ( 5 , 0 , 3 ) = - 1228 1._RPP / 604 8._RPP !                  /                   ;                (i+2)*(i+2)             ;                 (i+1)*(i+2) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 14166 1._RPP / 448 0._RPP ; c ( 2 , 1 , 3 ) = - 132336 7._RPP / 1008 0._RPP !                 i*(i+2)              ;                (i-1)*(i+2)             ;                 (i-2)*(i+2) c ( 3 , 1 , 3 ) = 199123 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 3 ) = - 64399 9._RPP / 1008 0._RPP ; c ( 5 , 1 , 3 ) = 24312 7._RPP / 2016 0._RPP !                  /                   ;                     /                  ;                    i*(i+1) c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP ; c ( 2 , 2 , 3 ) = 15921 9._RPP / 112 0._RPP !                 i*(i+1)              ;                (i-1)*(i+1)             ;                (i-2)*(i+1) c ( 3 , 2 , 3 ) = - 55965 1._RPP / 189 0._RPP ; c ( 4 , 2 , 3 ) = 24868 1._RPP / 168 0._RPP ; c ( 5 , 2 , 3 ) = - 28852 1._RPP / 1008 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP ; c ( 2 , 3 , 3 ) = 0._RPP !                 i*i                  ;                (i-1)*i                 ;                (i-2)*i c ( 3 , 3 , 3 ) = 487774 3._RPP / 3024 0._RPP ; c ( 4 , 3 , 3 ) = - 510697 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 3 ) = 25539 7._RPP / 756 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP ; c ( 2 , 4 , 3 ) = 0._RPP !                  /                   ;                (i-1)*(i-1)             ;                (i-2)*(i-1) c ( 3 , 4 , 3 ) = 0._RPP ; c ( 4 , 4 , 3 ) = 188443 9._RPP / 4032 0._RPP ; c ( 5 , 4 , 3 ) = - 124 0._RPP / 6 3._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP ; c ( 2 , 5 , 3 ) = 0._RPP !                  /                   ;                     /                  ;                (i-2)*(i-2) c ( 3 , 5 , 3 ) = 0._RPP ; c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 9059 3._RPP / 4032 0._RPP ! stencil 4 !             (i+4)*(i+4)              ;                (i+3)*(i+4)             ;                 (i+2)*(i+4) c ( 0 , 0 , 4 ) = 9059 3._RPP / 4032 0._RPP ; c ( 1 , 0 , 4 ) = - 18848 3._RPP / 756 0._RPP ; c ( 2 , 0 , 4 ) = 13947 1._RPP / 252 0._RPP !             (i+1)*(i+4)              ;                    i*(i+4)             ;                 (i-1)*(i+4) c ( 3 , 0 , 4 ) = - 6860 1._RPP / 112 0._RPP ; c ( 4 , 0 , 4 ) = 203350 9._RPP / 6048 0._RPP ; c ( 5 , 0 , 4 ) = - 7337 9._RPP / 1008 0._RPP !                  /                   ;                (i+3)*(i+3)             ;                 (i+2)*(i+3) c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 844995 7._RPP / 12096 0._RPP ; c ( 2 , 1 , 4 ) = - 947833 1._RPP / 3024 0._RPP !             (i+1)*(i+3)              ;                    i*(i+3)             ;                 (i-1)*(i+3) c ( 3 , 1 , 4 ) = 530062 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 4 ) = - 587761 7._RPP / 3024 0._RPP ; c ( 5 , 1 , 4 ) = 256728 7._RPP / 6048 0._RPP !                  /                   ;                     /                  ;                 (i+2)*(i+2) c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP ; c ( 2 , 2 , 4 ) = 119704 7._RPP / 336 0._RPP !             (i+1)*(i+2)              ;                    i*(i+2)             ;                 (i-1)*(i+2) c ( 3 , 2 , 4 ) = - 16985 9._RPP / 21 0._RPP ; c ( 4 , 2 , 4 ) = 688171 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 4 ) = - 101530 3._RPP / 1008 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP ; c ( 2 , 3 , 4 ) = 0._RPP !             (i+1)*(i+1)              ;                    i*(i+1)             ;                 (i-1)*(i+1) c ( 3 , 3 , 4 ) = 472185 1._RPP / 1008 0._RPP ; c ( 4 , 3 , 4 ) = - 1630606 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 4 ) = 6142 7._RPP / 50 4._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP ; c ( 2 , 4 , 4 ) = 0._RPP !                  /                   ;                    i*i                 ;                 (i-1)*i c ( 3 , 4 , 4 ) = 0._RPP ; c ( 4 , 4 , 4 ) = 1936596 7._RPP / 12096 0._RPP ; c ( 5 , 4 , 4 ) = - 113974 9._RPP / 1512 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP ; c ( 2 , 5 , 4 ) = 0._RPP !                  /                   ;                     /                  ;                 (i-1)*(i-1) c ( 3 , 5 , 4 ) = 0._RPP ; c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 38418 7._RPP / 4032 0._RPP ! stencil 5 !             (i+5)*(i+5)              ;                (i+4)*(i+5)             ;                 (i+3)*(i+5) c ( 0 , 0 , 5 ) = 38418 7._RPP / 4032 0._RPP ; c ( 1 , 0 , 5 ) = - 53959 1._RPP / 504 0._RPP ; c ( 2 , 0 , 5 ) = 184014 1._RPP / 756 0._RPP !             (i+2)*(i+5)              ;                (i+1)*(i+5)             ;                     i*(i+5) c ( 3 , 0 , 5 ) = - 31406 3._RPP / 112 0._RPP ; c ( 4 , 0 , 5 ) = 66114 5._RPP / 403 2._RPP ; c ( 5 , 0 , 5 ) = - 23563 7._RPP / 604 8._RPP !                  /                   ;                (i+4)*(i+3)             ;                 (i+3)*(i+3) c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 1216022 9._RPP / 4032 0._RPP ; c ( 2 , 1 , 5 ) = - 4161526 1._RPP / 3024 0._RPP !             (i+2)*(i+3)              ;                (i+1)*(i+3)             ;                     i*(i+3) c ( 3 , 1 , 5 ) = 267495 1._RPP / 168 0._RPP ; c ( 4 , 1 , 5 ) = - 104821 1._RPP / 112 0._RPP ; c ( 5 , 1 , 5 ) = 270601 7._RPP / 1209 6._RPP !                  /                   ;                     /                  ;                 (i+3)*(i+2) c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP ; c ( 2 , 2 , 5 ) = 4768939 3._RPP / 3024 0._RPP !             (i+2)*(i+2)              ;                (i+1)*(i+2)             ;                     i*(i+2) c ( 3 , 2 , 5 ) = - 693756 1._RPP / 189 0._RPP ; c ( 4 , 2 , 5 ) = 3286270 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 5 ) = - 1584853 1._RPP / 3024 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP ; c ( 2 , 3 , 5 ) = 0._RPP !             (i+2)*(i+1)              ;                (i+1)*(i+1)             ;                     i*(i+1) c ( 3 , 3 , 5 ) = 2170378 1._RPP / 1008 0._RPP ; c ( 4 , 3 , 5 ) = - 2598093 7._RPP / 1008 0._RPP ; c ( 5 , 3 , 5 ) = 476292 1._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP ; c ( 2 , 4 , 5 ) = 0._RPP !                  /                   ;                (i+1)*i                 ;                     i*i c ( 3 , 4 , 5 ) = 0._RPP ; c ( 4 , 4 , 5 ) = 3161707 9._RPP / 4032 0._RPP ; c ( 5 , 4 , 5 ) = - 296627 9._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP ; c ( 2 , 5 , 5 ) = 0._RPP !                  /                   ;                     /                  ;                     i*(i-1) c ( 3 , 5 , 5 ) = 0._RPP ; c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 615021 1._RPP / 12096 0._RPP case ( 7 ) ! 13th order ! stencil 0 !                   i*i                   ;                   (i-1)*i c ( 0 , 0 , 0 ) = 89720716 3._RPP / 748440 0._RPP ; c ( 1 , 0 , 0 ) = - 2276309235 7._RPP / 1995840 0._RPP !                  (i-2)*i                ;                   (i-3)*i c ( 2 , 0 , 0 ) = 4680858363 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 0 ) = - 3964543964 3._RPP / 1496880 0._RPP !                  (i-4)*i                ;                   (i-5)*i c ( 4 , 0 , 0 ) = 857930974 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 0 ) = - 241688504 3._RPP / 399168 0._RPP !                  (i-6)*i c ( 6 , 0 , 0 ) = 539152879 9._RPP / 5987520 0._RPP !                    /                    ;                   (i-1)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 618261273 1._RPP / 221760 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 2 , 1 , 0 ) = - 862343162 3._RPP / 73920 0._RPP ; c ( 3 , 1 , 0 ) = 6644004937 1._RPP / 498960 0._RPP !                  (i-4)*(i-1)            ;                   (i-5)*(i-1) c ( 4 , 1 , 0 ) = - 1930850567 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 0 ) = 341705736 7._RPP / 110880 0._RPP !                  (i-6)*(i-1) c ( 6 , 1 , 0 ) = - 918196195 9._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 2 , 2 , 0 ) = 136940474 9._RPP / 11088 0._RPP ; c ( 3 , 2 , 0 ) = - 2836489260 7._RPP / 99792 0._RPP !                  (i-4)*(i-2)            ;                   (i-5)*(i-2) c ( 4 , 2 , 0 ) = 829077191 3._RPP / 44352 0._RPP ; c ( 5 , 2 , 0 ) = - 1473417899 9._RPP / 221760 0._RPP !                  (i-6)*(i-2) c ( 6 , 2 , 0 ) = 496477189 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP !                    /                    ;                   (i-3)*(i-3) c ( 2 , 3 , 0 ) = 0._RPP ; c ( 3 , 3 , 0 ) = 4925685991 9._RPP / 299376 0._RPP !                  (i-4)*(i-3)            ;                   (i-5)*(i-3) c ( 4 , 3 , 0 ) = - 2169300276 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 0 ) = 3868338505 1._RPP / 498960 0._RPP !                  (i-6)*(i-3) c ( 6 , 3 , 0 ) = - 1742503220 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 0 ) = 0._RPP ; c ( 3 , 4 , 0 ) = 0._RPP !                  (i-4)*(i-4)            ;                   (i-5)*(i-4) c ( 4 , 4 , 0 ) = 19973092 1._RPP / 2772 0._RPP ; c ( 5 , 4 , 0 ) = - 380943782 3._RPP / 73920 0._RPP !                  (i-6)*(i-4) c ( 6 , 4 , 0 ) = 1547692635 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 0 ) = 0._RPP ; c ( 3 , 5 , 0 ) = 0._RPP !                    /                    ;                   (i-5)*(i-5) c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 204794188 3._RPP / 221760 0._RPP !                  (i-6)*(i-5) c ( 6 , 5 , 0 ) = - 555666927 7._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 0 ) = 0._RPP ; c ( 1 , 6 , 0 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 0 ) = 0._RPP ; c ( 3 , 6 , 0 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 0 ) = 0._RPP ; c ( 5 , 6 , 0 ) = 0._RPP !                  (i-6)*(i-6) c ( 6 , 6 , 0 ) = 6291129 7._RPP / 299376 0._RPP ! stencil 1 !                  (i+1)*(i+1)            ;                    i*(i+1) c ( 0 , 0 , 1 ) = 6291129 7._RPP / 299376 0._RPP ; c ( 1 , 0 , 1 ) = - 407454478 7._RPP / 1995840 0._RPP !                  (i-1)*(i+1)            ;                   (i-2)*(i+1) c ( 2 , 0 , 1 ) = 281106706 7._RPP / 665280 0._RPP ; c ( 3 , 0 , 1 ) = - 712463825 3._RPP / 1496880 0._RPP !                  (i-3)*(i+1)            ;                   (i-4)*(i+1) c ( 4 , 0 , 1 ) = 153130724 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 1 ) = - 71274560 3._RPP / 665280 0._RPP !                  (i-5)*(i+1) c ( 6 , 0 , 1 ) = 94515532 9._RPP / 5987520 0._RPP !                    /                    ;                       i*(i-1) c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 12794249 7._RPP / 24640 0._RPP !                  (i-1)*(i-1)            ;                   (i-2)*(i-1) c ( 2 , 1 , 1 ) = - 1468493305 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 1 ) = 1260100950 1._RPP / 498960 0._RPP !                  (i-3)*(i-1)            ;                   (i-4)*(i-1) c ( 4 , 1 , 1 ) = - 40538296 1._RPP / 24640 0._RPP ; c ( 5 , 1 , 1 ) = 192403251 1._RPP / 332640 0._RPP !                  (i-5)*(i-1) c ( 6 , 1 , 1 ) = - 34191075 7._RPP / 399168 0._RPP !                    /                    ;                    / c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP !                  (i-1)*(i-2)            ;                   (i-3)*(i-2) c ( 2 , 2 , 1 ) = 79635877 7._RPP / 33264 0._RPP ; c ( 3 , 2 , 1 ) = - 61641031 3._RPP / 11088 0._RPP !                  (i-4)*(i-2)            ;                   (i-5)*(i-2) c ( 4 , 2 , 1 ) = 486808918 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 1 ) = - 861944098 7._RPP / 665280 0._RPP !                  (i-6)*(i-2) c ( 6 , 2 , 1 ) = 32078218 3._RPP / 166320 0._RPP !                    /                    ;                     / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP !                    /                    ;                   (i-2)*(i-3) c ( 2 , 3 , 1 ) = 0._RPP ; c ( 3 , 3 , 1 ) = 978005716 9._RPP / 299376 0._RPP !                  (i-3)*(i-3)            ;                   (i-4)*(i-3) c ( 4 , 3 , 1 ) = - 433064005 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 1 ) = 85783846 9._RPP / 55440 0._RPP !                  (i-5)*(i-3) c ( 6 , 3 , 1 ) = - 346560749 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 1 ) = 0._RPP ; c ( 3 , 4 , 1 ) = 0._RPP !                  (i-3)*(i-4)            ;                   (i-4)*(i-4) c ( 4 , 4 , 1 ) = 5367868 3._RPP / 3696 0._RPP ; c ( 5 , 4 , 1 ) = - 693248065 7._RPP / 665280 0._RPP !                  (i-5)*(i-4) c ( 6 , 4 , 1 ) = 312671848 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 1 ) = 0._RPP ; c ( 3 , 5 , 1 ) = 0._RPP !                    /                    ;                   (i-5)*(i-5) c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 125000764 3._RPP / 665280 0._RPP !                  (i-6)*(i-5) c ( 6 , 5 , 1 ) = - 37747468 9._RPP / 665280 0._RPP !                    /                    ;                     / c ( 0 , 6 , 1 ) = 0._RPP ; c ( 1 , 6 , 1 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 1 ) = 0._RPP ; c ( 3 , 6 , 1 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 1 ) = 0._RPP ; c ( 5 , 6 , 1 ) = 0._RPP !                  (i-6)*(i-5) c ( 6 , 6 , 1 ) = 6436177 1._RPP / 1496880 0._RPP ! stencil 2 !                  (i+2)*i                ;                   (i+1)*i c ( 0 , 0 , 2 ) = 6436177 1._RPP / 1496880 0._RPP ; c ( 1 , 0 , 2 ) = - 29545598 3._RPP / 665280 0._RPP !                      i*i                ;                   (i-1)*i c ( 2 , 0 , 2 ) = 189470539 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 2 ) = - 161828432 3._RPP / 1496880 0._RPP !                  (i-2)*i                ;                   (i-3)*i c ( 4 , 0 , 2 ) = 11552405 3._RPP / 166320 0._RPP ; c ( 5 , 0 , 2 ) = - 9550813 9._RPP / 399168 0._RPP !                  (i-4)*i c ( 6 , 0 , 2 ) = 827947 9._RPP / 239500 8._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 80633841 7._RPP / 665280 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 2 ) = - 357379840 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 2 ) = 104253133 7._RPP / 166320 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 2 ) = - 272557531 7._RPP / 665280 0._RPP ; c ( 5 , 1 , 2 ) = 47532109 3._RPP / 332640 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 2 ) = - 1540162 9._RPP / 73920 0._RPP !                    /                    ;                    / c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 2 ) = 3418731 7._RPP / 5544 0._RPP ; c ( 3 , 2 , 2 ) = - 147661888 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 2 ) = 131211445 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 2 ) = - 77374943 9._RPP / 221760 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 2 ) = 25655684 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 2 ) = 0._RPP ; c ( 3 , 3 , 2 ) = 272658535 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 2 ) = - 41242402 9._RPP / 33264 0._RPP ; c ( 5 , 3 , 2 ) = 222453801 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 2 ) = - 99560072 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 2 ) = 0._RPP ; c ( 3 , 4 , 2 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 2 ) = 14327095 7._RPP / 33264 0._RPP ; c ( 5 , 4 , 2 ) = - 209657188 7._RPP / 665280 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 2 ) = 10570699 9._RPP / 221760 0._RPP !                    /                    ;                     / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 2 ) = 0._RPP ; c ( 3 , 5 , 2 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 13001356 3._RPP / 221760 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 2 ) = - 35932142 9._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 2 ) = 0._RPP ; c ( 1 , 6 , 2 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 2 ) = 0._RPP ; c ( 3 , 6 , 2 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 2 ) = 0._RPP ; c ( 5 , 6 , 2 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 2 ) = 262720 3._RPP / 187110 0._RPP ! stencil 3 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 3 ) = 262720 3._RPP / 187110 0._RPP ; c ( 1 , 0 , 3 ) = - 32333332 3._RPP / 1995840 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 3 ) = 76114296 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 3 ) = - 70156313 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 3 ) = 15854431 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 3 ) = - 22562395 3._RPP / 1995840 0._RPP !                  (i-3)*i c ( 6 , 0 , 3 ) = 9902265 7._RPP / 5987520 0._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 10844416 9._RPP / 221760 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 3 ) = - 17649851 3._RPP / 73920 0._RPP ; c ( 3 , 1 , 3 ) = 150694498 1._RPP / 498960 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 3 ) = - 46467836 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 3 ) = 8426374 9._RPP / 110880 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 3 ) = - 22562395 3._RPP / 1995840 0._RPP !                    /                    ;                    / c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 3 ) = 1679070 7._RPP / 5544 0._RPP ; c ( 3 , 2 , 3 ) = - 79053117 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 3 ) = 25052354 3._RPP / 44352 0._RPP ; c ( 5 , 2 , 3 ) = - 46467836 9._RPP / 221760 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 3 ) = 15854431 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 3 ) = 0._RPP ; c ( 3 , 3 , 3 ) = 160773916 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 3 ) = - 79053117 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 3 ) = 150694498 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 3 ) = - 70156313 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 3 ) = 0._RPP ; c ( 3 , 4 , 3 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 3 ) = 1679070 7._RPP / 5544 0._RPP ; c ( 5 , 4 , 3 ) = - 17649851 3._RPP / 73920 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 3 ) = 76114296 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 3 ) = 0._RPP ; c ( 3 , 5 , 3 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 10844416 9._RPP / 221760 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 3 ) = - 32333332 3._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 3 ) = 0._RPP ; c ( 1 , 6 , 3 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 3 ) = 0._RPP ; c ( 3 , 6 , 3 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 3 ) = 0._RPP ; c ( 5 , 6 , 3 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 3 ) = 262720 3._RPP / 187110 0._RPP ! stencil 4 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 4 ) = 262720 3._RPP / 187110 0._RPP ; c ( 1 , 0 , 4 ) = - 35932142 9._RPP / 1995840 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 4 ) = 10570699 9._RPP / 221760 0._RPP ; c ( 3 , 0 , 4 ) = - 99560072 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 4 ) = 25655684 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 4 ) = - 1540162 9._RPP / 73920 0._RPP !                  (i-3)*i c ( 6 , 0 , 4 ) = 827947 9._RPP / 239500 8._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 13001356 3._RPP / 221760 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 4 ) = - 209657188 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 4 ) = 222453801 1._RPP / 498960 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 4 ) = - 77374943 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 4 ) = 47532109 3._RPP / 332640 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 4 ) = - 9550813 9._RPP / 399168 0._RPP !                    /                    ;                    / c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 4 ) = 14327095 7._RPP / 33264 0._RPP ; c ( 3 , 2 , 4 ) = - 41242402 9._RPP / 33264 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 4 ) = 131211445 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 4 ) = - 272557531 7._RPP / 665280 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 4 ) = 11552405 3._RPP / 166320 0._RPP !                    /                    ;                     / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 4 ) = 0._RPP ; c ( 3 , 3 , 4 ) = 272658535 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 4 ) = - 147661888 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 4 ) = 104253133 7._RPP / 166320 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 4 ) = - 161828432 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 4 ) = 0._RPP ; c ( 3 , 4 , 4 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 4 ) = 3418731 7._RPP / 5544 0._RPP ; c ( 5 , 4 , 4 ) = - 357379840 7._RPP / 665280 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 4 ) = 189470539 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 4 ) = 0._RPP ; c ( 3 , 5 , 4 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 80633841 7._RPP / 665280 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 4 ) = - 29545598 3._RPP / 665280 0._RPP !                    /                    ;                     / c ( 0 , 6 , 4 ) = 0._RPP ; c ( 1 , 6 , 4 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 4 ) = 0._RPP ; c ( 3 , 6 , 4 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 4 ) = 0._RPP ; c ( 5 , 6 , 4 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 4 ) = 6436177 1._RPP / 1496880 0._RPP ! stencil 5 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 5 ) = 6436177 1._RPP / 1496880 0._RPP ; c ( 1 , 0 , 5 ) = - 37747468 9._RPP / 665280 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 5 ) = 312671848 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 5 ) = - 346560749 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 5 ) = 32078218 3._RPP / 166320 0._RPP ; c ( 5 , 0 , 5 ) = - 34191075 7._RPP / 399168 0._RPP !                  (i-3)*i c ( 6 , 0 , 5 ) = 94515532 9._RPP / 5987520 0._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 125000764 3._RPP / 665280 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 5 ) = - 693248065 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 5 ) = 85783846 9._RPP / 55440 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 5 ) = - 861944098 7._RPP / 665280 0._RPP ; c ( 5 , 1 , 5 ) = 192403251 1._RPP / 332640 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 5 ) = - 71274560 3._RPP / 665280 0._RPP !                    /                    ;                    / c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 5 ) = 5367868 3._RPP / 3696 0._RPP ; c ( 3 , 2 , 5 ) = - 433064005 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 5 ) = 486808918 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 5 ) = - 40538296 1._RPP / 24640 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 5 ) = 153130724 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 5 ) = 0._RPP ; c ( 3 , 3 , 5 ) = 978005716 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 5 ) = - 61641031 3._RPP / 11088 0._RPP ; c ( 5 , 3 , 5 ) = 1260100950 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 5 ) = - 712463825 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 5 ) = 0._RPP ; c ( 3 , 4 , 5 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 5 ) = 79635877 7._RPP / 33264 0._RPP ; c ( 5 , 4 , 5 ) = - 1468493305 7._RPP / 665280 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 5 ) = 281106706 7._RPP / 665280 0._RPP !                    /                    ;                     / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 5 ) = 0._RPP ; c ( 3 , 5 , 5 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 12794249 7._RPP / 24640 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 5 ) = - 407454478 7._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 5 ) = 0._RPP ; c ( 1 , 6 , 5 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 5 ) = 0._RPP ; c ( 3 , 6 , 5 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 5 ) = 0._RPP ; c ( 5 , 6 , 5 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 5 ) = 6291129 7._RPP / 299376 0._RPP ! stencil 6 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 6 ) = 6291129 7._RPP / 299376 0._RPP ; c ( 1 , 0 , 6 ) = - 555666927 7._RPP / 1995840 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 6 ) = 1547692635 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 6 ) = - 1742503220 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 6 ) = 496477189 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 6 ) = - 918196195 9._RPP / 1995840 0._RPP !                  (i-3)*i c ( 6 , 0 , 6 ) = 539152879 9._RPP / 5987520 0._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 6 ) = 0._RPP ; c ( 1 , 1 , 6 ) = 204794188 3._RPP / 221760 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 6 ) = - 380943782 3._RPP / 73920 0._RPP ; c ( 3 , 1 , 6 ) = 3868338505 1._RPP / 498960 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 6 ) = - 1473417899 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 6 ) = 341705736 7._RPP / 110880 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 6 ) = - 241688504 3._RPP / 399168 0._RPP !                    /                    ;                    / c ( 0 , 2 , 6 ) = 0._RPP ; c ( 1 , 2 , 6 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 6 ) = 19973092 1._RPP / 2772 0._RPP ; c ( 3 , 2 , 6 ) = - 2169300276 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 6 ) = 829077191 3._RPP / 44352 0._RPP ; c ( 5 , 2 , 6 ) = - 1930850567 9._RPP / 221760 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 6 ) = 857930974 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 6 ) = 0._RPP ; c ( 1 , 3 , 6 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 6 ) = 0._RPP ; c ( 3 , 3 , 6 ) = 4925685991 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 6 ) = - 2836489260 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 6 ) = 6644004937 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 6 ) = - 3964543964 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 6 ) = 0._RPP ; c ( 1 , 4 , 6 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 6 ) = 0._RPP ; c ( 3 , 4 , 6 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 6 ) = 136940474 9._RPP / 11088 0._RPP ; c ( 5 , 4 , 6 ) = - 862343162 3._RPP / 73920 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 6 ) = 4680858363 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 6 ) = 0._RPP ; c ( 1 , 5 , 6 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 6 ) = 0._RPP ; c ( 3 , 5 , 6 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 6 ) = 0._RPP ; c ( 5 , 5 , 6 ) = 618261273 1._RPP / 221760 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 6 ) = - 2276309235 7._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 6 ) = 0._RPP ; c ( 1 , 6 , 6 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 6 ) = 0._RPP ; c ( 3 , 6 , 6 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 6 ) = 0._RPP ; c ( 5 , 6 , 6 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 6 ) = 89720716 3._RPP / 748440 0._RPP case ( 8 ) ! 15th order ! stencil 0 !                    /                              ;                      / c ( 0 , 0 , 0 ) = 587078540679 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 0 ) = - 313071895443 1._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 2 , 0 , 0 ) = 3601963023845 3._RPP / 444787200 0._RPP ; c ( 3 , 0 , 0 ) = - 903077174440 9._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 0 ) = 702898716544 9._RPP / 69189120 0._RPP ; c ( 5 , 0 , 0 ) = - 526926040795 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 6 , 0 , 0 ) = 5052882299457 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 0 ) = - 81910049458 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 58179188140736 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 0 ) = - 18543240054934 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 0 ) = 42866891772828 1._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 0 ) = - 39330381673 9._RPP / 648648 0._RPP ; c ( 5 , 1 , 0 ) = 101073149489938 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 0 ) = - 1266152064402 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 0 ) = 3950906179212 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 0 ) = 127228075011819 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 0 ) = - 630647758453 9._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 4 , 2 , 0 ) = 98215049469830 9._RPP / 622702080 0._RPP ; c ( 5 , 2 , 0 ) = - 10992804980258 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 0 ) = 79532599772251 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 0 ) = - 647659119916 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 0 ) = 0._RPP ; c ( 3 , 3 , 0 ) = 589638297742 3._RPP / 4528742 4._RPP !                    /                              ;                      / c ( 4 , 3 , 0 ) = - 3599923347105 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 0 ) = 77576024915482 7._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 0 ) = - 488268892477 7._RPP / 12972960 0._RPP ; c ( 7 , 3 , 0 ) = 1019671679701 3._RPP / 207567360 0._RPP !                    /                              ;                      / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 0 ) = 0._RPP ; c ( 3 , 4 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 0 ) = 2331542417837 3._RPP / 22643712 0._RPP ; c ( 5 , 4 , 0 ) = - 98349292735 9._RPP / 884520 0._RPP !                    /                              ;                      / c ( 6 , 4 , 0 ) = 4191014000477 9._RPP / 124540416 0._RPP ; c ( 7 , 4 , 0 ) = - 342379815619 3._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 0 ) = 0._RPP ; c ( 3 , 5 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 62417743633026 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 0 ) = - 7094431059310 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 0 ) = 1061058110012 3._RPP / 444787200 0._RPP !                    /                              ;                      / c ( 0 , 6 , 0 ) = 0._RPP ; c ( 1 , 6 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 0 ) = 0._RPP ; c ( 3 , 6 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 0 ) = 0._RPP ; c ( 5 , 6 , 0 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 0 ) = 17222970865763 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 0 ) = - 141010670914 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 7 , 0 ) = 0._RPP ; c ( 1 , 7 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 0 ) = 0._RPP ; c ( 3 , 7 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 0 ) = 0._RPP ; c ( 5 , 7 , 0 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 0 ) = 0._RPP ; c ( 7 , 7 , 0 ) = 98600509638 7._RPP / 2075673600 0._RPP ! stencil 1 !                    /                              ;                      / c ( 0 , 0 , 1 ) = 98600509638 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 1 ) = - 106945739728 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 2 , 0 , 1 ) = 4331536630438 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 1 ) = - 155058492516 1._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 1 ) = 72147091048 1._RPP / 41513472 0._RPP ; c ( 5 , 0 , 1 ) = - 179355812158 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 6 , 0 , 1 ) = 122148005652 1._RPP / 444787200 0._RPP ; c ( 7 , 0 , 1 ) = - 13780187086 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 10208047141955 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 1 ) = - 3290342827366 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 1 ) = 7627351322914 3._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 1 ) = - 139757141290 1._RPP / 12972960 0._RPP ; c ( 5 , 1 , 1 ) = 17892284043259 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 1 ) = - 223086272634 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 1 ) = 692571107649 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 1 ) = 22945613591682 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 1 ) = - 1145007795 7._RPP / 35380 8._RPP !                    /                              ;                      / c ( 4 , 2 , 1 ) = 17855983504052 3._RPP / 622702080 0._RPP ; c ( 5 , 2 , 1 ) = - 1995270410234 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 1 ) = 14388785579794 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 1 ) = - 58348813105 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 1 ) = 0._RPP ; c ( 3 , 3 , 1 ) = 540773370278 9._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 1 ) = - 663047977677 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 1 ) = 14295096719597 3._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 1 ) = - 22456304186 9._RPP / 3243240 0._RPP ; c ( 7 , 3 , 1 ) = 4156675907 9._RPP / 4612608 0._RPP !                    /                              ;                      / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 1 ) = 0._RPP ; c ( 3 , 4 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 1 ) = 432253177133 9._RPP / 22643712 0._RPP ; c ( 5 , 4 , 1 ) = - 2924498549 5._RPP / 141523 2._RPP !                    /                              ;                      / c ( 6 , 4 , 1 ) = 3894108374479 3._RPP / 622702080 0._RPP ; c ( 7 , 4 , 1 ) = - 9074419282 3._RPP / 11119680 0._RPP !                    /                              ;                      / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 1 ) = 0._RPP ; c ( 3 , 5 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 11648728537227 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 1 ) = - 1325766894046 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 1 ) = 1387332828613 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 1 ) = 0._RPP ; c ( 1 , 6 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 1 ) = 0._RPP ; c ( 3 , 6 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 1 ) = 0._RPP ; c ( 5 , 6 , 1 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 1 ) = 3226850444480 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 1 ) = - 13217381913 1._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 0 , 7 , 1 ) = 0._RPP ; c ( 1 , 7 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 1 ) = 0._RPP ; c ( 3 , 7 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 1 ) = 0._RPP ; c ( 5 , 7 , 1 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 1 ) = 0._RPP ; c ( 7 , 7 , 1 ) = 2644617249 1._RPP / 296524800 0._RPP ! stencil 2 !                    /                              ;                      / c ( 0 , 0 , 2 ) = 2644617249 1._RPP / 296524800 0._RPP ; c ( 1 , 0 , 2 ) = - 10439193786 1._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 2 , 0 , 2 ) = 862463834821 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 2 ) = - 31072696639 3._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 2 ) = 72122074556 3._RPP / 207567360 0._RPP ; c ( 5 , 0 , 2 ) = - 2541216454 9._RPP / 13899600 0._RPP !                    /                              ;                      / c ( 6 , 0 , 2 ) = 167702113857 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 2 ) = - 2667434578 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 2086303164608 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 2 ) = - 690510075850 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 2 ) = 324051029606 9._RPP / 124540416 0._RPP !                    /                              ;                      / c ( 4 , 1 , 2 ) = - 3718793686 9._RPP / 1621620 0._RPP ; c ( 5 , 1 , 2 ) = 3791367900946 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 2 ) = - 46856166582 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 2 ) = 143819879052 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 2 ) = 4988347834251 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 2 ) = - 25386569121 1._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 4 , 2 , 2 ) = 3989610078547 7._RPP / 622702080 0._RPP ; c ( 5 , 2 , 2 ) = - 445676728598 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 2 ) = 3195952217083 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 2 ) = - 25687939228 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 2 ) = 0._RPP ; c ( 3 , 3 , 2 ) = 123194938772 3._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 2 ) = - 153209436465 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 2 ) = 3319172729165 9._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 2 ) = - 4164393066 1._RPP / 2594592 0._RPP ; c ( 7 , 3 , 2 ) = 43100007739 7._RPP / 207567360 0._RPP !                    /                              ;                      / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 2 ) = 0._RPP ; c ( 3 , 4 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 2 ) = 20391213427 3._RPP / 4528742 4._RPP ; c ( 5 , 4 , 2 ) = - 544514212 7._RPP / 110565 0._RPP !                    /                              ;                      / c ( 6 , 4 , 2 ) = 930691381743 1._RPP / 622702080 0._RPP ; c ( 7 , 4 , 2 ) = - 15144137020 9._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 2 ) = 0._RPP ; c ( 3 , 5 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 2819916191874 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 2 ) = - 323354911474 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 2 ) = 338853371302 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 2 ) = 0._RPP ; c ( 1 , 6 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 2 ) = 0._RPP ; c ( 3 , 6 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 2 ) = 0._RPP ; c ( 5 , 6 , 2 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 2 ) = 796525598531 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 2 ) = - 6561116818 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 7 , 2 ) = 0._RPP ; c ( 1 , 7 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 2 ) = 0._RPP ; c ( 3 , 7 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 2 ) = 0._RPP ; c ( 5 , 7 , 2 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 2 ) = 0._RPP ; c ( 7 , 7 , 2 ) = 4638829254 7._RPP / 2075673600 0._RPP ! stencil 3 !                    /                              ;                      / c ( 0 , 0 , 3 ) = 4638829254 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 3 ) = - 5624526592 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 2 , 0 , 3 ) = 245841778342 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 3 ) = - 1841581435 7._RPP / 15567552 0._RPP !                    /                              ;                      / c ( 4 , 0 , 3 ) = 7281200608 7._RPP / 69189120 0._RPP ; c ( 5 , 0 , 3 ) = - 10847364622 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 6 , 0 , 3 ) = 50808286092 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 3 ) = - 794254126 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 604760553059 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 3 ) = - 212910385282 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 3 ) = 522796688136 7._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 3 ) = - 9876569669 3._RPP / 12972960 0._RPP ; c ( 5 , 1 , 3 ) = 1275283098715 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 3 ) = - 15758059542 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 3 ) = 47818564929 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 3 ) = 1647638781570 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 3 ) = - 552771549 7._RPP / 221130 0._RPP !                    /                              ;                      / c ( 4 , 2 , 3 ) = 1441639394689 1._RPP / 622702080 0._RPP ; c ( 5 , 2 , 3 ) = - 164407916774 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 3 ) = 1187043298066 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 3 ) = - 4746934060 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 3 ) = 0._RPP ; c ( 3 , 3 , 3 ) = 45724952851 7._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 3 ) = - 59591572125 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 3 ) = 53207164366 1._RPP / 24908083 2._RPP !                    /                              ;                      / c ( 6 , 3 , 3 ) = - 1059014965 3._RPP / 1621620 0._RPP ; c ( 7 , 3 , 3 ) = 2511636615 7._RPP / 29652480 0._RPP !                    /                              ;                      / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 3 ) = 0._RPP ; c ( 3 , 4 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 3 ) = 42034116193 1._RPP / 22643712 0._RPP ; c ( 5 , 4 , 3 ) = - 7485146782 3._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 6 , 4 , 3 ) = 410088084328 9._RPP / 622702080 0._RPP ; c ( 7 , 4 , 3 ) = - 6751326537 7._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 3 ) = 0._RPP ; c ( 3 , 5 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 1278096745707 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 3 ) = - 152168848426 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 3 ) = 163158910789 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 3 ) = 0._RPP ; c ( 1 , 6 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 3 ) = 0._RPP ; c ( 3 , 6 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 3 ) = 0._RPP ; c ( 5 , 6 , 3 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 3 ) = 394486189760 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 3 ) = - 240737704 3._RPP / 13899600 0._RPP !                    /                              ;                      / c ( 0 , 7 , 3 ) = 0._RPP ; c ( 1 , 7 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 3 ) = 0._RPP ; c ( 3 , 7 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 3 ) = 0._RPP ; c ( 5 , 7 , 3 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 3 ) = 0._RPP ; c ( 7 , 7 , 3 ) = 2511636615 7._RPP / 2075673600 0._RPP ! stencil 4 !                    /                              ;                      / c ( 0 , 0 , 4 ) = 2511636615 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 4 ) = - 240737704 3._RPP / 13899600 0._RPP !                    /                              ;                      / c ( 2 , 0 , 4 ) = 163158910789 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 4 ) = - 6751326537 7._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 4 ) = 2511636615 7._RPP / 29652480 0._RPP ; c ( 5 , 0 , 4 ) = - 4746934060 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 6 , 0 , 4 ) = 47818564929 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 4 ) = - 794254126 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 394486189760 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 4 ) = - 152168848426 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 4 ) = 410088084328 9._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 4 ) = - 1059014965 3._RPP / 1621620 0._RPP ; c ( 5 , 1 , 4 ) = 1187043298066 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 4 ) = - 15758059542 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 4 ) = 50808286092 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 4 ) = 1278096745707 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 4 ) = - 7485146782 3._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 4 , 2 , 4 ) = 53207164366 1._RPP / 24908083 2._RPP ; c ( 5 , 2 , 4 ) = - 164407916774 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 4 ) = 1275283098715 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 4 ) = - 10847364622 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 4 ) = 0._RPP ; c ( 3 , 3 , 4 ) = 42034116193 1._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 4 ) = - 59591572125 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 4 ) = 1441639394689 1._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 4 ) = - 9876569669 3._RPP / 12972960 0._RPP ; c ( 7 , 3 , 4 ) = 7281200608 7._RPP / 69189120 0._RPP !                    /                              ;                      / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 4 ) = 0._RPP ; c ( 3 , 4 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 4 ) = 45724952851 7._RPP / 22643712 0._RPP ; c ( 5 , 4 , 4 ) = - 552771549 7._RPP / 221130 0._RPP !                    /                              ;                      / c ( 6 , 4 , 4 ) = 522796688136 7._RPP / 622702080 0._RPP ; c ( 7 , 4 , 4 ) = - 1841581435 7._RPP / 15567552 0._RPP !                    /                              ;                      / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 4 ) = 0._RPP ; c ( 3 , 5 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 1647638781570 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 4 ) = - 212910385282 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 4 ) = 245841778342 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 4 ) = 0._RPP ; c ( 1 , 6 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 4 ) = 0._RPP ; c ( 3 , 6 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 4 ) = 0._RPP ; c ( 5 , 6 , 4 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 4 ) = 604760553059 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 4 ) = - 5624526592 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 7 , 4 ) = 0._RPP ; c ( 1 , 7 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 4 ) = 0._RPP ; c ( 3 , 7 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 4 ) = 0._RPP ; c ( 5 , 7 , 4 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 4 ) = 0._RPP ; c ( 7 , 7 , 4 ) = 4638829254 7._RPP / 2075673600 0._RPP ! stencil 5 !                    /                              ;                     / c ( 0 , 0 , 5 ) = 4638829254 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 5 ) = - 6561116818 7._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 2 , 0 , 5 ) = 338853371302 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 5 ) = - 15144137020 9._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 4 , 0 , 5 ) = 43100007739 7._RPP / 207567360 0._RPP ; c ( 5 , 0 , 5 ) = - 25687939228 1._RPP / 194594400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 0 , 5 ) = 143819879052 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 5 ) = - 2667434578 7._RPP / 389188800 0._RPP !                    /                              ;                     / c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 796525598531 9._RPP / 6227020800 0._RPP !                    /                              ;                     / c ( 2 , 1 , 5 ) = - 323354911474 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 5 ) = 930691381743 1._RPP / 622702080 0._RPP !                    /                              ;                     / c ( 4 , 1 , 5 ) = - 4164393066 1._RPP / 2594592 0._RPP ; c ( 5 , 1 , 5 ) = 3195952217083 7._RPP / 3113510400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 1 , 5 ) = - 46856166582 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 5 ) = 167702113857 7._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 2 , 5 ) = 2819916191874 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 5 ) = - 544514212 7._RPP / 110565 0._RPP !                    /                              ;                     / c ( 4 , 2 , 5 ) = 3319172729165 9._RPP / 622702080 0._RPP ; c ( 5 , 2 , 5 ) = - 445676728598 9._RPP / 129729600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 2 , 5 ) = 3791367900946 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 5 ) = - 2541216454 9._RPP / 13899600 0._RPP !                    /                              ;                     / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 3 , 5 ) = 0._RPP ; c ( 3 , 3 , 5 ) = 20391213427 3._RPP / 4528742 4._RPP !                    /                              ;                     / c ( 4 , 3 , 5 ) = - 153209436465 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 5 ) = 3989610078547 7._RPP / 622702080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 3 , 5 ) = - 3718793686 9._RPP / 1621620 0._RPP ; c ( 7 , 3 , 5 ) = 72122074556 3._RPP / 207567360 0._RPP !                    /                              ;                     / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 4 , 5 ) = 0._RPP ; c ( 3 , 4 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 4 , 5 ) = 123194938772 3._RPP / 22643712 0._RPP ; c ( 5 , 4 , 5 ) = - 25386569121 1._RPP / 3538080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 4 , 5 ) = 324051029606 9._RPP / 124540416 0._RPP ; c ( 7 , 4 , 5 ) = - 31072696639 3._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 5 , 5 ) = 0._RPP ; c ( 3 , 5 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 4988347834251 7._RPP / 2075673600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 5 , 5 ) = - 690510075850 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 5 ) = 862463834821 1._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 6 , 5 ) = 0._RPP ; c ( 1 , 6 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 6 , 5 ) = 0._RPP ; c ( 3 , 6 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 6 , 5 ) = 0._RPP ; c ( 5 , 6 , 5 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 6 , 5 ) = 2086303164608 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 5 ) = - 10439193786 1._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 0 , 7 , 5 ) = 0._RPP ; c ( 1 , 7 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 7 , 5 ) = 0._RPP ; c ( 3 , 7 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 7 , 5 ) = 0._RPP ; c ( 5 , 7 , 5 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 7 , 5 ) = 0._RPP ; c ( 7 , 7 , 5 ) = 2644617249 1._RPP / 296524800 0._RPP ! stencil 6 !                    /                              ;                     / c ( 0 , 0 , 6 ) = 2644617249 1._RPP / 296524800 0._RPP ; c ( 1 , 0 , 6 ) = - 13217381913 1._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 2 , 0 , 6 ) = 1387332828613 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 6 ) = - 9074419282 3._RPP / 11119680 0._RPP !                    /                              ;                     / c ( 4 , 0 , 6 ) = 4156675907 9._RPP / 4612608 0._RPP ; c ( 5 , 0 , 6 ) = - 58348813105 3._RPP / 97297200 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 0 , 6 ) = 692571107649 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 6 ) = - 13780187086 7._RPP / 389188800 0._RPP !                    /                              ;                     / c ( 0 , 1 , 6 ) = 0._RPP ; c ( 1 , 1 , 6 ) = 3226850444480 9._RPP / 6227020800 0._RPP !                    /                              ;                     / c ( 2 , 1 , 6 ) = - 1325766894046 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 6 ) = 3894108374479 3._RPP / 622702080 0._RPP !                    /                              ;                     / c ( 4 , 1 , 6 ) = - 22456304186 9._RPP / 3243240 0._RPP ; c ( 5 , 1 , 6 ) = 14388785579794 7._RPP / 3113510400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 1 , 6 ) = - 223086272634 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 6 ) = 122148005652 1._RPP / 444787200 0._RPP !                    /                              ;                     / c ( 0 , 2 , 6 ) = 0._RPP ; c ( 1 , 2 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 2 , 6 ) = 11648728537227 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 6 ) = - 2924498549 5._RPP / 141523 2._RPP !                    /                              ;                     / c ( 4 , 2 , 6 ) = 14295096719597 3._RPP / 622702080 0._RPP ; c ( 5 , 2 , 6 ) = - 1995270410234 9._RPP / 129729600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 2 , 6 ) = 17892284043259 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 6 ) = - 179355812158 1._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 0 , 3 , 6 ) = 0._RPP ; c ( 1 , 3 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 3 , 6 ) = 0._RPP ; c ( 3 , 3 , 6 ) = 432253177133 9._RPP / 22643712 0._RPP !                    /                              ;                     / c ( 4 , 3 , 6 ) = - 663047977677 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 6 ) = 17855983504052 3._RPP / 622702080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 3 , 6 ) = - 139757141290 1._RPP / 12972960 0._RPP ; c ( 7 , 3 , 6 ) = 72147091048 1._RPP / 41513472 0._RPP !                    /                              ;                     / c ( 0 , 4 , 6 ) = 0._RPP ; c ( 1 , 4 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 4 , 6 ) = 0._RPP ; c ( 3 , 4 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 4 , 6 ) = 540773370278 9._RPP / 22643712 0._RPP ; c ( 5 , 4 , 6 ) = - 1145007795 7._RPP / 35380 8._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 4 , 6 ) = 7627351322914 3._RPP / 622702080 0._RPP ; c ( 7 , 4 , 6 ) = - 155058492516 1._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 0 , 5 , 6 ) = 0._RPP ; c ( 1 , 5 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 5 , 6 ) = 0._RPP ; c ( 3 , 5 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 5 , 6 ) = 0._RPP ; c ( 5 , 5 , 6 ) = 22945613591682 7._RPP / 2075673600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 5 , 6 ) = - 3290342827366 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 6 ) = 4331536630438 1._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 6 , 6 ) = 0._RPP ; c ( 1 , 6 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 6 , 6 ) = 0._RPP ; c ( 3 , 6 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 6 , 6 ) = 0._RPP ; c ( 5 , 6 , 6 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 6 , 6 ) = 10208047141955 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 6 ) = - 106945739728 7._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 0 , 7 , 6 ) = 0._RPP ; c ( 1 , 7 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 7 , 6 ) = 0._RPP ; c ( 3 , 7 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 7 , 6 ) = 0._RPP ; c ( 5 , 7 , 6 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 7 , 6 ) = 0._RPP ; c ( 7 , 7 , 6 ) = 98600509638 7._RPP / 2075673600 0._RPP ! stencil 7 !                    /                              ;                     / c ( 0 , 0 , 7 ) = 98600509638 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 7 ) = - 141010670914 7._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 2 , 0 , 7 ) = 1061058110012 3._RPP / 444787200 0._RPP ; c ( 3 , 0 , 7 ) = - 342379815619 3._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 4 , 0 , 7 ) = 1019671679701 3._RPP / 207567360 0._RPP ; c ( 5 , 0 , 7 ) = - 647659119916 1._RPP / 194594400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 0 , 7 ) = 3950906179212 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 7 ) = - 81910049458 7._RPP / 389188800 0._RPP !                    /                              ;                     / c ( 0 , 1 , 7 ) = 0._RPP ; c ( 1 , 1 , 7 ) = 17222970865763 9._RPP / 6227020800 0._RPP !                    /                              ;                     / c ( 2 , 1 , 7 ) = - 7094431059310 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 7 ) = 4191014000477 9._RPP / 124540416 0._RPP !                    /                              ;                     / c ( 4 , 1 , 7 ) = - 488268892477 7._RPP / 12972960 0._RPP ; c ( 5 , 1 , 7 ) = 79532599772251 7._RPP / 3113510400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 1 , 7 ) = - 1266152064402 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 7 ) = 5052882299457 7._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 2 , 7 ) = 0._RPP ; c ( 1 , 2 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 2 , 7 ) = 62417743633026 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 7 ) = - 98349292735 9._RPP / 884520 0._RPP !                    /                              ;                     / c ( 4 , 2 , 7 ) = 77576024915482 7._RPP / 622702080 0._RPP ; c ( 5 , 2 , 7 ) = - 10992804980258 9._RPP / 129729600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 2 , 7 ) = 101073149489938 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 7 ) = - 526926040795 3._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 0 , 3 , 7 ) = 0._RPP ; c ( 1 , 3 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 3 , 7 ) = 0._RPP ; c ( 3 , 3 , 7 ) = 2331542417837 3._RPP / 22643712 0._RPP !                    /                              ;                     / c ( 4 , 3 , 7 ) = - 3599923347105 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 7 ) = 98215049469830 9._RPP / 622702080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 3 , 7 ) = - 39330381673 9._RPP / 648648 0._RPP ; c ( 7 , 3 , 7 ) = 702898716544 9._RPP / 69189120 0._RPP !                    /                              ;                     / c ( 0 , 4 , 7 ) = 0._RPP ; c ( 1 , 4 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 4 , 7 ) = 0._RPP ; c ( 3 , 4 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 4 , 7 ) = 589638297742 3._RPP / 4528742 4._RPP ; c ( 5 , 4 , 7 ) = - 630647758453 9._RPP / 3538080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 4 , 7 ) = 42866891772828 1._RPP / 622702080 0._RPP ; c ( 7 , 4 , 7 ) = - 903077174440 9._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 0 , 5 , 7 ) = 0._RPP ; c ( 1 , 5 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 5 , 7 ) = 0._RPP ; c ( 3 , 5 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 5 , 7 ) = 0._RPP ; c ( 5 , 5 , 7 ) = 127228075011819 7._RPP / 2075673600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 5 , 7 ) = - 18543240054934 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 7 ) = 3601963023845 3._RPP / 444787200 0._RPP !                    /                              ;                     / c ( 0 , 6 , 7 ) = 0._RPP ; c ( 1 , 6 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 6 , 7 ) = 0._RPP ; c ( 3 , 6 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 6 , 7 ) = 0._RPP ; c ( 5 , 6 , 7 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 6 , 7 ) = 58179188140736 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 7 ) = - 313071895443 1._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 0 , 7 , 7 ) = 0._RPP ; c ( 1 , 7 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 7 , 7 ) = 0._RPP ; c ( 3 , 7 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 7 , 7 ) = 0._RPP ; c ( 5 , 7 , 7 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 7 , 7 ) = 0._RPP ; c ( 7 , 7 , 7 ) = 587078540679 7._RPP / 2075673600 0._RPP case ( 9 ) ! 17th order ! stencil 0 !                    /                               ;                     / c ( 0 , 0 , 0 ) = 10947113933269 9._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 0 ) = - 89462836442080 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 0 ) = 3470956782876598 9._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 0 ) = - 1208363205553750 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 4 , 0 , 0 ) = 53423709511790 3._RPP / 1046139494 4._RPP ; c ( 5 , 0 , 0 ) = - 4784134214198129 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 0 ) = 2164462807751548 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 0 ) = - 564439940024630 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 0 ) = 12973990640860 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 560275323330565 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 2 , 1 , 0 ) = - 5911141295073430 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 0 ) = 20717808425886056 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 0 ) = - 4602038409035702 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 0 ) = 16544517891672647 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 0 ) = - 3753103645304716 1._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 0 ) = 13718972102530 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 0 ) = - 451752457452509 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 0 ) = 466071217217893 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 0 ) = - 4514872822425481 7._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 0 ) = 22878692017843 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 0 ) = - 3629458001216861 3._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 0 ) = 3300852708223699 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 0 ) = - 3025005282549752 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 0 ) = 1395244392999561 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 0 ) = 0._RPP ; c ( 3 , 3 , 0 ) = 15964677371155834 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 0 ) = - 714007473389985 1._RPP / 373621248 0._RPP ; c ( 5 , 3 , 0 ) = 2580251345869183 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 0 ) = - 2938718777174794 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 0 ) = 10788739048624814 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 0 ) = - 2491175852975000 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 0 ) = 0._RPP ; c ( 3 , 4 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 0 ) = 800187970376734 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 0 ) = - 579411902443348 3._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 0 ) = 15020534732683 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 0 ) = - 2429347143458870 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 0 ) = 112305878501505 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 0 ) = 0._RPP ; c ( 3 , 5 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 10504573010955745 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 0 ) = - 2399374389255760 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 0 ) = 8828714974335541 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 0 ) = - 81699003745448 3._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 6 , 0 ) = 0._RPP ; c ( 1 , 6 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 0 ) = 0._RPP ; c ( 3 , 6 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 0 ) = 0._RPP ; c ( 5 , 6 , 0 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 0 ) = 199495274192793 1._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 0 ) = - 2020412537734006 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 0 ) = 935506490307805 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 0 ) = 0._RPP ; c ( 1 , 7 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 0 ) = 0._RPP ; c ( 3 , 7 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 0 ) = 0._RPP ; c ( 5 , 7 , 0 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 0 ) = 0._RPP ; c ( 7 , 7 , 0 ) = 1063735481545661 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 0 ) = - 18955567275961 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 0 ) = 0._RPP ; c ( 1 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 0 ) = 0._RPP ; c ( 3 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 0 ) = 0._RPP ; c ( 5 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 0 ) = 0._RPP ; c ( 7 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 0 ) = 1784873725120 3._RPP / 16345929600 0._RPP ! stencil 1 !                    /                               ;                     / c ( 0 , 0 , 1 ) = 1784873725120 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 1 ) = - 14780912554847 9._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 1 ) = 115266961643356 7._RPP / 26153487360 0._RPP ; c ( 3 , 0 , 1 ) = - 1003625893562122 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 1 ) = 221425915373504 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 1 ) = - 790658467304897 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 1 ) = 356395192925475 7._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 1 ) = - 740646202891 9._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 8 , 0 , 1 ) = 10599441829821 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 660345506505409 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 1 ) = - 1003677958085818 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 1 ) = 3527256877887227 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 1 ) = - 783236811583460 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 1 ) = 2810137895488000 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 1 ) = - 635653720341542 3._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 1 ) = 2315984163112 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 1 ) = - 76005337654316 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 1 ) = 80057267234686 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 1 ) = - 779567532947119 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 1 ) = 3956407788958 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 1 ) = - 125451994816551 1._RPP / 934053120 0._RPP !                    /                               ;                     / c ( 6 , 2 , 1 ) = 569432593046545 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 1 ) = - 520558506485519 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 1 ) = 239433810124813 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 1 ) = 0._RPP ; c ( 3 , 3 , 1 ) = 2777072392772198 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 1 ) = - 623064713812012 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 1 ) = 2253375754684385 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 1 ) = - 512910400994605 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 1 ) = 1879962448756268 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 1 ) = - 433174706907934 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 1 ) = 0._RPP ; c ( 3 , 4 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 1 ) = 140330435447542 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 1 ) = - 509106072743740 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 1 ) = 2640359881420 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 1 ) = - 426697274934164 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 1 ) = 98485018206416 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 1 ) = 0._RPP ; c ( 3 , 5 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 1851802802323795 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 1 ) = - 423486261093611 9._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 1 ) = 311638099752196 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 5 , 1 ) = - 360178442307514 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 1 ) = 0._RPP ; c ( 1 , 6 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 1 ) = 0._RPP ; c ( 3 , 6 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 1 ) = 0._RPP ; c ( 5 , 6 , 1 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 1 ) = 35281236971941 3._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 1 ) = - 357541164655690 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 1 ) = 165507219650188 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 1 ) = 0._RPP ; c ( 1 , 7 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 1 ) = 0._RPP ; c ( 3 , 7 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 1 ) = 0._RPP ; c ( 5 , 7 , 1 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 1 ) = 0._RPP ; c ( 7 , 7 , 1 ) = 26924749115906 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 8 , 7 , 1 ) = - 3359357233795 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 1 ) = 0._RPP ; c ( 1 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 1 ) = 0._RPP ; c ( 3 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 1 ) = 0._RPP ; c ( 5 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 1 ) = 0._RPP ; c ( 7 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 1 ) = 316535517012 1._RPP / 16345929600 0._RPP ! stencil 2 !                    /                               ;                     / c ( 0 , 0 , 2 ) = 316535517012 1._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 2 ) = - 384413984834 3._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 2 , 0 , 2 ) = 106319120144653 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 2 ) = - 185989924739449 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 2 ) = 40992179077691 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 2 ) = - 145710511264309 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 2 ) = 65245292556748 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 2 ) = - 16817238148781 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 2 ) = 1909470410406 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 123999028356413 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 2 ) = - 191861009660335 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 2 ) = 135989101716685 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 4 , 1 , 2 ) = - 151274428150079 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 2 ) = 541497253844423 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 2 ) = - 121878246652664 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 2 ) = 441155351017 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 2 ) = - 574841303470 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 2 ) = 15662254432876 3._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 2 ) = - 154496455714316 9._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 2 ) = 788382052810 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 2 ) = - 125045499175210 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 2 ) = 113189854289740 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 2 ) = - 102960824791727 3._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 2 ) = 47064366535890 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 2 ) = 0._RPP ; c ( 3 , 3 , 2 ) = 559966627269370 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 2 ) = - 126799229420335 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 2 ) = 460178203604450 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 2 ) = - 20938884275712 1._RPP / 934053120 0._RPP ; c ( 7 , 3 , 2 ) = 382543571327995 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 2 ) = - 87725249292872 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 2 ) = 0._RPP ; c ( 3 , 4 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 2 ) = 28925923563877 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 2 ) = - 105629161653487 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 2 ) = 548943514198 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 2 ) = - 88617378590975 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 2 ) = 20389161410459 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 2 ) = 0._RPP ; c ( 3 , 5 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 387829668278573 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 2 ) = - 89093725268464 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 2 ) = 328142799572072 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 2 ) = - 75740201764057 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 2 ) = 0._RPP ; c ( 1 , 6 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 2 ) = 0._RPP ; c ( 3 , 6 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 2 ) = 0._RPP ; c ( 5 , 6 , 2 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 2 ) = 7473082165381 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 2 ) = - 75959848012063 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 2 ) = 7034106245689 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 7 , 2 ) = 0._RPP ; c ( 1 , 7 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 2 ) = 0._RPP ; c ( 3 , 7 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 2 ) = 0._RPP ; c ( 5 , 7 , 2 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 2 ) = 0._RPP ; c ( 7 , 7 , 2 ) = 40235579814154 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 2 ) = - 102644137864 7._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 0 , 8 , 2 ) = 0._RPP ; c ( 1 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 2 ) = 0._RPP ; c ( 3 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 2 ) = 0._RPP ; c ( 5 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 2 ) = 0._RPP ; c ( 7 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 2 ) = 67932810145 3._RPP / 16345929600 0._RPP ! stencil 3 !                    /                               ;                     / c ( 0 , 0 , 3 ) = 67932810145 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 3 ) = - 605604173116 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 3 ) = 24758266056940 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 3 ) = - 1769493211975 7._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 4 , 0 , 3 ) = 1969091838402 1._RPP / 5230697472 0._RPP ; c ( 5 , 0 , 3 ) = - 35006738200625 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 3 ) = 15561495071226 1._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 3 ) = - 3958767415244 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 3 ) = 88341623047 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 29367511416596 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 3 ) = - 47266283089441 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 3 ) = 172029789182536 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 3 ) = - 38844231666875 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 3 ) = 139714133741459 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 3 ) = - 31342113107807 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 3 ) = 112354071745 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 3 ) = - 3607377492245 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 3 ) = 4038561439218 1._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 3 ) = - 41172185433295 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 3 ) = 214500578863 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 3 ) = - 34365598242589 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 3 ) = 31145828068984 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 3 ) = - 28167860109091 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 3 ) = 12732629258653 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 3 ) = 0._RPP ; c ( 3 , 3 , 3 ) = 155322581342650 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 3 ) = - 7231095534637 3._RPP / 373621248 0._RPP ; c ( 5 , 3 , 3 ) = 26669846723506 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 3 ) = - 30536884781216 3._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 3 ) = 111438613822412 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 3 ) = - 25367482023674 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 3 ) = 0._RPP ; c ( 3 , 4 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 3 ) = 8539401890959 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 3 ) = - 6381181890858 1._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 3 ) = 167909462473 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 3 ) = - 27213951837707 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 3 ) = 249720972318 5._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 3 ) = 0._RPP ; c ( 3 , 5 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 120696469431859 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 3 ) = - 28262210797336 7._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 3 ) = 105123843951611 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 3 ) = - 4863348991747 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 6 , 3 ) = 0._RPP ; c ( 1 , 6 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 3 ) = 0._RPP ; c ( 3 , 6 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 3 ) = 0._RPP ; c ( 5 , 6 , 3 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 3 ) = 2432493465598 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 3 ) = - 25128376722865 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 3 ) = 11727264947413 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 3 ) = 0._RPP ; c ( 1 , 7 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 3 ) = 0._RPP ; c ( 3 , 7 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 3 ) = 0._RPP ; c ( 5 , 7 , 3 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 3 ) = 0._RPP ; c ( 7 , 7 , 3 ) = 13615578096730 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 3 ) = - 246623318515 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 3 ) = 0._RPP ; c ( 1 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 3 ) = 0._RPP ; c ( 3 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 3 ) = 0._RPP ; c ( 5 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 3 ) = 0._RPP ; c ( 7 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 3 ) = 23811484639 9._RPP / 16345929600 0._RPP ! stencil 4 !                    /                               ;                     / c ( 0 , 0 , 4 ) = 23811484639 9._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 4 ) = - 229780436377 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 4 ) = 2021607532067 3._RPP / 26153487360 0._RPP ; c ( 3 , 0 , 4 ) = - 19270006097372 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 4 ) = 4527294202072 7._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 4 ) = - 16788831494225 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 4 ) = 7685890397289 1._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 4 ) = - 397630041033 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 8 , 0 , 4 ) = 222750647449 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 11997931490698 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 4 ) = - 20735925261266 9._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 4 ) = 16108483925350 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 4 , 1 , 4 ) = - 19231034687299 1._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 4 ) = 72335778444206 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 4 ) = - 16769067524111 3._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 4 ) = 61375366326 1._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 4 ) = - 397630041033 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 4 ) = 1901031096652 3._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 4 ) = - 20705915804089 7._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 4 ) = 114357625116 1._RPP / 21228480 0._RPP ; c ( 5 , 2 , 4 ) = - 3845076331699 3._RPP / 934053120 0._RPP !                    /                               ;                     / c ( 6 , 2 , 4 ) = 18078615174047 9._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 4 ) = - 16769067524111 3._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 4 ) = 7685890397289 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 4 ) = 0._RPP ; c ( 3 , 3 , 4 ) = 83648436863713 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 4 ) = - 20713906720178 3._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 4 ) = 80519580337327 7._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 4 ) = - 3845076331699 3._RPP / 934053120 0._RPP ; c ( 7 , 3 , 4 ) = 72335778444206 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 4 ) = - 16788831494225 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 4 ) = 0._RPP ; c ( 3 , 4 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 4 ) = 5229739288913 9._RPP / 747242496 0._RPP ; c ( 5 , 4 , 4 ) = - 20713906720178 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 4 ) = 114357625116 1._RPP / 21228480 0._RPP ; c ( 7 , 4 , 4 ) = - 19231034687299 1._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 4 ) = 4527294202072 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 4 ) = 0._RPP ; c ( 3 , 5 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 83648436863713 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 4 ) = - 20705915804089 7._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 4 ) = 16108483925350 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 5 , 4 ) = - 19270006097372 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 4 ) = 0._RPP ; c ( 1 , 6 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 4 ) = 0._RPP ; c ( 3 , 6 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 4 ) = 0._RPP ; c ( 5 , 6 , 4 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 4 ) = 1901031096652 3._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 4 ) = - 20735925261266 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 4 ) = 2021607532067 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 7 , 4 ) = 0._RPP ; c ( 1 , 7 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 4 ) = 0._RPP ; c ( 3 , 7 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 4 ) = 0._RPP ; c ( 5 , 7 , 4 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 4 ) = 0._RPP ; c ( 7 , 7 , 4 ) = 11997931490698 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 4 ) = - 229780436377 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 4 ) = 0._RPP ; c ( 1 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 4 ) = 0._RPP ; c ( 3 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 4 ) = 0._RPP ; c ( 5 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 4 ) = 0._RPP ; c ( 7 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 4 ) = 23811484639 9._RPP / 16345929600 0._RPP ! stencil 5 !                    /                               ;                     / c ( 0 , 0 , 5 ) = 23811484639 9._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 5 ) = - 246623318515 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 5 ) = 11727264947413 9._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 5 ) = - 4863348991747 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 4 , 0 , 5 ) = 249720972318 5._RPP / 1046139494 4._RPP ; c ( 5 , 0 , 5 ) = - 25367482023674 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 5 ) = 12732629258653 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 5 ) = - 3607377492245 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 5 ) = 88341623047 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 13615578096730 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 5 ) = - 25128376722865 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 5 ) = 105123843951611 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 5 ) = - 27213951837707 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 5 ) = 111438613822412 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 5 ) = - 28167860109091 1._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 5 ) = 112354071745 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 5 ) = - 3958767415244 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 5 ) = 2432493465598 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 5 ) = - 28262210797336 7._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 5 ) = 167909462473 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 5 ) = - 30536884781216 3._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 5 ) = 31145828068984 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 5 ) = - 31342113107807 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 5 ) = 15561495071226 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 5 ) = 0._RPP ; c ( 3 , 3 , 5 ) = 120696469431859 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 5 ) = - 6381181890858 1._RPP / 373621248 0._RPP ; c ( 5 , 3 , 5 ) = 26669846723506 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 5 ) = - 34365598242589 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 5 ) = 139714133741459 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 5 ) = - 35006738200625 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 5 ) = 0._RPP ; c ( 3 , 4 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 5 ) = 8539401890959 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 5 ) = - 7231095534637 3._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 5 ) = 214500578863 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 5 ) = - 38844231666875 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 5 ) = 1969091838402 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 5 ) = 0._RPP ; c ( 3 , 5 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 155322581342650 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 5 ) = - 41172185433295 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 5 ) = 172029789182536 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 5 ) = - 1769493211975 7._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 6 , 5 ) = 0._RPP ; c ( 1 , 6 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 5 ) = 0._RPP ; c ( 3 , 6 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 5 ) = 0._RPP ; c ( 5 , 6 , 5 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 5 ) = 4038561439218 1._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 5 ) = - 47266283089441 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 5 ) = 24758266056940 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 5 ) = 0._RPP ; c ( 1 , 7 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 5 ) = 0._RPP ; c ( 3 , 7 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 5 ) = 0._RPP ; c ( 5 , 7 , 5 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 5 ) = 0._RPP ; c ( 7 , 7 , 5 ) = 29367511416596 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 5 ) = - 605604173116 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 5 ) = 0._RPP ; c ( 1 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 5 ) = 0._RPP ; c ( 3 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 5 ) = 0._RPP ; c ( 5 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 5 ) = 0._RPP ; c ( 7 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 5 ) = 67932810145 3._RPP / 16345929600 0._RPP ! stencil 6 !                    /                               ;                     / c ( 0 , 0 , 6 ) = 67932810145 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 6 ) = - 102644137864 7._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 2 , 0 , 6 ) = 7034106245689 7._RPP / 26153487360 0._RPP ; c ( 3 , 0 , 6 ) = - 75740201764057 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 6 ) = 20389161410459 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 6 ) = - 87725249292872 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 6 ) = 47064366535890 7._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 6 ) = - 574841303470 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 8 , 0 , 6 ) = 1909470410406 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 6 ) = 0._RPP ; c ( 1 , 1 , 6 ) = 40235579814154 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 6 ) = - 75959848012063 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 6 ) = 328142799572072 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 6 ) = - 88617378590975 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 6 ) = 382543571327995 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 6 ) = - 102960824791727 3._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 6 ) = 441155351017 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 6 ) = - 16817238148781 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 6 ) = 0._RPP ; c ( 1 , 2 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 6 ) = 7473082165381 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 6 ) = - 89093725268464 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 6 ) = 548943514198 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 6 ) = - 20938884275712 1._RPP / 934053120 0._RPP !                    /                               ;                     / c ( 6 , 2 , 6 ) = 113189854289740 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 6 ) = - 121878246652664 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 6 ) = 65245292556748 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 6 ) = 0._RPP ; c ( 1 , 3 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 6 ) = 0._RPP ; c ( 3 , 3 , 6 ) = 387829668278573 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 6 ) = - 105629161653487 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 6 ) = 460178203604450 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 6 ) = - 125045499175210 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 6 ) = 541497253844423 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 6 ) = - 145710511264309 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 6 ) = 0._RPP ; c ( 1 , 4 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 6 ) = 0._RPP ; c ( 3 , 4 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 6 ) = 28925923563877 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 6 ) = - 126799229420335 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 6 ) = 788382052810 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 6 ) = - 151274428150079 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 6 ) = 40992179077691 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 6 ) = 0._RPP ; c ( 1 , 5 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 6 ) = 0._RPP ; c ( 3 , 5 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 6 ) = 0._RPP ; c ( 5 , 5 , 6 ) = 559966627269370 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 6 ) = - 154496455714316 9._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 6 ) = 135989101716685 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 5 , 6 ) = - 185989924739449 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 6 ) = 0._RPP ; c ( 1 , 6 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 6 ) = 0._RPP ; c ( 3 , 6 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 6 ) = 0._RPP ; c ( 5 , 6 , 6 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 6 ) = 15662254432876 3._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 6 ) = - 191861009660335 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 6 ) = 106319120144653 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 6 ) = 0._RPP ; c ( 1 , 7 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 6 ) = 0._RPP ; c ( 3 , 7 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 6 ) = 0._RPP ; c ( 5 , 7 , 6 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 6 ) = 0._RPP ; c ( 7 , 7 , 6 ) = 123999028356413 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 6 ) = - 384413984834 3._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 0 , 8 , 6 ) = 0._RPP ; c ( 1 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 6 ) = 0._RPP ; c ( 3 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 6 ) = 0._RPP ; c ( 5 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 6 ) = 0._RPP ; c ( 7 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 6 ) = 316535517012 1._RPP / 16345929600 0._RPP ! stencil 7 !                    /                               ;                     / c ( 0 , 0 , 7 ) = 316535517012 1._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 7 ) = - 3359357233795 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 7 ) = 165507219650188 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 7 ) = - 360178442307514 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 7 ) = 98485018206416 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 7 ) = - 433174706907934 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 7 ) = 239433810124813 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 7 ) = - 76005337654316 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 7 ) = 10599441829821 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 7 ) = 0._RPP ; c ( 1 , 1 , 7 ) = 26924749115906 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 2 , 1 , 7 ) = - 357541164655690 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 7 ) = 311638099752196 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 4 , 1 , 7 ) = - 426697274934164 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 7 ) = 1879962448756268 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 7 ) = - 520558506485519 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 7 ) = 2315984163112 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 7 ) = - 740646202891 9._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 0 , 2 , 7 ) = 0._RPP ; c ( 1 , 2 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 7 ) = 35281236971941 3._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 7 ) = - 423486261093611 9._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 7 ) = 2640359881420 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 7 ) = - 512910400994605 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 7 ) = 569432593046545 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 7 ) = - 635653720341542 3._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 7 ) = 356395192925475 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 7 ) = 0._RPP ; c ( 1 , 3 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 7 ) = 0._RPP ; c ( 3 , 3 , 7 ) = 1851802802323795 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 7 ) = - 509106072743740 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 7 ) = 2253375754684385 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 7 ) = - 125451994816551 1._RPP / 934053120 0._RPP ; c ( 7 , 3 , 7 ) = 2810137895488000 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 7 ) = - 790658467304897 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 7 ) = 0._RPP ; c ( 1 , 4 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 7 ) = 0._RPP ; c ( 3 , 4 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 7 ) = 140330435447542 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 7 ) = - 623064713812012 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 7 ) = 3956407788958 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 7 ) = - 783236811583460 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 7 ) = 221425915373504 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 7 ) = 0._RPP ; c ( 1 , 5 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 7 ) = 0._RPP ; c ( 3 , 5 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 7 ) = 0._RPP ; c ( 5 , 5 , 7 ) = 2777072392772198 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 7 ) = - 779567532947119 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 7 ) = 3527256877887227 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 7 ) = - 1003625893562122 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 7 ) = 0._RPP ; c ( 1 , 6 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 7 ) = 0._RPP ; c ( 3 , 6 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 7 ) = 0._RPP ; c ( 5 , 6 , 7 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 7 ) = 80057267234686 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 7 ) = - 1003677958085818 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 7 ) = 115266961643356 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 7 , 7 ) = 0._RPP ; c ( 1 , 7 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 7 ) = 0._RPP ; c ( 3 , 7 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 7 ) = 0._RPP ; c ( 5 , 7 , 7 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 7 ) = 0._RPP ; c ( 7 , 7 , 7 ) = 660345506505409 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 7 ) = - 14780912554847 9._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 7 ) = 0._RPP ; c ( 1 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 7 ) = 0._RPP ; c ( 3 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 7 ) = 0._RPP ; c ( 5 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 7 ) = 0._RPP ; c ( 7 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 7 ) = 1784873725120 3._RPP / 16345929600 0._RPP ! stencil 8 !                    /                               ;                     / c ( 0 , 0 , 8 ) = 1784873725120 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 8 ) = - 18955567275961 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 8 ) = 935506490307805 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 8 ) = - 81699003745448 3._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 4 , 0 , 8 ) = 112305878501505 1._RPP / 5230697472 0._RPP ; c ( 5 , 0 , 8 ) = - 2491175852975000 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 8 ) = 1395244392999561 1._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 8 ) = - 451752457452509 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 8 ) = 12973990640860 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 8 ) = 0._RPP ; c ( 1 , 1 , 8 ) = 1063735481545661 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 8 ) = - 2020412537734006 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 8 ) = 8828714974335541 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 8 ) = - 2429347143458870 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 8 ) = 10788739048624814 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 8 ) = - 3025005282549752 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 8 ) = 13718972102530 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 8 ) = - 564439940024630 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 8 ) = 0._RPP ; c ( 1 , 2 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 8 ) = 199495274192793 1._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 8 ) = - 2399374389255760 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 8 ) = 15020534732683 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 8 ) = - 2938718777174794 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 8 ) = 3300852708223699 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 8 ) = - 3753103645304716 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 8 ) = 2164462807751548 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 8 ) = 0._RPP ; c ( 1 , 3 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 8 ) = 0._RPP ; c ( 3 , 3 , 8 ) = 10504573010955745 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 8 ) = - 579411902443348 3._RPP / 373621248 0._RPP ; c ( 5 , 3 , 8 ) = 2580251345869183 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 8 ) = - 3629458001216861 3._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 8 ) = 16544517891672647 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 8 ) = - 4784134214198129 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 8 ) = 0._RPP ; c ( 1 , 4 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 8 ) = 0._RPP ; c ( 3 , 4 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 8 ) = 800187970376734 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 8 ) = - 714007473389985 1._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 8 ) = 22878692017843 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 8 ) = - 4602038409035702 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 8 ) = 53423709511790 3._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 0 , 5 , 8 ) = 0._RPP ; c ( 1 , 5 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 8 ) = 0._RPP ; c ( 3 , 5 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 8 ) = 0._RPP ; c ( 5 , 5 , 8 ) = 15964677371155834 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 8 ) = - 4514872822425481 7._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 8 ) = 20717808425886056 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 8 ) = - 1208363205553750 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 6 , 8 ) = 0._RPP ; c ( 1 , 6 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 8 ) = 0._RPP ; c ( 3 , 6 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 8 ) = 0._RPP ; c ( 5 , 6 , 8 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 8 ) = 466071217217893 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 8 ) = - 5911141295073430 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 8 ) = 3470956782876598 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 8 ) = 0._RPP ; c ( 1 , 7 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 8 ) = 0._RPP ; c ( 3 , 7 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 8 ) = 0._RPP ; c ( 5 , 7 , 8 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 8 ) = 0._RPP ; c ( 7 , 7 , 8 ) = 560275323330565 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 8 , 7 , 8 ) = - 89462836442080 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 8 ) = 0._RPP ; c ( 1 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 8 ) = 0._RPP ; c ( 3 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 8 ) = 0._RPP ; c ( 5 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 8 ) = 0._RPP ; c ( 7 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 8 ) = 10947113933269 9._RPP / 16345929600 0._RPP endselect endassociate endsubroutine create pure subroutine compute ( self , stencil ) !< Compute beta. class ( beta_rec_js ), intent ( inout ) :: self !< Beta. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. integer ( I_P ) :: s1 , s2 , s3 , f !< Counters. do s1 = 0 , self % S - 1 ! stencils loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = 0._RPP do s2 = 0 , self % S - 1 do s3 = 0 , self % S - 1 self % values ( f , s1 ) = self % values ( f , s1 ) + & self % coef ( s3 , s2 , s1 ) * stencil ( f + self % ff , s1 - s3 ) * stencil ( f + self % ff , s1 - s2 ) enddo enddo enddo enddo endsubroutine compute pure function description ( self ) result ( string ) !< Return beta string-description. class ( beta_rec_js ), intent ( in ) :: self !< Beta. character ( len = :), allocatable :: string !< String-description. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'beta_rec_js%description to be implemented, do not use!' #endif endfunction description elemental subroutine destroy ( self ) !< Destroy beta. class ( beta_rec_js ), intent ( inout ) :: self !< Beta. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % coef )) deallocate ( self % coef ) endsubroutine destroy endmodule wenoof_beta_rec_js","tags":"","loc":"sourcefile/wenoof_beta_rec_js.f90.html","title":"wenoof_beta_rec_js.F90 – FORESEER"},{"text":"Jiang-Shu (upwind) reconstructor object. This File Depends On sourcefile~~wenoof_reconstructor_js.f90~~EfferentGraph sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 var pansourcefilewenoof_reconstructor_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_reconstructor_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_reconstructor_js.f90~~AfferentGraph sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilewenoof_reconstructor_jsf90AfferentGraph = svgPanZoom('#sourcefilewenoof_reconstructor_jsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_reconstructor_js Source Code wenoof_reconstructor_js.F90 Source Code !< Jiang-Shu (upwind) reconstructor object. module wenoof_reconstructor_js !< Jiang-Shu (upwind) reconstructor object. use , intrinsic :: iso_fortran_env , only : stderr => error_unit #ifdef r16p use penf , only : I_P , RPP => R16P , str #else use penf , only : I_P , RPP => R8P , str #endif use wenoof_base_object use wenoof_interpolations_factory use wenoof_interpolations_object use wenoof_interpolator_object use wenoof_weights_factory use wenoof_weights_object implicit none private public :: reconstructor_js public :: reconstructor_js_constructor type , extends ( interpolator_object_constructor ) :: reconstructor_js_constructor !< Jiang-Shu (upwind) reconstructor object constructor. endtype reconstructor_js_constructor type , extends ( interpolator_object ) :: reconstructor_js !< Jiang-Shu (upwind) reconstructor object. !< !< @note Provide the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !< !< @note The supported accuracy formal order are: 3rd, 5th, 7th, 9th, 11th, 13th, 15th, 17th  corresponding to use 2, 3, 4, 5, 6, !< 7, 8, 9 stencils composed of 2, 3, 4, 5, 6, 7, 8, 9 values, respectively. contains ! public deferred methods procedure , pass ( self ) :: create !< Create reconstructor. procedure , pass ( self ) :: description !< Return reconstructor string-description. procedure , pass ( self ) :: destroy !< Destroy reconstructor. procedure , pass ( self ) :: interpolate_debug !< Interpolate values (providing also debug values). procedure , pass ( self ) :: interpolate_standard !< Interpolate values (without providing debug values). endtype reconstructor_js contains ! public deferred methods subroutine create ( self , constructor ) !< Create interpolator. class ( reconstructor_js ), intent ( inout ) :: self !< Interpolator. class ( base_object_constructor ), intent ( in ) :: constructor !< Constructor. type ( interpolations_factory ) :: i_factory !< Inteprolations factory. type ( weights_factory ) :: w_factory !< Weights factory. call self % destroy call self % create_ ( constructor = constructor ) select type ( constructor ) class is ( interpolator_object_constructor ) call i_factory % create ( constructor = constructor % interpolations_constructor , object = self % interpolations ) call w_factory % create ( constructor = constructor % weights_constructor , object = self % weights ) endselect endsubroutine create pure function description ( self ) result ( string ) !< Return reconstructor string-descripition. class ( reconstructor_js ), intent ( in ) :: self !< Reconstructor. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = 'Jiang-Shu reconstructor:' // nl string = string // '  - S   = ' // trim ( str ( self % S )) // nl string = string // '  - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '  - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '  - ff  = ' // trim ( str ( self % ff )) // nl string = string // self % weights % description () endfunction description elemental subroutine destroy ( self ) !< Destroy reconstructor. class ( reconstructor_js ), intent ( inout ) :: self !< Reconstructor. call self % destroy_ if ( allocated ( self % interpolations )) deallocate ( self % interpolations ) if ( allocated ( self % weights )) deallocate ( self % weights ) endsubroutine destroy pure subroutine interpolate_debug ( self , stencil , interpolation , si , weights ) !< Interpolate values (providing also debug values). class ( reconstructor_js ), intent ( inout ) :: self !< Reconstructor. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( RPP ), intent ( out ) :: si ( 1 :, 0 :) !< Computed values of smoothness indicators [1:2, 0:S-1]. real ( RPP ), intent ( out ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S-1]. call self % interpolate_standard ( stencil = stencil , interpolation = interpolation ) si = self % weights % smoothness_indicators () weights = self % weights % values endsubroutine interpolate_debug pure subroutine interpolate_standard ( self , stencil , interpolation ) !< Interpolate values (without providing debug values). class ( reconstructor_js ), intent ( inout ) :: self !< Reconstructor. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. integer ( I_P ) :: f , s !< Counters. call self % interpolations % compute ( stencil = stencil ) call self % weights % compute ( stencil = stencil ) interpolation = 0._RPP do s = 0 , self % S - 1 ! stencils loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) interpolation ( f + self % ff ) = interpolation ( f + self % ff ) + & self % weights % values ( f + self % ff , s ) * self % interpolations % values ( f , s ) enddo enddo endsubroutine interpolate_standard endmodule wenoof_reconstructor_js","tags":"","loc":"sourcefile/wenoof_reconstructor_js.f90.html","title":"wenoof_reconstructor_js.F90 – FORESEER"},{"text":"Jiang-Shu alpha (non linear weights) object. This File Depends On sourcefile~~wenoof_alpha_rec_js.f90~~EfferentGraph sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_alpha_rec_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_rec_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_alpha_rec_js.f90~~AfferentGraph sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_alpha_rec_jsf90AfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_rec_jsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_alpha_rec_js Source Code wenoof_alpha_rec_js.F90 Source Code !< Jiang-Shu alpha (non linear weights) object. module wenoof_alpha_rec_js !< Jiang-Shu alpha (non linear weights) object. !< !< @note The provided alpha implements the alpha coefficients defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. #ifdef r16p use penf , only : I_P , RPP => R16P , str #else use penf , only : I_P , RPP => R8P , str #endif use wenoof_alpha_object use wenoof_base_object use wenoof_beta_object use wenoof_kappa_object implicit none private public :: alpha_rec_js public :: alpha_rec_js_constructor type , extends ( alpha_object_constructor ) :: alpha_rec_js_constructor !< Jiang-Shu alpha object constructor. endtype alpha_rec_js_constructor type , extends ( alpha_object ) :: alpha_rec_js !< Jiang-Shu alpha object. !< !< @note The provided WENO alpha implements the alpha coefficients defined in *Efficient Implementation of Weighted !< ENO Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. contains ! public deferred methods procedure , pass ( self ) :: create !< Create alpha. procedure , pass ( self ) :: compute !< Compute alpha. procedure , pass ( self ) :: description !< Return alpha string-description. procedure , pass ( self ) :: destroy !< Destroy alpha. endtype alpha_rec_js contains ! deferred public methods subroutine create ( self , constructor ) !< Create alpha. class ( alpha_rec_js ), intent ( inout ) :: self !< Alpha. class ( base_object_constructor ), intent ( in ) :: constructor !< Alpha constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % values_sum ( 1 : 2 )) self % values = 0._RPP self % values_sum = 0._RPP endsubroutine create pure subroutine compute ( self , beta , kappa ) !< Compute alpha. class ( alpha_rec_js ), intent ( inout ) :: self !< Alpha coefficient. class ( beta_object ), intent ( in ) :: beta !< Beta coefficients. class ( kappa_object ), intent ( in ) :: kappa !< Kappa coefficients. integer ( I_P ) :: f , s1 !< Counters. self % values_sum = 0._RPP do s1 = 0 , self % S - 1 ! stencil loops do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = kappa % values ( f , s1 ) / ( self % eps + beta % values ( f , s1 )) ** self % S self % values_sum ( f ) = self % values_sum ( f ) + self % values ( f , s1 ) enddo enddo endsubroutine compute pure function description ( self ) result ( string ) !< Return alpha string-descripition. class ( alpha_rec_js ), intent ( in ) :: self !< Alpha coefficient. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '    Jiang-Shu alpha coefficients for reconstructor:' // nl string = string // '      - S   = ' // trim ( str ( self % S )) // nl string = string // '      - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '      - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '      - ff  = ' // trim ( str ( self % ff )) // nl string = string // '      - eps = ' // trim ( str ( self % eps )) endfunction description elemental subroutine destroy ( self ) !< Destroy alpha. class ( alpha_rec_js ), intent ( inout ) :: self !< Alpha. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % values_sum )) deallocate ( self % values_sum ) endsubroutine destroy endmodule wenoof_alpha_rec_js","tags":"","loc":"sourcefile/wenoof_alpha_rec_js.f90.html","title":"wenoof_alpha_rec_js.F90 – FORESEER"},{"text":"Jiang-Shu and Gerolymos-Senechal-Vallet kappa coefficients for reconstruction. This File Depends On sourcefile~~wenoof_kappa_rec_js.f90~~EfferentGraph sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_kappa_rec_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_kappa_rec_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_kappa_rec_js.f90~~AfferentGraph sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_kappa_rec_jsf90AfferentGraph = svgPanZoom('#sourcefilewenoof_kappa_rec_jsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_kappa_rec_js Source Code wenoof_kappa_rec_js.F90 Source Code !< Jiang-Shu and Gerolymos-Senechal-Vallet kappa coefficients for reconstruction. module wenoof_kappa_rec_js !< Jiang-Shu and Gerolymos-Senechal-Vallet kappa coefficients for reconstruction. !< !< @note The provided WENO kappa implements the linear weights defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif use wenoof_base_object use wenoof_kappa_object implicit none private public :: kappa_rec_js public :: kappa_rec_js_constructor type , extends ( kappa_object_constructor ) :: kappa_rec_js_constructor !< Jiang-Shu and Gerolymos-Senechal-Vallet optimal kappa object constructor. endtype kappa_rec_js_constructor type , extends ( kappa_object ) :: kappa_rec_js !< Jiang-Shu and Gerolymos-Senechal-Vallet kappa object. !< !< @note The provided WENO kappa implements the weights defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 contains ! public deferred methods procedure , pass ( self ) :: create !< Create kappa. procedure , pass ( self ) :: compute !< Compute kappa. procedure , pass ( self ) :: description !< Return kappa string-description. procedure , pass ( self ) :: destroy !< Destroy kappa. endtype kappa_rec_js contains ! deferred public methods subroutine create ( self , constructor ) !< Create kappa. !< !< @note The kappa coefficients are also computed, they being constants. class ( kappa_rec_js ), intent ( inout ) :: self !< Kappa. class ( base_object_constructor ), intent ( in ) :: constructor !< Kappa constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP call self % compute endsubroutine create pure subroutine compute ( self ) !< Compute kappa. class ( kappa_rec_js ), intent ( inout ) :: self !< Kappa. associate ( val => self % values ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 2._RPP / 3._RPP ! stencil 0 val ( 1 , 1 ) = 1._RPP / 3._RPP ! stencil 1 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 3._RPP ! stencil 0 val ( 2 , 1 ) = 2._RPP / 3._RPP ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 0.3_RPP ! stencil 0 val ( 1 , 1 ) = 0.6_RPP ! stencil 1 val ( 1 , 2 ) = 0.1_RPP ! stencil 2 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 0.1_RPP ! stencil 0 val ( 2 , 1 ) = 0.6_RPP ! stencil 1 val ( 2 , 2 ) = 0.3_RPP ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 4._RPP / 3 5._RPP ! stencil 0 val ( 1 , 1 ) = 1 8._RPP / 3 5._RPP ! stencil 1 val ( 1 , 2 ) = 1 2._RPP / 3 5._RPP ! stencil 2 val ( 1 , 3 ) = 1._RPP / 3 5._RPP ! stencil 3 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 3 5._RPP ! stencil 0 val ( 2 , 1 ) = 1 2._RPP / 3 5._RPP ! stencil 1 val ( 2 , 2 ) = 1 8._RPP / 3 5._RPP ! stencil 2 val ( 2 , 3 ) = 4._RPP / 3 5._RPP ! stencil 3 case ( 5 ) ! 9th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 5._RPP / 12 6._RPP ! stencil 0 val ( 1 , 1 ) = 2 0._RPP / 6 3._RPP ! stencil 1 val ( 1 , 2 ) = 1 0._RPP / 2 1._RPP ! stencil 2 val ( 1 , 3 ) = 1 0._RPP / 6 3._RPP ! stencil 3 val ( 1 , 4 ) = 1._RPP / 12 6._RPP ! stencil 4 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 12 6._RPP ! stencil 0 val ( 2 , 1 ) = 1 0._RPP / 6 3._RPP ! stencil 1 val ( 2 , 2 ) = 1 0._RPP / 2 1._RPP ! stencil 2 val ( 2 , 3 ) = 2 0._RPP / 6 3._RPP ! stencil 3 val ( 2 , 4 ) = 5._RPP / 12 6._RPP ! stencil 4 case ( 6 ) ! 11th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 1._RPP / 7 7._RPP ! stencil 0 val ( 1 , 1 ) = 2 5._RPP / 15 4._RPP ! stencil 1 val ( 1 , 2 ) = 10 0._RPP / 23 1._RPP ! stencil 2 val ( 1 , 3 ) = 2 5._RPP / 7 7._RPP ! stencil 3 val ( 1 , 4 ) = 5._RPP / 7 7._RPP ! stencil 4 val ( 1 , 5 ) = 1._RPP / 46 2._RPP ! stencil 5 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 46 2._RPP ! stencil 0 val ( 2 , 1 ) = 5._RPP / 7 7._RPP ! stencil 1 val ( 2 , 2 ) = 2 5._RPP / 7 7._RPP ! stencil 2 val ( 2 , 3 ) = 10 0._RPP / 23 1._RPP ! stencil 3 val ( 2 , 4 ) = 2 5._RPP / 15 4._RPP ! stencil 4 val ( 2 , 5 ) = 1._RPP / 7 7._RPP ! stencil 5 case ( 7 ) ! 13th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 7._RPP / 171 6._RPP ! stencil 0 val ( 1 , 1 ) = 2 1._RPP / 28 6._RPP ! stencil 1 val ( 1 , 2 ) = 17 5._RPP / 57 2._RPP ! stencil 2 val ( 1 , 3 ) = 17 5._RPP / 42 9._RPP ! stencil 3 val ( 1 , 4 ) = 10 5._RPP / 57 2._RPP ! stencil 4 val ( 1 , 5 ) = 7._RPP / 28 6._RPP ! stencil 5 val ( 1 , 6 ) = 1._RPP / 171 6._RPP ! stencil 6 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 171 6._RPP ! stencil 0 val ( 2 , 1 ) = 7._RPP / 28 6._RPP ! stencil 1 val ( 2 , 2 ) = 10 5._RPP / 57 2._RPP ! stencil 2 val ( 2 , 3 ) = 17 5._RPP / 42 9._RPP ! stencil 3 val ( 2 , 4 ) = 17 5._RPP / 57 2._RPP ! stencil 4 val ( 2 , 5 ) = 2 1._RPP / 28 6._RPP ! stencil 5 val ( 2 , 6 ) = 7._RPP / 171 6._RPP ! stencil 6 case ( 8 ) ! 15th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 8._RPP / 643 5._RPP ! stencil 0 val ( 1 , 1 ) = 19 6._RPP / 643 5._RPP ! stencil 1 val ( 1 , 2 ) = 39 2._RPP / 214 5._RPP ! stencil 2 val ( 1 , 3 ) = 49 0._RPP / 128 7._RPP ! stencil 3 val ( 1 , 4 ) = 39 2._RPP / 128 7._RPP ! stencil 4 val ( 1 , 5 ) = 19 6._RPP / 214 5._RPP ! stencil 5 val ( 1 , 6 ) = 5 6._RPP / 643 5._RPP ! stencil 6 val ( 1 , 7 ) = 1._RPP / 643 5._RPP ! stencil 7 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 643 5._RPP ! stencil 0 val ( 2 , 1 ) = 5 6._RPP / 643 5._RPP ! stencil 1 val ( 2 , 2 ) = 19 6._RPP / 214 5._RPP ! stencil 2 val ( 2 , 3 ) = 39 2._RPP / 128 7._RPP ! stencil 3 val ( 2 , 4 ) = 49 0._RPP / 128 7._RPP ! stencil 4 val ( 2 , 5 ) = 39 2._RPP / 214 5._RPP ! stencil 5 val ( 2 , 6 ) = 19 6._RPP / 643 5._RPP ! stencil 6 val ( 2 , 7 ) = 8._RPP / 643 5._RPP ! stencil 7 case ( 9 ) ! 17th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 9._RPP / 2431 0._RPP ! stencil 0 val ( 1 , 1 ) = 14 4._RPP / 1215 5._RPP ! stencil 1 val ( 1 , 2 ) = 117 6._RPP / 1215 5._RPP ! stencil 2 val ( 1 , 3 ) = 352 8._RPP / 1215 5._RPP ! stencil 3 val ( 1 , 4 ) = 88 2._RPP / 243 1._RPP ! stencil 4 val ( 1 , 5 ) = 235 2._RPP / 1215 5._RPP ! stencil 5 val ( 1 , 6 ) = 50 4._RPP / 1215 5._RPP ! stencil 6 val ( 1 , 7 ) = 3 6._RPP / 1215 5._RPP ! stencil 7 val ( 1 , 8 ) = 1._RPP / 2431 0._RPP ! stencil 8 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 2431 0._RPP ! stencil 0 val ( 2 , 1 ) = 3 6._RPP / 1215 5._RPP ! stencil 1 val ( 2 , 2 ) = 50 4._RPP / 1215 5._RPP ! stencil 2 val ( 2 , 3 ) = 235 2._RPP / 1215 5._RPP ! stencil 3 val ( 2 , 4 ) = 88 2._RPP / 243 1._RPP ! stencil 4 val ( 2 , 5 ) = 352 8._RPP / 1215 5._RPP ! stencil 5 val ( 2 , 6 ) = 117 6._RPP / 1215 5._RPP ! stencil 6 val ( 2 , 7 ) = 14 4._RPP / 1215 5._RPP ! stencil 7 val ( 2 , 8 ) = 9._RPP / 2431 0._RPP ! stencil 8 endselect endassociate endsubroutine compute pure function description ( self ) result ( string ) !< Return string-description of kappa. class ( kappa_rec_js ), intent ( in ) :: self !< Kappa. character ( len = :), allocatable :: string !< String-description. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'kappa_rec_js%description to be implemented, do not use!' #endif endfunction description elemental subroutine destroy ( self ) !< Destroy kappa. class ( kappa_rec_js ), intent ( inout ) :: self !< Kappa. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) endsubroutine destroy endmodule wenoof_kappa_rec_js","tags":"","loc":"sourcefile/wenoof_kappa_rec_js.f90.html","title":"wenoof_kappa_rec_js.F90 – FORESEER"},{"text":"Jiang-Shu and Gerolymos-Senechal-Vallet weights. This File Depends On sourcefile~~wenoof_weights_js.f90~~EfferentGraph sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_weights_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_weights_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_weights_js.f90~~AfferentGraph sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_weights_jsf90AfferentGraph = svgPanZoom('#sourcefilewenoof_weights_jsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_weights_js Source Code wenoof_weights_js.F90 Source Code !< Jiang-Shu and Gerolymos-Senechal-Vallet weights. module wenoof_weights_js !< Jiang-Shu and Gerolymos-Senechal-Vallet weights. !< !< @note The provided WENO weights implements the weights defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 #ifdef r16p use penf , only : I_P , RPP => R16P , str #else use penf , only : I_P , RPP => R8P , str #endif use wenoof_alpha_factory use wenoof_alpha_object use wenoof_alpha_rec_js use wenoof_alpha_rec_m use wenoof_alpha_rec_z use wenoof_base_object use wenoof_beta_factory use wenoof_beta_object use wenoof_beta_rec_js use wenoof_kappa_factory use wenoof_kappa_object use wenoof_kappa_rec_js use wenoof_weights_object implicit none private public :: weights_js public :: weights_js_constructor type , extends ( weights_object_constructor ) :: weights_js_constructor !< Jiang-Shu and Gerolymos-Senechal-Vallet optimal weights object constructor. class ( alpha_object_constructor ), allocatable :: alpha_constructor !< Alpha coefficients (non linear weights) constructor. class ( beta_object_constructor ), allocatable :: beta_constructor !< Beta coefficients (smoothness indicators) constructor. class ( kappa_object_constructor ), allocatable :: kappa_constructor !< kappa coefficients (optimal, linear weights) constructor. endtype weights_js_constructor type , extends ( weights_object ) :: weights_js !< Jiang-Shu and Gerolymos-Senechal-Vallet weights object. !< !< @note The provided WENO weights implements the weights defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 class ( alpha_object ), allocatable :: alpha !< Alpha coefficients (non linear weights). class ( beta_object ), allocatable :: beta !< Beta coefficients (smoothness indicators). class ( kappa_object ), allocatable :: kappa !< kappa coefficients (optimal, linear weights). contains ! deferred public methods procedure , pass ( self ) :: create !< Create weights. procedure , pass ( self ) :: compute !< Compute weights. procedure , pass ( self ) :: description !< Return weights string-description. procedure , pass ( self ) :: destroy !< Destroy weights. procedure , pass ( self ) :: smoothness_indicators !< Return smoothness indicators. endtype weights_js contains ! deferred public methods subroutine create ( self , constructor ) !< Create reconstructor. class ( weights_js ), intent ( inout ) :: self !< Weights. class ( base_object_constructor ), intent ( in ) :: constructor !< Constructor. type ( alpha_factory ) :: a_factory !< Alpha factory. type ( beta_factory ) :: b_factory !< Beta factory. type ( kappa_factory ) :: k_factory !< Kappa factory. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP select type ( constructor ) type is ( weights_js_constructor ) associate ( alpha_constructor => constructor % alpha_constructor , & beta_constructor => constructor % beta_constructor , & kappa_constructor => constructor % kappa_constructor ) call a_factory % create ( constructor = alpha_constructor , object = self % alpha ) ! select type(alpha_constructor) ! type is(alpha_rec_js_constructor) !   call factory%create(constructor=alpha_constructor, object=self%alpha) ! type is(alpha_rec_m_constructor) !   call factory%create(constructor=alpha_constructor, object=self%alpha) ! type is(alpha_rec_z_constructor) !   call factory%create(constructor=alpha_constructor, object=self%alpha) ! endselect call b_factory % create ( constructor = beta_constructor , object = self % beta ) ! select type(beta_constructor) ! type is(beta_rec_js_constructor) !   allocate(beta_rec_js :: self%beta) !   call self%beta%create(constructor=beta_constructor) ! endselect call k_factory % create ( constructor = kappa_constructor , object = self % kappa ) ! select type(kappa_constructor) ! type is(kappa_rec_js_constructor) !   allocate(kappa_rec_js :: self%kappa) !   call self%kappa%create(constructor=kappa_constructor) ! endselect endassociate endselect endsubroutine create pure subroutine compute ( self , stencil ) !< Compute weights. class ( weights_js ), intent ( inout ) :: self !< Weights. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. integer ( I_P ) :: f , s !< Counters. call self % beta % compute ( stencil = stencil ) call self % alpha % compute ( beta = self % beta , kappa = self % kappa ) do s = 0 , self % S - 1 ! stencils loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f + self % ff , s ) = self % alpha % values ( f , s ) / self % alpha % values_sum ( f ) enddo enddo endsubroutine compute pure function description ( self ) result ( string ) !< Return string-description of weights. class ( weights_js ), intent ( in ) :: self !< Weights. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '  Jiang-Shu weights:' // nl string = string // '    - S   = ' // trim ( str ( self % S )) // nl string = string // '    - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '    - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '    - ff  = ' // trim ( str ( self % ff )) // nl string = string // self % alpha % description () endfunction description elemental subroutine destroy ( self ) !< Destroy weights. class ( weights_js ), intent ( inout ) :: self !< Weights. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % alpha )) deallocate ( self % alpha ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % kappa )) deallocate ( self % kappa ) endsubroutine destroy pure function smoothness_indicators ( self ) result ( si ) !< Return smoothness indicators.. class ( weights_js ), intent ( in ) :: self !< Weights. real ( RPP ), allocatable :: si (:,:) !< Smoothness indicators. if ( allocated ( self % beta )) then if ( allocated ( self % beta % values )) then si = self % beta % values endif endif endfunction smoothness_indicators endmodule wenoof_weights_js","tags":"","loc":"sourcefile/wenoof_weights_js.f90.html","title":"wenoof_weights_js.F90 – FORESEER"},{"text":"Jiang-Shu (upwind) interpolator object. This File Depends On sourcefile~~wenoof_interpolator_js.f90~~EfferentGraph sourcefile~wenoof_interpolator_js.f90 wenoof_interpolator_js.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 var pansourcefilewenoof_interpolator_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_interpolator_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_interpolator_js Source Code wenoof_interpolator_js.F90 Source Code !< Jiang-Shu (upwind) interpolator object. module wenoof_interpolator_js !< Jiang-Shu (upwind) interpolator object. use , intrinsic :: iso_fortran_env , only : stderr => error_unit #ifdef r16p use penf , only : RPP => R16P #else use penf , only : RPP => R8P #endif use wenoof_interpolator_object implicit none private public :: interpolator_js public :: interpolator_js_constructor type , extends ( interpolator_object_constructor ) :: interpolator_js_constructor !< Jiang-Shu (upwind) interpolator object constructor. endtype interpolator_js_constructor type , extends ( interpolator_object ) :: interpolator_js !< Jiang-Shu (upwind) interpolator object. contains ! public deferred methods procedure , pass ( self ) :: description !< Return interpolator string-description. procedure , pass ( self ) :: interpolate_standard !< Interpolate values (without providing debug values). procedure , pass ( self ) :: interpolate_debug !< Interpolate values (providing also debug values). endtype interpolator_js contains ! public deferred methods pure function description ( self ) result ( string ) !< Return interpolator string-descripition. class ( interpolator_js ), intent ( in ) :: self !< Interpolator. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line character. character ( len = :), allocatable :: dummy_string !< Dummy string. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolator_js to be implemented, do not use!' #endif endfunction description pure subroutine interpolate_standard ( self , stencil , interpolation ) !< Interpolate values (without providing debug values). class ( interpolator_js ), intent ( inout ) :: self !< Interpolator. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolator_js to be implemented, do not use!' #endif endsubroutine interpolate_standard pure subroutine interpolate_debug ( self , stencil , interpolation , si , weights ) !< Interpolate values (providing also debug values). class ( interpolator_js ), intent ( inout ) :: self !< Interpolator. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( RPP ), intent ( out ) :: si ( 1 :, 0 :) !< Computed values of smoothness indicators [1:2, 0:S-1]. real ( RPP ), intent ( out ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S-1]. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolator_js to be implemented, do not use!' #endif endsubroutine interpolate_debug endmodule wenoof_interpolator_js","tags":"","loc":"sourcefile/wenoof_interpolator_js.f90.html","title":"wenoof_interpolator_js.F90 – FORESEER"},{"text":"Borges alpha (non linear weights) object. This File Depends On sourcefile~~wenoof_alpha_rec_z.f90~~EfferentGraph sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_alpha_rec_zf90EfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_rec_zf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_alpha_rec_z.f90~~AfferentGraph sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_alpha_rec_zf90AfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_rec_zf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_alpha_rec_z Source Code wenoof_alpha_rec_z.F90 Source Code !< Borges alpha (non linear weights) object. module wenoof_alpha_rec_z !< Borges alpha (non linear weights) object. !< !< @note The provided WENO alpha implements the alpha coefficients defined in *An improved weighted essentially non-oscillatory !< scheme for hyperbolic conservation laws*, Rafael Borges, Monique Carmona, Bruno Costa and Wai Sun Don, JCP, 2008, !< vol. 227, pp. 3191-3211, doi: 10.1016/j.jcp.2007.11.038. #ifdef r16p use penf , only : I_P , RPP => R16P , str #else use penf , only : I_P , RPP => R8P , str #endif use wenoof_alpha_object use wenoof_base_object use wenoof_beta_object use wenoof_kappa_object implicit none private public :: alpha_rec_z public :: alpha_rec_z_constructor type , extends ( alpha_object_constructor ) :: alpha_rec_z_constructor !< Borges alpha (non linear weights) object constructor. endtype alpha_rec_z_constructor type , extends ( alpha_object ) :: alpha_rec_z !< Borges alpha (non linear weights) object. !< !< @note The provided alpha implements the alpha coefficients defined in *An improved weighted essentially non-oscillatory !< scheme for hyperbolic conservation laws*, Rafael Borges, Monique Carmona, Bruno Costa and Wai Sun Don, JCP, !< 2008, vol. 227, pp. 3191-3211, doi: 10.1016/j.jcp.2007.11.038. contains ! public deferred methods procedure , pass ( self ) :: create !< Create alpha. procedure , pass ( self ) :: compute !< Compute alpha. procedure , pass ( self ) :: description !< Return alpha string-description. procedure , pass ( self ) :: destroy !< Destroy alpha. endtype alpha_rec_z contains ! public deferred methods subroutine create ( self , constructor ) !< Create alpha. class ( alpha_rec_z ), intent ( inout ) :: self !< Alpha. class ( base_object_constructor ), intent ( in ) :: constructor !< Alpha constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % values_sum ( 1 : 2 )) self % values = 0._RPP self % values_sum = 0._RPP endsubroutine create pure subroutine compute ( self , beta , kappa ) !< Compute alpha. class ( alpha_rec_z ), intent ( inout ) :: self !< Alpha. class ( beta_object ), intent ( in ) :: beta !< Beta. class ( kappa_object ), intent ( in ) :: kappa !< Kappa. integer ( I_P ) :: f , s1 !< Counters. self % values_sum = 0._RPP do s1 = 0 , self % S - 1 ! stencil loops do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = kappa % values ( f , s1 ) * & (( 1._RPP + ( tau ( S = self % S , beta = beta % values ) / ( self % eps + beta % values ( f , s1 )))) ** ( weno_exp ( self % S ))) self % values_sum ( f ) = self % values_sum ( f ) + self % values ( f , s1 ) enddo enddo endsubroutine compute pure function description ( self ) result ( string ) !< Return alpha string-descripition. class ( alpha_rec_z ), intent ( in ) :: self !< Alpha coefficients. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '    Borges alpha coefficients for reconstructor:' // nl string = string // '      - S   = ' // trim ( str ( self % S )) // nl string = string // '      - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '      - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '      - ff  = ' // trim ( str ( self % ff )) // nl string = string // '      - eps = ' // trim ( str ( self % eps )) endfunction description elemental subroutine destroy ( self ) !< Destroy alpha. class ( alpha_rec_z ), intent ( inout ) :: self !< Alpha. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % values_sum )) deallocate ( self % values_sum ) endsubroutine destroy ! private non TBP pure function tau ( S , beta ) result ( w_tau ) !< Compute the tau coefficient used in the WENO-Z alpha coefficients. integer ( I_P ), intent ( in ) :: S !< Number of stencils used. real ( RPP ), intent ( in ) :: beta ( 0 : S - 1 ) !< Smoothness indicators. real ( RPP ) :: w_tau !< Tau coefficient. w_tau = abs ( beta ( 0 ) - & ( 1_I_P - weno_odd ( S )) * beta ( 1 ) - & ( 1_I_P - weno_odd ( S )) * beta ( S - 2 ) + & ( 1_I_P - 2_I_P * weno_odd ( S )) * beta ( S - 1 )) endfunction tau pure function weno_exp ( S ) result ( w_exp ) !< Compute the exponent used in the alpha function. integer ( I_P ), intent ( in ) :: S !< Number of stencils used. integer ( I_P ) :: w_exp !< Exponent used in the alpha function. w_exp = int ( S , I_P ) endfunction weno_exp pure function weno_odd ( S ) result ( w_odd ) !< Compute the distinguisher between odd and even number of stencils. integer ( I_P ), intent ( in ) :: S !< Number of stencils used. integer ( I_P ) :: w_odd !< Distinguishing between odd and even number of stencils. w_odd = int ( mod ( S , 2_I_P ), I_P ) endfunction weno_odd endmodule wenoof_alpha_rec_z","tags":"","loc":"sourcefile/wenoof_alpha_rec_z.f90.html","title":"wenoof_alpha_rec_z.F90 – FORESEER"},{"text":"Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. This File Depends On sourcefile~~wenoof_interpolations_rec_js.f90~~EfferentGraph sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_interpolations_rec_jsf90EfferentGraph = svgPanZoom('#sourcefilewenoof_interpolations_rec_jsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_interpolations_rec_js.f90~~AfferentGraph sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_interpolations_rec_jsf90AfferentGraph = svgPanZoom('#sourcefilewenoof_interpolations_rec_jsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_interpolations_rec_js Source Code wenoof_interpolations_rec_js.F90 Source Code !< Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. module wenoof_interpolations_rec_js !< Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. !< !< @note The provided interpolations implement the Lagrange interpolations defined in *Efficient Implementation !< of Weighted ENO Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif use wenoof_base_object use wenoof_interpolations_object implicit none private public :: interpolations_rec_js public :: interpolations_rec_js_constructor type , extends ( interpolations_object_constructor ) :: interpolations_rec_js_constructor !< Jiang-Shu (Lagrange) interpolations object for derivative reconstruction constructor. endtype interpolations_rec_js_constructor type , extends ( interpolations_object ) :: interpolations_rec_js !< Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. !< !< @note The provided interpolations implement the Lagrange interpolations defined in *Efficient Implementation !< of Weighted ENO Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 private real ( RPP ), allocatable :: coef (:,:,:) !< Polynomial coefficients [1:2,0:S-1,0:S-1]. contains ! public deferred methods procedure , pass ( self ) :: create !< Create interpolations. procedure , pass ( self ) :: compute !< Compute interpolations. procedure , pass ( self ) :: description !< Return interpolations string-description. procedure , pass ( self ) :: destroy !< Destroy interpolations. endtype interpolations_rec_js contains ! public deferred methods subroutine create ( self , constructor ) !< Create interpolations. class ( interpolations_rec_js ), intent ( inout ) :: self !< Interpolations. class ( base_object_constructor ), intent ( in ) :: constructor !< Interpolations constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP allocate ( self % coef ( 1 : 2 , 0 : self % S - 1 , 0 : self % S - 1 )) associate ( c => self % coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) !  cell  0           ;    cell  1 c ( 1 , 0 , 0 ) = 0.5_RPP ; c ( 1 , 1 , 0 ) = 0.5_RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 0.5_RPP ; c ( 1 , 1 , 1 ) = 1.5_RPP ! stencil 1 ! 2 => right interface (i+1/2) !  cell  0           ;    cell  1 c ( 2 , 0 , 0 ) = 1.5_RPP ; c ( 2 , 1 , 0 ) = - 0.5_RPP ! stencil 0 c ( 2 , 0 , 1 ) = 0.5_RPP ; c ( 2 , 1 , 1 ) = 0.5_RPP ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) !  cell  0                 ;    cell  1                 ;    cell  2 c ( 1 , 0 , 0 ) = 1._RPP / 3._RPP ; c ( 1 , 1 , 0 ) = 5._RPP / 6._RPP ; c ( 1 , 2 , 0 ) = - 1._RPP / 6._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 6._RPP ; c ( 1 , 1 , 1 ) = 5._RPP / 6._RPP ; c ( 1 , 2 , 1 ) = 1._RPP / 3._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 3._RPP ; c ( 1 , 1 , 2 ) = - 7._RPP / 6._RPP ; c ( 1 , 2 , 2 ) = 1 1._RPP / 6._RPP ! stencil 2 ! 2 => right interface (i+1/2) !  cell  0                 ;    cell  1                 ;    cell  2 c ( 2 , 0 , 0 ) = 1 1._RPP / 6._RPP ; c ( 2 , 1 , 0 ) = - 7._RPP / 6._RPP ; c ( 2 , 2 , 0 ) = 1._RPP / 3._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 3._RPP ; c ( 2 , 1 , 1 ) = 5._RPP / 6._RPP ; c ( 2 , 2 , 1 ) = - 1._RPP / 6._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 6._RPP ; c ( 2 , 1 , 2 ) = 5._RPP / 6._RPP ; c ( 2 , 2 , 2 ) = 1._RPP / 3._RPP ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) !  cell  0               ;    cell  1               ;    cell  2               ;    cell  3 c ( 1 , 0 , 0 ) = 1._RPP / 4._RPP ; c ( 1 , 1 , 0 ) = 1 3._RPP / 1 2._RPP ; c ( 1 , 2 , 0 ) = - 5._RPP / 1 2._RPP ; c ( 1 , 3 , 0 ) = 1._RPP / 1 2._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 1 2._RPP ; c ( 1 , 1 , 1 ) = 7._RPP / 1 2._RPP ; c ( 1 , 2 , 1 ) = 7._RPP / 1 2._RPP ; c ( 1 , 3 , 1 ) = - 1._RPP / 1 2._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 1 2._RPP ; c ( 1 , 1 , 2 ) = - 5._RPP / 1 2._RPP ; c ( 1 , 2 , 2 ) = 1 3._RPP / 1 2._RPP ; c ( 1 , 3 , 2 ) = 1._RPP / 4._RPP ! stencil 2 c ( 1 , 0 , 3 ) = - 1._RPP / 4._RPP ; c ( 1 , 1 , 3 ) = 1 3._RPP / 1 2._RPP ; c ( 1 , 2 , 3 ) =- 2 3._RPP / 1 2._RPP ; c ( 1 , 3 , 3 ) = 2 5._RPP / 1 2._RPP ! stencil 3 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1               ;   cell  2                ;    cell  3 c ( 2 , 0 , 0 ) = 2 5._RPP / 1 2._RPP ; c ( 2 , 1 , 0 ) =- 2 3._RPP / 1 2._RPP ; c ( 2 , 2 , 0 ) = 1 3._RPP / 1 2._RPP ; c ( 2 , 3 , 0 ) = - 1._RPP / 4._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 4._RPP ; c ( 2 , 1 , 1 ) = 1 3._RPP / 1 2._RPP ; c ( 2 , 2 , 1 ) = - 5._RPP / 1 2._RPP ; c ( 2 , 3 , 1 ) = 1._RPP / 1 2._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 1 2._RPP ; c ( 2 , 1 , 2 ) = 7._RPP / 1 2._RPP ; c ( 2 , 2 , 2 ) = 7._RPP / 1 2._RPP ; c ( 2 , 3 , 2 ) = - 1._RPP / 1 2._RPP ! stencil 2 c ( 2 , 0 , 3 ) = 1._RPP / 1 2._RPP ; c ( 2 , 1 , 3 ) = - 5._RPP / 1 2._RPP ; c ( 2 , 2 , 3 ) = 1 3._RPP / 1 2._RPP ; c ( 2 , 3 , 3 ) = 1._RPP / 4._RPP ! stencil 3 case ( 5 ) ! 9th order ! 1 => left interface (i-1/2) !  cell  0                ;    cell  1                ;    cell  2                ;    cell  3 c ( 1 , 0 , 0 ) = 1._RPP / 5._RPP ; c ( 1 , 1 , 0 ) = 7 7._RPP / 6 0._RPP ; c ( 1 , 2 , 0 ) = - 4 3._RPP / 6 0._RPP ; c ( 1 , 3 , 0 ) = 1 7._RPP / 6 0._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 2 0._RPP ; c ( 1 , 1 , 1 ) = 9._RPP / 2 0._RPP ; c ( 1 , 2 , 1 ) = 4 7._RPP / 6 0._RPP ; c ( 1 , 3 , 1 ) = - 1 3._RPP / 6 0._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 3 0._RPP ; c ( 1 , 1 , 2 ) = - 1 3._RPP / 6 0._RPP ; c ( 1 , 2 , 2 ) = 4 7._RPP / 6 0._RPP ; c ( 1 , 3 , 2 ) = 9._RPP / 2 0._RPP ! stencil 2 c ( 1 , 0 , 3 ) = - 1._RPP / 2 0._RPP ; c ( 1 , 1 , 3 ) = 1 7._RPP / 6 0._RPP ; c ( 1 , 2 , 3 ) = - 4 3._RPP / 6 0._RPP ; c ( 1 , 3 , 3 ) = 7 7._RPP / 6 0._RPP ! stencil 3 c ( 1 , 0 , 4 ) = 1._RPP / 5._RPP ; c ( 1 , 1 , 4 ) = - 2 1._RPP / 2 0._RPP ; c ( 1 , 2 , 4 ) = 13 7._RPP / 6 0._RPP ; c ( 1 , 3 , 4 ) =- 16 3._RPP / 6 0._RPP ! stencil 4 !  cell  4 c ( 1 , 4 , 0 ) = - 1._RPP / 2 0._RPP ! stencil 0 c ( 1 , 4 , 1 ) = 1._RPP / 3 0._RPP ! stencil 1 c ( 1 , 4 , 2 ) = - 1._RPP / 2 0._RPP ! stencil 2 c ( 1 , 4 , 3 ) = 1._RPP / 5._RPP ! stencil 3 c ( 1 , 4 , 4 ) = 13 7._RPP / 6 0._RPP ! stencil 4 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1               ;   cell  2                ;    cell  3 c ( 2 , 0 , 0 ) = 13 7._RPP / 6 0._RPP ; c ( 2 , 1 , 0 ) =- 16 3._RPP / 6 0._RPP ; c ( 2 , 2 , 0 ) = 13 7._RPP / 6 0._RPP ; c ( 2 , 3 , 0 ) = - 2 1._RPP / 2 0._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 5._RPP ; c ( 2 , 1 , 1 ) = 7 7._RPP / 6 0._RPP ; c ( 2 , 2 , 1 ) = - 4 3._RPP / 6 0._RPP ; c ( 2 , 3 , 1 ) = 1 7._RPP / 6 0._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 2 0._RPP ; c ( 2 , 1 , 2 ) = 9._RPP / 2 0._RPP ; c ( 2 , 2 , 2 ) = 4 7._RPP / 6 0._RPP ; c ( 2 , 3 , 2 ) = - 1 3._RPP / 6 0._RPP ! stencil 2 c ( 2 , 0 , 3 ) = 1._RPP / 3 0._RPP ; c ( 2 , 1 , 3 ) = - 1 3._RPP / 6 0._RPP ; c ( 2 , 2 , 3 ) = 4 7._RPP / 6 0._RPP ; c ( 2 , 3 , 3 ) = 9._RPP / 2 0._RPP ! stencil 3 c ( 2 , 0 , 4 ) = - 1._RPP / 2 0._RPP ; c ( 2 , 1 , 4 ) = 1 7._RPP / 6 0._RPP ; c ( 2 , 2 , 4 ) = - 4 3._RPP / 6 0._RPP ; c ( 2 , 3 , 4 ) = 7 7._RPP / 6 0._RPP ! stencil 4 !  cell  4 c ( 2 , 4 , 0 ) = 1._RPP / 5._RPP ! stencil 0 c ( 2 , 4 , 1 ) = - 1._RPP / 2 0._RPP ! stencil 1 c ( 2 , 4 , 2 ) = 1._RPP / 3 0._RPP ! stencil 2 c ( 2 , 4 , 3 ) = - 1._RPP / 2 0._RPP ! stencil 3 c ( 2 , 4 , 4 ) = 1._RPP / 5._RPP ! stencil 4 case ( 6 ) ! 11th order ! 1 => left interface (i-1/2) !  cell  0                ;    cell  1                ;    cell  2                ;    cell  3 c ( 1 , 0 , 0 ) = 1._RPP / 6._RPP ; c ( 1 , 1 , 0 ) = 2 9._RPP / 2 0._RPP ; c ( 1 , 2 , 0 ) = - 2 1._RPP / 2 0._RPP ; c ( 1 , 3 , 0 ) = 3 7._RPP / 6 0._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 3 0._RPP ; c ( 1 , 1 , 1 ) = 1 1._RPP / 3 0._RPP ; c ( 1 , 2 , 1 ) = 1 9._RPP / 2 0._RPP ; c ( 1 , 3 , 1 ) = - 2 3._RPP / 6 0._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 6 0._RPP ; c ( 1 , 1 , 2 ) = - 2._RPP / 1 5._RPP ; c ( 1 , 2 , 2 ) = 3 7._RPP / 6 0._RPP ; c ( 1 , 3 , 2 ) = 3 7._RPP / 6 0._RPP ! stencil 2 c ( 1 , 0 , 3 ) = - 1._RPP / 6 0._RPP ; c ( 1 , 1 , 3 ) = 7._RPP / 6 0._RPP ; c ( 1 , 2 , 3 ) = - 2 3._RPP / 6 0._RPP ; c ( 1 , 3 , 3 ) = 1 9._RPP / 2 0._RPP ! stencil 3 c ( 1 , 0 , 4 ) = 1._RPP / 3 0._RPP ; c ( 1 , 1 , 4 ) = - 1 3._RPP / 6 0._RPP ; c ( 1 , 2 , 4 ) = 3 7._RPP / 6 0._RPP ; c ( 1 , 3 , 4 ) = - 2 1._RPP / 2 0._RPP ! stencil 4 c ( 1 , 0 , 5 ) = - 1._RPP / 6._RPP ; c ( 1 , 1 , 5 ) = 3 1._RPP / 3 0._RPP ; c ( 1 , 2 , 5 ) =- 16 3._RPP / 6 0._RPP ; c ( 1 , 3 , 5 ) = 7 9._RPP / 2 0._RPP ! stencil 5 !  cell  4                ;    cell  5 c ( 1 , 4 , 0 ) = - 1 3._RPP / 6 0._RPP ; c ( 1 , 5 , 0 ) = 1._RPP / 3 0._RPP ! stencil 0 c ( 1 , 4 , 1 ) = 7._RPP / 6 0._RPP ; c ( 1 , 5 , 1 ) = - 1._RPP / 6 0._RPP ! stencil 1 c ( 1 , 4 , 2 ) = - 2._RPP / 1 5._RPP ; c ( 1 , 5 , 2 ) = 1._RPP / 6 0._RPP ! stencil 2 c ( 1 , 4 , 3 ) = 1 1._RPP / 3 0._RPP ; c ( 1 , 5 , 3 ) = - 1._RPP / 3 0._RPP ! stencil 3 c ( 1 , 4 , 4 ) = 2 9._RPP / 2 0._RPP ; c ( 1 , 5 , 4 ) = 1._RPP / 6._RPP ! stencil 4 c ( 1 , 4 , 5 ) = - 7 1._RPP / 2 0._RPP ; c ( 1 , 5 , 5 ) = 4 9._RPP / 2 0._RPP ! stencil 5 ! 2 => right interface (i+1/2) !  cell  0                ;    cell  1                ;   cell  2                 ;    cell  3 c ( 2 , 0 , 0 ) = 4 9._RPP / 2 0._RPP ; c ( 2 , 1 , 0 ) = - 7 1._RPP / 2 0._RPP ; c ( 2 , 2 , 0 ) = 7 9._RPP / 2 0._RPP ; c ( 2 , 3 , 0 ) =- 16 3._RPP / 6 0._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 6._RPP ; c ( 2 , 1 , 1 ) = 2 9._RPP / 2 0._RPP ; c ( 2 , 2 , 1 ) = - 2 1._RPP / 2 0._RPP ; c ( 2 , 3 , 1 ) = 3 7._RPP / 6 0._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 3 0._RPP ; c ( 2 , 1 , 2 ) = 1 1._RPP / 3 0._RPP ; c ( 2 , 2 , 2 ) = 1 9._RPP / 2 0._RPP ; c ( 2 , 3 , 2 ) = - 2 3._RPP / 6 0._RPP ! stencil 2 c ( 2 , 0 , 3 ) = 1._RPP / 6 0._RPP ; c ( 2 , 1 , 3 ) = - 2._RPP / 1 5._RPP ; c ( 2 , 2 , 3 ) = 3 7._RPP / 6 0._RPP ; c ( 2 , 3 , 3 ) = 3 7._RPP / 6 0._RPP ! stencil 3 c ( 2 , 0 , 4 ) = - 1._RPP / 6 0._RPP ; c ( 2 , 1 , 4 ) = 7._RPP / 6 0._RPP ; c ( 2 , 2 , 4 ) = - 2 3._RPP / 6 0._RPP ; c ( 2 , 3 , 4 ) = 1 9._RPP / 2 0._RPP ! stencil 4 c ( 2 , 0 , 5 ) = 1._RPP / 3 0._RPP ; c ( 2 , 1 , 5 ) = - 1 3._RPP / 6 0._RPP ; c ( 2 , 2 , 5 ) = 3 7._RPP / 6 0._RPP ; c ( 2 , 3 , 5 ) = - 2 1._RPP / 2 0._RPP ! stencil 5 !  cell  4                ;    cell  5 c ( 2 , 4 , 0 ) = 3 1._RPP / 3 0._RPP ; c ( 2 , 5 , 0 ) = - 1._RPP / 6._RPP ! stencil 0 c ( 2 , 4 , 1 ) = - 1 3._RPP / 6 0._RPP ; c ( 2 , 5 , 1 ) = 1._RPP / 3 0._RPP ! stencil 1 c ( 2 , 4 , 2 ) = 7._RPP / 6 0._RPP ; c ( 2 , 5 , 2 ) = - 1._RPP / 6 0._RPP ! stencil 2 c ( 2 , 4 , 3 ) = - 2._RPP / 1 5._RPP ; c ( 2 , 5 , 3 ) = 1._RPP / 6 0._RPP ! stencil 3 c ( 2 , 4 , 4 ) = 1 1._RPP / 3 0._RPP ; c ( 2 , 5 , 4 ) = - 1._RPP / 3 0._RPP ! stencil 4 c ( 2 , 4 , 5 ) = 2 9._RPP / 2 0._RPP ; c ( 2 , 5 , 5 ) = 1._RPP / 6._RPP ! stencil 5 case ( 7 ) ! 13th order !! 1 => left interface (i-1/2) !  cell  0                  ;    cell  1                  ;    cell  2 !c(1,0,0)=    1._RPP/7._RPP  ; c(1,1,0)=  223._RPP/140._RPP; c(1,2,0)= -197._RPP/140._RPP  ! stencil 0 !c(1,0,1)=   -1._RPP/42._RPP ; c(1,1,1)=   13._RPP/42._RPP ; c(1,2,1)=  153._RPP/140._RPP  ! stencil 1 !c(1,0,2)=    1._RPP/105._RPP; c(1,1,2)=  -19._RPP/210._RPP; c(1,2,2)=  107._RPP/210._RPP  ! stencil 2 !c(1,0,3)=   -1._RPP/140._RPP; c(1,1,3)=    5._RPP/84._RPP ; c(1,2,3)= -101._RPP/420._RPP  ! stencil 3 !c(1,0,4)=    1._RPP/105._RPP; c(1,1,4)=  -31._RPP/420._RPP; c(1,2,4)=  109._RPP/420._RPP  ! stencil 4 !c(1,0,5)=   -1._RPP/42._RPP ; c(1,1,5)=  -37._RPP/210._RPP; c(1,2,5)= -241._RPP/420._RPP  ! stencil 5 !c(1,0,6)=   -1._RPP/7._RPP  ; c(1,1,6)=  -43._RPP/42._RPP ; c(1,2,6)=  667._RPP/210._RPP  ! stencil 6 !!  cell  3                       cell  4                  ;    cell  5 !c(1,3,0)=  153._RPP/140._RPP; c(1,4,0)= -241._RPP/420._RPP; c(1,5,0)=   37._RPP/210._RPP  ! stencil 0 !c(1,3,1)= -241._RPP/420._RPP; c(1,4,1)=  109._RPP/420._RPP; c(1,5,1)=  -31._RPP/420._RPP  ! stencil 1 !c(1,3,2)=  319._RPP/420._RPP; c(1,4,2)= -101._RPP/420._RPP; c(1,5,2)=    5._RPP/84._RPP   ! stencil 2 !c(1,3,3)=  319._RPP/420._RPP; c(1,4,3)=  107._RPP/210._RPP; c(1,5,3)=  -19._RPP/210._RPP  ! stencil 3 !c(1,3,4)= -241._RPP/420._RPP; c(1,4,4)=  153._RPP/140._RPP; c(1,5,4)=   13._RPP/42._RPP   ! stencil 4 !c(1,3,5)=  153._RPP/140._RPP; c(1,4,5)= -197._RPP/140._RPP; c(1,5,5)=  223._RPP/140._RPP  ! stencil 5 !c(1,3,6)=-2341._RPP/420._RPP; c(1,4,6)=  853._RPP/140._RPP; c(1,5,6)= -617._RPP/140._RPP  ! stencil 6 !!  cell  6 !c(1,6,0)=   -1._RPP/42._RPP   ! stencil 0 !c(1,6,1)=    1._RPP/105._RPP  ! stencil 1 !c(1,6,2)=   -1._RPP/140._RPP  ! stencil 2 !c(1,6,3)=    1._RPP/105._RPP  ! stencil 3 !c(1,6,4)=   -1._RPP/42._RPP   ! stencil 4 !c(1,6,5)=    1._RPP/7._RPP    ! stencil 5 !c(1,6,6)=  363._RPP/140._RPP  ! stencil 6 !! 2 => right interface (i+1/2) !!  cell  0                  ;    cell  1                  ;    cell  2 !c(2,0,0)=  363._RPP/140._RPP; c(2,1,0)= -617._RPP/140._RPP; c(2,2,0)=  853._RPP/140._RPP  ! stencil 0 !c(2,0,1)=    1._RPP/7._RPP  ; c(2,1,1)=  223._RPP/140._RPP; c(2,2,1)= -197._RPP/140._RPP  ! stencil 1 !c(2,0,2)=   -1._RPP/42._RPP ; c(2,1,2)=   13._RPP/42._RPP ; c(2,2,2)=  153._RPP/140._RPP  ! stencil 2 !c(2,0,3)=    1._RPP/105._RPP; c(2,1,3)=  -19._RPP/210._RPP; c(2,2,3)=  107._RPP/210._RPP  ! stencil 3 !c(2,0,4)=   -1._RPP/140._RPP; c(2,1,4)=    5._RPP/84._RPP ; c(2,2,4)= -101._RPP/420._RPP  ! stencil 4 !c(2,0,5)=    1._RPP/105._RPP; c(2,1,5)=  -31._RPP/420._RPP; c(2,2,5)=  109._RPP/420._RPP  ! stencil 5 !c(2,0,6)=   -1._RPP/42._RPP ; c(2,1,6)=   37._RPP/210._RPP; c(2,2,6)= -241._RPP/420._RPP  ! stencil 6 !!  cell  3                  ;    cell  4                  ;    cell  5 !c(2,3,0)=-2341._RPP/420._RPP; c(2,4,0)=  667._RPP/210._RPP; c(2,5,0)=  -43._RPP/42._RPP   ! stencil 0 !c(2,3,1)=  153._RPP/140._RPP; c(2,4,1)= -241._RPP/420._RPP; c(2,5,1)=   37._RPP/210._RPP  ! stencil 1 !c(2,3,2)= -241._RPP/420._RPP; c(2,4,2)=  109._RPP/420._RPP; c(2,5,2)=  -31._RPP/420._RPP  ! stencil 2 !c(2,3,3)=  319._RPP/420._RPP; c(2,4,3)= -101._RPP/420._RPP; c(2,5,3)=    5._RPP/84._RPP   ! stencil 3 !c(2,3,4)=  319._RPP/420._RPP; c(2,4,4)=  107._RPP/210._RPP; c(2,5,4)=  -19._RPP/210._RPP  ! stencil 4 !c(2,3,5)= -241._RPP/420._RPP; c(2,4,5)=  153._RPP/140._RPP; c(2,5,5)=   13._RPP/42._RPP   ! stencil 5 !c(2,3,6)=  153._RPP/140._RPP; c(2,4,6)= -197._RPP/140._RPP; c(2,5,6)=  223._RPP/140._RPP  ! stencil 6 !!  cell  6 !c(2,6,0)=    1._RPP/7._RPP    ! stencil 0 !c(2,6,1)=   -1._RPP/42._RPP   ! stencil 1 !c(2,6,2)=    1._RPP/105._RPP  ! stencil 2 !c(2,6,3)=   -1._RPP/140._RPP  ! stencil 3 !c(2,6,4)=    1._RPP/105._RPP  ! stencil 4 !c(2,6,5)=   -1._RPP/42._RPP   ! stencil 5 !c(2,6,6)=    1._RPP/7._RPP    ! stencil 6 ! 1 => left interface (i-1/2) c ( 1 , 0 , 6 ) = 6 0._RPP / 42 0._RPP ; c ( 1 , 0 , 5 ) =- 1 0._RPP / 42 0._RPP ; c ( 1 , 0 , 4 ) = 4._RPP / 42 0._RPP ; c ( 1 , 0 , 3 ) =- 3._RPP / 42 0._RPP c ( 1 , 1 , 6 ) =- 43 0._RPP / 42 0._RPP ; c ( 1 , 1 , 5 ) = 7 4._RPP / 42 0._RPP ; c ( 1 , 1 , 4 ) =- 3 1._RPP / 42 0._RPP ; c ( 1 , 1 , 3 ) = 2 5._RPP / 42 0._RPP c ( 1 , 2 , 6 ) = 133 4._RPP / 42 0._RPP ; c ( 1 , 2 , 5 ) =- 24 1._RPP / 42 0._RPP ; c ( 1 , 2 , 4 ) = 10 9._RPP / 42 0._RPP ; c ( 1 , 2 , 3 ) =- 10 1._RPP / 42 0._RPP c ( 1 , 3 , 6 ) =- 234 1._RPP / 42 0._RPP ; c ( 1 , 3 , 5 ) = 45 9._RPP / 42 0._RPP ; c ( 1 , 3 , 4 ) =- 24 1._RPP / 42 0._RPP ; c ( 1 , 3 , 3 ) = 31 9._RPP / 42 0._RPP c ( 1 , 4 , 6 ) = 255 9._RPP / 42 0._RPP ; c ( 1 , 4 , 5 ) =- 59 1._RPP / 42 0._RPP ; c ( 1 , 4 , 4 ) = 45 9._RPP / 42 0._RPP ; c ( 1 , 4 , 3 ) = 21 4._RPP / 42 0._RPP c ( 1 , 5 , 6 ) =- 185 1._RPP / 42 0._RPP ; c ( 1 , 5 , 5 ) = 66 9._RPP / 42 0._RPP ; c ( 1 , 5 , 4 ) = 13 0._RPP / 42 0._RPP ; c ( 1 , 5 , 3 ) =- 3 8._RPP / 42 0._RPP c ( 1 , 6 , 6 ) = 108 9._RPP / 42 0._RPP ; c ( 1 , 6 , 5 ) = 6 0._RPP / 42 0._RPP ; c ( 1 , 6 , 4 ) =- 1 0._RPP / 42 0._RPP ; c ( 1 , 6 , 3 ) = 4._RPP / 42 0._RPP c ( 1 , 0 , 2 ) = 4._RPP / 42 0._RPP ; c ( 1 , 0 , 1 ) =- 1 0._RPP / 42 0._RPP ; c ( 1 , 0 , 0 ) = 6 0._RPP / 42 0._RPP c ( 1 , 1 , 2 ) =- 3 8._RPP / 42 0._RPP ; c ( 1 , 1 , 1 ) = 13 0._RPP / 42 0._RPP ; c ( 1 , 1 , 0 ) = 66 9._RPP / 42 0._RPP c ( 1 , 2 , 2 ) = 21 4._RPP / 42 0._RPP ; c ( 1 , 2 , 1 ) = 45 9._RPP / 42 0._RPP ; c ( 1 , 2 , 0 ) =- 59 1._RPP / 42 0._RPP c ( 1 , 3 , 2 ) = 31 9._RPP / 42 0._RPP ; c ( 1 , 3 , 1 ) =- 24 1._RPP / 42 0._RPP ; c ( 1 , 3 , 0 ) = 45 9._RPP / 42 0._RPP c ( 1 , 4 , 2 ) =- 10 1._RPP / 42 0._RPP ; c ( 1 , 4 , 1 ) = 10 9._RPP / 42 0._RPP ; c ( 1 , 4 , 0 ) =- 24 1._RPP / 42 0._RPP c ( 1 , 5 , 2 ) = 2 5._RPP / 42 0._RPP ; c ( 1 , 5 , 1 ) =- 3 1._RPP / 42 0._RPP ; c ( 1 , 5 , 0 ) = 7 4._RPP / 42 0._RPP c ( 1 , 6 , 2 ) =- 3._RPP / 42 0._RPP ; c ( 1 , 6 , 1 ) = 4._RPP / 42 0._RPP ; c ( 1 , 6 , 0 ) =- 1 0._RPP / 42 0._RPP ! 2 => right interface (i+1/2) c ( 2 , 6 , 0 ) = 6 0._RPP / 42 0._RPP ; c ( 2 , 6 , 1 ) =- 1 0._RPP / 42 0._RPP ; c ( 2 , 6 , 2 ) = 4._RPP / 42 0._RPP ; c ( 2 , 6 , 3 ) =- 3._RPP / 42 0._RPP c ( 2 , 5 , 0 ) =- 43 0._RPP / 42 0._RPP ; c ( 2 , 5 , 1 ) = 7 4._RPP / 42 0._RPP ; c ( 2 , 5 , 2 ) =- 3 1._RPP / 42 0._RPP ; c ( 2 , 5 , 3 ) = 2 5._RPP / 42 0._RPP c ( 2 , 4 , 0 ) = 133 4._RPP / 42 0._RPP ; c ( 2 , 4 , 1 ) =- 24 1._RPP / 42 0._RPP ; c ( 2 , 4 , 2 ) = 10 9._RPP / 42 0._RPP ; c ( 2 , 4 , 3 ) =- 10 1._RPP / 42 0._RPP c ( 2 , 3 , 0 ) =- 234 1._RPP / 42 0._RPP ; c ( 2 , 3 , 1 ) = 45 9._RPP / 42 0._RPP ; c ( 2 , 3 , 2 ) =- 24 1._RPP / 42 0._RPP ; c ( 2 , 3 , 3 ) = 31 9._RPP / 42 0._RPP c ( 2 , 2 , 0 ) = 255 9._RPP / 42 0._RPP ; c ( 2 , 2 , 1 ) =- 59 1._RPP / 42 0._RPP ; c ( 2 , 2 , 2 ) = 45 9._RPP / 42 0._RPP ; c ( 2 , 2 , 3 ) = 21 4._RPP / 42 0._RPP c ( 2 , 1 , 0 ) =- 185 1._RPP / 42 0._RPP ; c ( 2 , 1 , 1 ) = 66 9._RPP / 42 0._RPP ; c ( 2 , 1 , 2 ) = 13 0._RPP / 42 0._RPP ; c ( 2 , 1 , 3 ) =- 3 8._RPP / 42 0._RPP c ( 2 , 0 , 0 ) = 108 9._RPP / 42 0._RPP ; c ( 2 , 0 , 1 ) = 6 0._RPP / 42 0._RPP ; c ( 2 , 0 , 2 ) =- 1 0._RPP / 42 0._RPP ; c ( 2 , 0 , 3 ) = 4._RPP / 42 0._RPP c ( 2 , 6 , 4 ) = 4._RPP / 42 0._RPP ; c ( 2 , 6 , 5 ) =- 1 0._RPP / 42 0._RPP ; c ( 2 , 6 , 6 ) = 6 0._RPP / 42 0._RPP c ( 2 , 5 , 4 ) =- 3 8._RPP / 42 0._RPP ; c ( 2 , 5 , 5 ) = 13 0._RPP / 42 0._RPP ; c ( 2 , 5 , 6 ) = 66 9._RPP / 42 0._RPP c ( 2 , 4 , 4 ) = 21 4._RPP / 42 0._RPP ; c ( 2 , 4 , 5 ) = 45 9._RPP / 42 0._RPP ; c ( 2 , 4 , 6 ) =- 59 1._RPP / 42 0._RPP c ( 2 , 3 , 4 ) = 31 9._RPP / 42 0._RPP ; c ( 2 , 3 , 5 ) =- 24 1._RPP / 42 0._RPP ; c ( 2 , 3 , 6 ) = 45 9._RPP / 42 0._RPP c ( 2 , 2 , 4 ) =- 10 1._RPP / 42 0._RPP ; c ( 2 , 2 , 5 ) = 10 9._RPP / 42 0._RPP ; c ( 2 , 2 , 6 ) =- 24 1._RPP / 42 0._RPP c ( 2 , 1 , 4 ) = 2 5._RPP / 42 0._RPP ; c ( 2 , 1 , 5 ) =- 3 1._RPP / 42 0._RPP ; c ( 2 , 1 , 6 ) = 7 4._RPP / 42 0._RPP c ( 2 , 0 , 4 ) =- 3._RPP / 42 0._RPP ; c ( 2 , 0 , 5 ) = 4._RPP / 42 0._RPP ; c ( 2 , 0 , 6 ) =- 1 0._RPP / 42 0._RPP case ( 8 ) ! 15th order !! 1 => left interface (i-1/2) !!  cell  0                  ;    cell  1                  ;    cell  2 !c(1,0,0)=    7._RPP/56._RPP ; c(1,1,0)= 1443._RPP/840._RPP; c(1,2,0)=-1497._RPP/840._RPP  ! stencil 0 !c(1,0,1)=   -1._RPP/56._RPP ; c(1,1,1)=   15._RPP/56._RPP ; c(1,2,1)= 1023._RPP/840._RPP  ! stencil 1 !c(1,0,2)=    1._RPP/168._RPP; c(1,1,2)=  -11._RPP/168._RPP; c(1,2,2)=   73._RPP/168._RPP  ! stencil 2 !c(1,0,3)=   -3._RPP/840._RPP; c(1,1,3)=   29._RPP/840._RPP; c(1,2,3)= -139._RPP/840._RPP  ! stencil 3 !c(1,0,4)=    3._RPP/840._RPP; c(1,1,4)=  -27._RPP/840._RPP; c(1,2,4)=  113._RPP/840._RPP  ! stencil 4 !c(1,0,5)=   -1._RPP/168._RPP; c(1,1,5)=   43._RPP/840._RPP; c(1,2,5)= -167._RPP/840._RPP  ! stencil 5 !c(1,0,6)=    1._RPP/56._RPP ; c(1,1,6)=  -25._RPP/168._RPP; c(1,2,6)=  463._RPP/840._RPP  ! stencil 6 !c(1,0,7)=   -7._RPP/56._RPP ; c(1,1,7)=   57._RPP/56._RPP ; c(1,2,7)= -613._RPP/168._RPP  ! stencil 7 !!  cell  3                  ;    cell  4                  ;    cell  5 !c(1,3,0)= 1443._RPP/840._RPP; c(1,4,0)=-1007._RPP/840._RPP; c(1,5,0)=  463._RPP/840._RPP  ! stencil 0 !c(1,3,1)= -657._RPP/840._RPP; c(1,4,1)=  393._RPP/840._RPP; c(1,5,1)= -167._RPP/840._RPP  ! stencil 1 !c(1,3,2)=  743._RPP/840._RPP; c(1,4,2)= -307._RPP/840._RPP; c(1,5,2)=  113._RPP/840._RPP  ! stencil 2 !c(1,3,3)=  533._RPP/840._RPP; c(1,4,3)=  533._RPP/840._RPP; c(1,5,3)= -139._RPP/840._RPP  ! stencil 3 !c(1,3,4)= -307._RPP/840._RPP; c(1,4,4)=  743._RPP/840._RPP; c(1,5,4)=   73._RPP/168._RPP  ! stencil 4 !c(1,3,5)=  393._RPP/840._RPP; c(1,4,5)= -657._RPP/840._RPP; c(1,5,5)= 1023._RPP/840._RPP  ! stencil 5 !c(1,3,6)=-1007._RPP/840._RPP; c(1,4,6)= 1443._RPP/840._RPP; c(1,5,6)=-1497._RPP/840._RPP  ! stencil 6 !c(1,3,7)= 6343._RPP/840._RPP; c(1,4,7)=-8357._RPP/840._RPP; c(1,5,7)= 7323._RPP/840._RPP  ! stencil 7 !!  cell  6                  ;    cell  7 !c(1,6,0)=  -25._RPP/168._RPP; c(1,7,0)=    1._RPP/56._RPP   ! stencil 0 !c(1,6,1)=   43._RPP/840._RPP; c(1,7,1)=   -1._RPP/168._RPP  ! stencil 1 !c(1,6,2)=  -27._RPP/840._RPP; c(1,7,2)=    3._RPP/840._RPP  ! stencil 2 !c(1,6,3)=   29._RPP/840._RPP; c(1,7,3)=   -3._RPP/840._RPP  ! stencil 3 !c(1,6,4)=  -11._RPP/168._RPP; c(1,7,4)=    1._RPP/168._RPP  ! stencil 4 !c(1,6,5)=   15._RPP/56._RPP ; c(1,7,5)=   -1._RPP/56._RPP   ! stencil 5 !c(1,6,6)= 1443._RPP/840._RPP; c(1,7,6)=    7._RPP/56._RPP   ! stencil 6 !c(1,6,7)=-4437._RPP/840._RPP; c(1,7,7)= 2283._RPP/840._RPP  ! stencil 7 !! 2 => right interface (i+1/2) !!  cell  0                  ;    cell  1                  ;    cell  2 !c(2,0,0)= 2283._RPP/840._RPP; c(2,1,0)=-4437._RPP/840._RPP; c(2,2,0)= 7323._RPP/840._RPP  ! stencil 0 !c(2,0,1)=    7._RPP/56._RPP ; c(2,1,1)= 1443._RPP/840._RPP; c(2,2,1)=-1497._RPP/840._RPP  ! stencil 1 !c(2,0,2)=   -1._RPP/56._RPP ; c(2,1,2)=   15._RPP/56._RPP ; c(2,2,2)= 1023._RPP/840._RPP  ! stencil 2 !c(2,0,3)=    1._RPP/168._RPP; c(2,1,3)=  -11._RPP/168._RPP; c(2,2,3)=   73._RPP/168._RPP  ! stencil 3 !c(2,0,4)=   -3._RPP/840._RPP; c(2,1,4)=   29._RPP/840._RPP; c(2,2,4)= -139._RPP/840._RPP  ! stencil 4 !c(2,0,5)=    3._RPP/840._RPP; c(2,1,5)=  -27._RPP/840._RPP; c(2,2,5)=  113._RPP/840._RPP  ! stencil 5 !c(2,0,6)=   -1._RPP/168._RPP; c(2,1,6)=   43._RPP/840._RPP; c(2,2,6)= -167._RPP/840._RPP  ! stencil 6 !c(2,0,7)=    1._RPP/56._RPP ; c(2,1,7)=  -25._RPP/168._RPP; c(2,2,7)=  463._RPP/840._RPP  ! stencil 7 !!  cell  3                  ;    cell  4                  ;    cell  5 !c(2,3,0)=-8357._RPP/840._RPP; c(2,4,0)= 6343._RPP/840._RPP; c(2,5,0)= -613._RPP/168._RPP  ! stencil 0 !c(2,3,1)= 1443._RPP/840._RPP; c(2,4,1)=-1007._RPP/840._RPP; c(2,5,1)=  463._RPP/840._RPP  ! stencil 1 !c(2,3,2)= -657._RPP/840._RPP; c(2,4,2)=  393._RPP/840._RPP; c(2,5,2)= -167._RPP/840._RPP  ! stencil 2 !c(2,3,3)=  743._RPP/840._RPP; c(2,4,3)= -307._RPP/840._RPP; c(2,5,3)=  113._RPP/840._RPP  ! stencil 3 !c(2,3,4)=  533._RPP/840._RPP; c(2,4,4)=  533._RPP/840._RPP; c(2,5,4)= -139._RPP/840._RPP  ! stencil 4 !c(2,3,5)= -307._RPP/840._RPP; c(2,4,5)=  743._RPP/840._RPP; c(2,5,5)=   73._RPP/168._RPP  ! stencil 5 !c(2,3,6)=  393._RPP/840._RPP; c(2,4,6)= -657._RPP/840._RPP; c(2,5,6)= 1023._RPP/840._RPP  ! stencil 6 !c(2,3,7)=-1007._RPP/840._RPP; c(2,4,7)= 1443._RPP/840._RPP; c(2,5,7)=-1497._RPP/840._RPP  ! stencil 7 !!  cell  6                  ;    cell  7 !c(2,6,0)=   57._RPP/56._RPP ; c(2,7,0)=   -7._RPP/56._RPP   ! stencil 0 !c(2,6,1)=  -25._RPP/168._RPP; c(2,7,1)=    1._RPP/56._RPP   ! stencil 1 !c(2,6,2)=   43._RPP/840._RPP; c(2,7,2)=   -1._RPP/168._RPP  ! stencil 2 !c(2,6,3)=  -27._RPP/840._RPP; c(2,7,3)=    3._RPP/840._RPP  ! stencil 3 !c(2,6,4)=   29._RPP/840._RPP; c(2,7,4)=   -3._RPP/840._RPP  ! stencil 4 !c(2,6,5)=  -11._RPP/168._RPP; c(2,7,5)=    1._RPP/168._RPP  ! stencil 5 !c(2,6,6)=   15._RPP/56._RPP ; c(2,7,6)=   -1._RPP/56._RPP   ! stencil 6 !c(2,6,7)= 1443._RPP/840._RPP; c(2,7,7)=    7._RPP/56._RPP   ! stencil 7 ! 1 => left interface (i-1/2) c ( 1 , 0 , 7 ) =- 10 5._RPP / 84 0._RPP ; c ( 1 , 0 , 6 ) = 1 5._RPP / 84 0._RPP ; c ( 1 , 0 , 5 ) =- 5._RPP / 84 0._RPP ; c ( 1 , 0 , 4 ) = 3._RPP / 84 0._RPP c ( 1 , 1 , 7 ) = 85 5._RPP / 84 0._RPP ; c ( 1 , 1 , 6 ) =- 12 5._RPP / 84 0._RPP ; c ( 1 , 1 , 5 ) = 4 3._RPP / 84 0._RPP ; c ( 1 , 1 , 4 ) =- 2 7._RPP / 84 0._RPP c ( 1 , 2 , 7 ) =- 306 5._RPP / 84 0._RPP ; c ( 1 , 2 , 6 ) = 46 3._RPP / 84 0._RPP ; c ( 1 , 2 , 5 ) =- 16 7._RPP / 84 0._RPP ; c ( 1 , 2 , 4 ) = 11 3._RPP / 84 0._RPP c ( 1 , 3 , 7 ) = 634 3._RPP / 84 0._RPP ; c ( 1 , 3 , 6 ) =- 100 7._RPP / 84 0._RPP ; c ( 1 , 3 , 5 ) = 39 3._RPP / 84 0._RPP ; c ( 1 , 3 , 4 ) =- 30 7._RPP / 84 0._RPP c ( 1 , 4 , 7 ) =- 835 7._RPP / 84 0._RPP ; c ( 1 , 4 , 6 ) = 144 3._RPP / 84 0._RPP ; c ( 1 , 4 , 5 ) =- 65 7._RPP / 84 0._RPP ; c ( 1 , 4 , 4 ) = 74 3._RPP / 84 0._RPP c ( 1 , 5 , 7 ) = 732 3._RPP / 84 0._RPP ; c ( 1 , 5 , 6 ) =- 149 7._RPP / 84 0._RPP ; c ( 1 , 5 , 5 ) = 102 3._RPP / 84 0._RPP ; c ( 1 , 5 , 4 ) = 36 5._RPP / 84 0._RPP c ( 1 , 6 , 7 ) =- 443 7._RPP / 84 0._RPP ; c ( 1 , 6 , 6 ) = 144 3._RPP / 84 0._RPP ; c ( 1 , 6 , 5 ) = 22 5._RPP / 84 0._RPP ; c ( 1 , 6 , 4 ) =- 5 5._RPP / 84 0._RPP c ( 1 , 7 , 7 ) = 228 3._RPP / 84 0._RPP ; c ( 1 , 7 , 6 ) = 10 5._RPP / 84 0._RPP ; c ( 1 , 7 , 5 ) =- 1 5._RPP / 84 0._RPP ; c ( 1 , 7 , 4 ) = 5._RPP / 84 0._RPP c ( 1 , 0 , 3 ) =- 3._RPP / 84 0._RPP ; c ( 1 , 0 , 2 ) = 5._RPP / 84 0._RPP ; c ( 1 , 0 , 1 ) =- 1 5._RPP / 84 0._RPP ; c ( 1 , 0 , 0 ) = 10 5._RPP / 84 0._RPP c ( 1 , 1 , 3 ) = 2 9._RPP / 84 0._RPP ; c ( 1 , 1 , 2 ) =- 5 5._RPP / 84 0._RPP ; c ( 1 , 1 , 1 ) = 22 5._RPP / 84 0._RPP ; c ( 1 , 1 , 0 ) = 144 3._RPP / 84 0._RPP c ( 1 , 2 , 3 ) =- 13 9._RPP / 84 0._RPP ; c ( 1 , 2 , 2 ) = 36 5._RPP / 84 0._RPP ; c ( 1 , 2 , 1 ) = 102 3._RPP / 84 0._RPP ; c ( 1 , 2 , 0 ) =- 149 7._RPP / 84 0._RPP c ( 1 , 3 , 3 ) = 53 3._RPP / 84 0._RPP ; c ( 1 , 3 , 2 ) = 74 3._RPP / 84 0._RPP ; c ( 1 , 3 , 1 ) =- 65 7._RPP / 84 0._RPP ; c ( 1 , 3 , 0 ) = 144 3._RPP / 84 0._RPP c ( 1 , 4 , 3 ) = 53 3._RPP / 84 0._RPP ; c ( 1 , 4 , 2 ) =- 30 7._RPP / 84 0._RPP ; c ( 1 , 4 , 1 ) = 39 3._RPP / 84 0._RPP ; c ( 1 , 4 , 0 ) =- 100 7._RPP / 84 0._RPP c ( 1 , 5 , 3 ) =- 13 9._RPP / 84 0._RPP ; c ( 1 , 5 , 2 ) = 11 3._RPP / 84 0._RPP ; c ( 1 , 5 , 1 ) =- 16 7._RPP / 84 0._RPP ; c ( 1 , 5 , 0 ) = 46 3._RPP / 84 0._RPP c ( 1 , 6 , 3 ) = 2 9._RPP / 84 0._RPP ; c ( 1 , 6 , 2 ) =- 2 7._RPP / 84 0._RPP ; c ( 1 , 6 , 1 ) = 4 3._RPP / 84 0._RPP ; c ( 1 , 6 , 0 ) =- 12 5._RPP / 84 0._RPP c ( 1 , 7 , 3 ) =- 3._RPP / 84 0._RPP ; c ( 1 , 7 , 2 ) = 3._RPP / 84 0._RPP ; c ( 1 , 7 , 1 ) =- 5._RPP / 84 0._RPP ; c ( 1 , 7 , 0 ) = 1 5._RPP / 840 _ RPP ! 2 => right interface (i+1/2) c ( 2 , 7 , 0 ) =- 10 5._RPP / 84 0._RPP ; c ( 2 , 7 , 1 ) = 1 5._RPP / 84 0._RPP ; c ( 2 , 7 , 2 ) =- 5._RPP / 84 0._RPP ; c ( 2 , 7 , 3 ) = 3._RPP / 84 0._RPP c ( 2 , 6 , 0 ) = 85 5._RPP / 84 0._RPP ; c ( 2 , 6 , 1 ) =- 12 5._RPP / 84 0._RPP ; c ( 2 , 6 , 2 ) = 4 3._RPP / 84 0._RPP ; c ( 2 , 6 , 3 ) =- 2 7._RPP / 84 0._RPP c ( 2 , 5 , 0 ) =- 306 5._RPP / 84 0._RPP ; c ( 2 , 5 , 1 ) = 46 3._RPP / 84 0._RPP ; c ( 2 , 5 , 2 ) =- 16 7._RPP / 84 0._RPP ; c ( 2 , 5 , 3 ) = 11 3._RPP / 84 0._RPP c ( 2 , 4 , 0 ) = 634 3._RPP / 84 0._RPP ; c ( 2 , 4 , 1 ) =- 100 7._RPP / 84 0._RPP ; c ( 2 , 4 , 2 ) = 39 3._RPP / 84 0._RPP ; c ( 2 , 4 , 3 ) =- 30 7._RPP / 84 0._RPP c ( 2 , 3 , 0 ) =- 835 7._RPP / 84 0._RPP ; c ( 2 , 3 , 1 ) = 144 3._RPP / 84 0._RPP ; c ( 2 , 3 , 2 ) =- 65 7._RPP / 84 0._RPP ; c ( 2 , 3 , 3 ) = 74 3._RPP / 84 0._RPP c ( 2 , 2 , 0 ) = 732 3._RPP / 84 0._RPP ; c ( 2 , 2 , 1 ) =- 149 7._RPP / 84 0._RPP ; c ( 2 , 2 , 2 ) = 102 3._RPP / 84 0._RPP ; c ( 2 , 2 , 3 ) = 36 5._RPP / 84 0._RPP c ( 2 , 1 , 0 ) =- 443 7._RPP / 84 0._RPP ; c ( 2 , 1 , 1 ) = 144 3._RPP / 84 0._RPP ; c ( 2 , 1 , 2 ) = 22 5._RPP / 84 0._RPP ; c ( 2 , 1 , 3 ) =- 5 5._RPP / 84 0._RPP c ( 2 , 0 , 0 ) = 228 3._RPP / 84 0._RPP ; c ( 2 , 0 , 1 ) = 10 5._RPP / 84 0._RPP ; c ( 2 , 0 , 2 ) =- 1 5._RPP / 84 0._RPP ; c ( 2 , 0 , 3 ) = 5._RPP / 84 0._RPP c ( 2 , 7 , 4 ) =- 3._RPP / 84 0._RPP ; c ( 2 , 7 , 5 ) = 5._RPP / 84 0._RPP ; c ( 2 , 7 , 6 ) =- 1 5._RPP / 84 0._RPP ; c ( 2 , 7 , 7 ) = 10 5._RPP / 84 0._RPP c ( 2 , 6 , 4 ) = 2 9._RPP / 84 0._RPP ; c ( 2 , 6 , 5 ) =- 5 5._RPP / 84 0._RPP ; c ( 2 , 6 , 6 ) = 22 5._RPP / 84 0._RPP ; c ( 2 , 6 , 7 ) = 144 3._RPP / 84 0._RPP c ( 2 , 5 , 4 ) =- 13 9._RPP / 84 0._RPP ; c ( 2 , 5 , 5 ) = 36 5._RPP / 84 0._RPP ; c ( 2 , 5 , 6 ) = 102 3._RPP / 84 0._RPP ; c ( 2 , 5 , 7 ) =- 149 7._RPP / 84 0._RPP c ( 2 , 4 , 4 ) = 53 3._RPP / 84 0._RPP ; c ( 2 , 4 , 5 ) = 74 3._RPP / 84 0._RPP ; c ( 2 , 4 , 6 ) =- 65 7._RPP / 84 0._RPP ; c ( 2 , 4 , 7 ) = 144 3._RPP / 84 0._RPP c ( 2 , 3 , 4 ) = 53 3._RPP / 84 0._RPP ; c ( 2 , 3 , 5 ) =- 30 7._RPP / 84 0._RPP ; c ( 2 , 3 , 6 ) = 39 3._RPP / 84 0._RPP ; c ( 2 , 3 , 7 ) =- 100 7._RPP / 84 0._RPP c ( 2 , 2 , 4 ) =- 13 9._RPP / 84 0._RPP ; c ( 2 , 2 , 5 ) = 11 3._RPP / 84 0._RPP ; c ( 2 , 2 , 6 ) =- 16 7._RPP / 84 0._RPP ; c ( 2 , 2 , 7 ) = 46 3._RPP / 84 0._RPP c ( 2 , 1 , 4 ) = 2 9._RPP / 84 0._RPP ; c ( 2 , 1 , 5 ) =- 2 7._RPP / 84 0._RPP ; c ( 2 , 1 , 6 ) = 4 3._RPP / 84 0._RPP ; c ( 2 , 1 , 7 ) =- 12 5._RPP / 84 0._RPP c ( 2 , 0 , 4 ) =- 3._RPP / 84 0._RPP ; c ( 2 , 0 , 5 ) = 3._RPP / 84 0._RPP ; c ( 2 , 0 , 6 ) =- 5._RPP / 84 0._RPP ; c ( 2 , 0 , 7 ) = 1 5._RPP / 840 _ RPP case ( 9 ) ! 17th order ! 1 => left interface (i-1/2) !  cell  0                    ;     cell  1                   ;     cell  2 !c(1,0,0)=     1._RPP/9._RPP   ; c(1,1,0)=  4609._RPP/2520._RPP; c(1,2,0)= -5471._RPP/2520._RPP  ! stencil 0 !c(1,0,1)=    -7._RPP/504._RPP ; c(1,1,1)=   119._RPP/508._RPP ; c(1,2,1)=  3349._RPP/2520._RPP  ! stencil 1 !c(1,0,2)=     1._RPP/252._RPP ; c(1,1,2)=   -25._RPP/508._RPP ; c(1,2,2)=   191._RPP/504._RPP   ! stencil 2 !c(1,0,3)=    -1._RPP/504._RPP ; c(1,1,3)=    11._RPP/508._RPP ; c(1,2,3)=   -61._RPP/504._RPP   ! stencil 3 !c(1,0,4)=     1._RPP/630._RPP ; c(1,1,4)=   -41._RPP/2520._RPP; c(1,2,4)=   199._RPP/2520._RPP  ! stencil 4 !c(1,0,5)=    -1._RPP/504._RPP ; c(1,1,5)=    49._RPP/2520._RPP; c(1,2,5)=  -221._RPP/2520._RPP  ! stencil 5 !c(1,0,6)=     1._RPP/252._RPP ; c(1,1,6)=   -19._RPP/508._RPP ; c(1,2,6)=   409._RPP/2520._RPP  ! stencil 6 !c(1,0,7)=    -7._RPP/504._RPP ; c(1,1,7)=    65._RPP/508._RPP ; c(1,2,7)=  -271._RPP/504._RPP   ! stencil 7 !c(1,0,8)=     1._RPP/9._RPP   ; c(1,1,8)=  -511._RPP/508._RPP ; c(1,2,8)=  2081._RPP/504._RPP   ! stencil 8 !!  cell  3                    ;    cell  4                    ;     cell  5 !c(1,3,0)=  6289._RPP/2520._RPP; c(1,4,0)= -5471._RPP/2520._RPP; c(1,5,0)=  3349._RPP/2520._RPP  ! stencil 0 !c(1,3,1)= -2531._RPP/2520._RPP; c(1,4,1)=  1879._RPP/2520._RPP; c(1,5,1)= -1061._RPP/2520._RPP  ! stencil 1 !c(1,3,2)=  2509._RPP/2520._RPP; c(1,4,2)= -1271._RPP/2520._RPP; c(1,5,2)=   619._RPP/2520._RPP  ! stencil 2 !c(1,3,3)=   275._RPP/504._RPP ; c(1,4,3)=  1879._RPP/2520._RPP; c(1,5,3)=  -641._RPP/2520._RPP  ! stencil 3 !c(1,3,4)=  -641._RPP/2520._RPP; c(1,4,4)=  1879._RPP/2520._RPP; c(1,5,4)=   275._RPP/504._RPP   ! stencil 4 !c(1,3,5)=   619._RPP/2520._RPP; c(1,4,5)= -1271._RPP/2520._RPP; c(1,5,5)=  2509._RPP/2520._RPP  ! stencil 5 !c(1,3,6)= -1061._RPP/2520._RPP; c(1,4,6)=  1879._RPP/2520._RPP; c(1,5,6)= -2531._RPP/2520._RPP  ! stencil 6 !c(1,3,7)=  3349._RPP/2520._RPP; c(1,4,7)= -5471._RPP/2520._RPP; c(1,5,7)=  6289._RPP/2520._RPP  ! stencil 7 !c(1,3,8)= -4975._RPP/504._RPP ; c(1,4,8)= 38629._RPP/2520._RPP; c(1,5,8)=-40751._RPP/2520._RPP  ! stencil 8 !!   cell  6                   ;     cell  7                   ;     cell  8 !c(1,6,0)=  -271._RPP/504._RPP ; c(1,7,0)=    65._RPP/504._RPP ; c(1,8,0)=    -1._RPP/72._RPP    ! stencil 0 !c(1,6,1)=   409._RPP/2520._RPP; c(1,7,1)=    19._RPP/504._RPP ; c(1,8,1)=     1._RPP/252._RPP   ! stencil 1 !c(1,6,2)=  -221._RPP/2520._RPP; c(1,7,2)=    49._RPP/2520._RPP; c(1,8,2)=    -1._RPP/504._RPP   ! stencil 2 !c(1,6,3)=   199._RPP/2520._RPP; c(1,7,3)=   -41._RPP/2520._RPP; c(1,8,3)=     1._RPP/630._RPP   ! stencil 3 !c(1,6,4)=   -61._RPP/504._RPP ; c(1,7,4)=    11._RPP/504._RPP ; c(1,8,4)=    -1._RPP/504._RPP   ! stencil 4 !c(1,6,5)=   955._RPP/2520._RPP; c(1,7,5)=   -25._RPP/504._RPP ; c(1,8,5)=     1._RPP/252._RPP   ! stencil 5 !c(1,6,6)=  3349._RPP/2520._RPP; c(1,7,6)=   119._RPP/504._RPP ; c(1,8,6)=     -1._RPP/72._RPP   ! stencil 6 !c(1,6,7)= -5471._RPP/2520._RPP; c(1,7,7)=  4609._RPP/2520._RPP; c(1,8,7)=      7._RPP/63._RPP   ! stencil 7 !c(1,6,8)= 29809._RPP/2520._RPP; c(1,7,8)=-15551._RPP/2520._RPP; c(1,8,8)=   7129._RPP/2520._RPP ! stencil 8 !! 2 => right interface (i+1/2) !!  cell  0                    ;     cell  1                   ;     cell  2 !c(2,0,0)=  7129._RPP/2520._RPP; c(2,1,0)=-15551._RPP/2520._RPP; c(2,2,0)= 29809._RPP/2520._RPP  ! stencil 0 !c(2,0,1)=     7._RPP/63._RPP  ; c(2,1,1)=  4609._RPP/2520._RPP; c(2,2,1)= -5471._RPP/2520._RPP  ! stencil 1 !c(2,0,2)=    -1._RPP/72._RPP  ; c(2,1,2)=   119._RPP/504._RPP ; c(2,2,2)=  3349._RPP/2520._RPP  ! stencil 2 !c(2,0,3)=    1._RPP/252._RPP  ; c(2,1,3)=   -25._RPP/504._RPP ; c(2,2,3)=   955._RPP/2520._RPP  ! stencil 3 !c(2,0,4)=   -1._RPP/504._RPP  ; c(2,1,4)=    11._RPP/504._RPP ; c(2,2,4)=   -61._RPP/504._RPP   ! stencil 4 !c(2,0,5)=    1._RPP/630._RPP  ; c(2,1,5)=   -41._RPP/2520._RPP; c(2,2,5)=   199._RPP/2520._RPP  ! stencil 5 !c(2,0,6)=   -1._RPP/504._RPP  ; c(2,1,6)=    49._RPP/2520._RPP; c(2,2,6)=  -221._RPP/2520._RPP  ! stencil 6 !c(2,0,7)=    1._RPP/252._RPP  ; c(2,1,7)=    19._RPP/504._RPP ; c(2,2,7)=   409._RPP/2520._RPP  ! stencil 7 !c(2,0,8)=   -1._RPP/72._RPP   ; c(2,1,8)=    65._RPP/504._RPP ; c(2,2,8)=  -271._RPP/504._RPP   ! stencil 8 !!   cell  3                   ; !  cell  4                    ;     cell  5 !c(2,3,0)=-40751._RPP/2520._RPP; c(2,4,0)= 38629._RPP/2520._RPP; c(2,5,0)= -4975._RPP/504._RPP   ! stencil 0 !c(2,3,1)=  6289._RPP/2520._RPP; c(2,4,1)= -5471._RPP/2520._RPP; c(2,5,1)=  3349._RPP/2520._RPP  ! stencil 1 !c(2,3,2)= -2531._RPP/2520._RPP; c(2,4,2)=  1879._RPP/2520._RPP; c(2,5,2)= -1061._RPP/2520._RPP  ! stencil 2 !c(2,3,3)=  2509._RPP/2520._RPP; c(2,4,3)= -1271._RPP/2520._RPP; c(2,5,3)=   619._RPP/2520._RPP  ! stencil 3 !c(2,3,4)=   275._RPP/504._RPP ; c(2,4,4)=  1879._RPP/2520._RPP; c(2,5,4)=  -641._RPP/2520._RPP  ! stencil 4 !c(2,3,5)=  -641._RPP/2520._RPP; c(2,4,5)=  1879._RPP/2520._RPP; c(2,5,5)=   275._RPP/504._RPP   ! stencil 5 !c(2,3,6)=   619._RPP/2520._RPP; c(2,4,6)= -1271._RPP/2520._RPP; c(2,5,6)=  2509._RPP/2520._RPP  ! stencil 6 !c(2,3,7)= -1061._RPP/2520._RPP; c(2,4,7)=  1879._RPP/2520._RPP; c(2,5,7)= -2531._RPP/2520._RPP  ! stencil 7 !c(2,3,8)=  3349._RPP/2520._RPP; c(2,4,8)= -5471._RPP/2520._RPP; c(2,5,8)=  6289._RPP/2520._RPP  ! stencil 8 !!   cell  6                   ;     cell  7                   ;     cell  8 !c(2,6,0)=  2081._RPP/504._RPP ; c(2,7,0)=  -511._RPP/508._RPP ; c(2,8,0)=     1._RPP/9._RPP     ! stencil 0 !c(2,6,1)=  -271._RPP/504._RPP ; c(2,7,1)=    65._RPP/508._RPP ; c(2,8,1)=    -7._RPP/504._RPP   ! stencil 1 !c(2,6,2)=   409._RPP/2520._RPP; c(2,7,2)=   -19._RPP/508._RPP ; c(2,8,2)=     1._RPP/252._RPP   ! stencil 2 !c(2,6,3)=  -221._RPP/2520._RPP; c(2,7,3)=    49._RPP/2520._RPP; c(2,8,3)=    -1._RPP/504._RPP   ! stencil 3 !c(2,6,4)=   199._RPP/2520._RPP; c(2,7,4)=   -41._RPP/2520._RPP; c(2,8,4)=     1._RPP/630._RPP   ! stencil 4 !c(2,6,5)=   -61._RPP/504._RPP ; c(2,7,5)=    11._RPP/508._RPP ; c(2,8,5)=    -1._RPP/504._RPP   ! stencil 5 !c(2,6,6)=   191._RPP/504._RPP ; c(2,7,6)=   -25._RPP/508._RPP ; c(2,8,6)=     1._RPP/252._RPP   ! stencil 6 !c(2,6,7)=  3349._RPP/2520._RPP; c(2,7,7)=   119._RPP/508._RPP ; c(2,8,7)=    -7._RPP/504._RPP   ! stencil 7 !c(2,6,8)= -5471._RPP/2520._RPP; c(2,7,8)=  4609._RPP/2520._RPP; c(2,8,8)=     1._RPP/9._RPP     ! stencil 8 ! 1 => left interface (i-1/2) c ( 1 , 0 , 8 ) = 28 0._RPP / 252 0._RPP ; c ( 1 , 0 , 7 ) =- 3 5._RPP / 252 0._RPP ; c ( 1 , 0 , 6 ) = 1 0._RPP / 252 0._RPP c ( 1 , 1 , 8 ) =- 255 5._RPP / 252 0._RPP ; c ( 1 , 1 , 7 ) = 32 5._RPP / 252 0._RPP ; c ( 1 , 1 , 6 ) =- 9 5._RPP / 252 0._RPP c ( 1 , 2 , 8 ) = 1040 5._RPP / 252 0._RPP ; c ( 1 , 2 , 7 ) =- 135 5._RPP / 252 0._RPP ; c ( 1 , 2 , 6 ) = 40 9._RPP / 252 0._RPP c ( 1 , 3 , 8 ) =- 2487 5._RPP / 252 0._RPP ; c ( 1 , 3 , 7 ) = 334 9._RPP / 252 0._RPP ; c ( 1 , 3 , 6 ) =- 106 1._RPP / 252 0._RPP c ( 1 , 4 , 8 ) = 3862 9._RPP / 252 0._RPP ; c ( 1 , 4 , 7 ) =- 547 1._RPP / 252 0._RPP ; c ( 1 , 4 , 6 ) = 187 9._RPP / 252 0._RPP c ( 1 , 5 , 8 ) =- 4075 1._RPP / 252 0._RPP ; c ( 1 , 5 , 7 ) = 628 9._RPP / 252 0._RPP ; c ( 1 , 5 , 6 ) =- 253 1._RPP / 252 0._RPP c ( 1 , 6 , 8 ) = 2980 9._RPP / 252 0._RPP ; c ( 1 , 6 , 7 ) =- 547 1._RPP / 252 0._RPP ; c ( 1 , 6 , 6 ) = 334 9._RPP / 252 0._RPP c ( 1 , 7 , 8 ) =- 1555 1._RPP / 252 0._RPP ; c ( 1 , 7 , 7 ) = 460 9._RPP / 252 0._RPP ; c ( 1 , 7 , 6 ) = 59 5._RPP / 252 0._RPP c ( 1 , 8 , 8 ) = 712 9._RPP / 252 0._RPP ; c ( 1 , 8 , 7 ) = 28 0._RPP / 252 0._RPP ; c ( 1 , 8 , 6 ) =- 3 5._RPP / 252 0._RPP c ( 1 , 0 , 5 ) =- 5._RPP / 252 0._RPP ; c ( 1 , 0 , 4 ) = 4._RPP / 252 0._RPP ; c ( 1 , 0 , 3 ) =- 5._RPP / 252 0._RPP c ( 1 , 1 , 5 ) = 4 9._RPP / 252 0._RPP ; c ( 1 , 1 , 4 ) =- 4 1._RPP / 252 0._RPP ; c ( 1 , 1 , 3 ) = 5 5._RPP / 252 0._RPP c ( 1 , 2 , 5 ) =- 22 1._RPP / 252 0._RPP ; c ( 1 , 2 , 4 ) = 19 9._RPP / 252 0._RPP ; c ( 1 , 2 , 3 ) =- 30 5._RPP / 252 0._RPP c ( 1 , 3 , 5 ) = 61 9._RPP / 252 0._RPP ; c ( 1 , 3 , 4 ) =- 64 1._RPP / 252 0._RPP ; c ( 1 , 3 , 3 ) = 137 5._RPP / 252 0._RPP c ( 1 , 4 , 5 ) =- 127 1._RPP / 252 0._RPP ; c ( 1 , 4 , 4 ) = 187 9._RPP / 252 0._RPP ; c ( 1 , 4 , 3 ) = 187 9._RPP / 252 0._RPP c ( 1 , 5 , 5 ) = 250 9._RPP / 252 0._RPP ; c ( 1 , 5 , 4 ) = 137 5._RPP / 252 0._RPP ; c ( 1 , 5 , 3 ) =- 64 1._RPP / 252 0._RPP c ( 1 , 6 , 5 ) = 95 5._RPP / 252 0._RPP ; c ( 1 , 6 , 4 ) =- 30 5._RPP / 252 0._RPP ; c ( 1 , 6 , 3 ) = 19 9._RPP / 252 0._RPP c ( 1 , 7 , 5 ) =- 12 5._RPP / 252 0._RPP ; c ( 1 , 7 , 4 ) = 5 5._RPP / 252 0._RPP ; c ( 1 , 7 , 3 ) =- 4 1._RPP / 252 0._RPP c ( 1 , 8 , 5 ) = 1 0._RPP / 252 0._RPP ; c ( 1 , 8 , 4 ) =- 5._RPP / 252 0._RPP ; c ( 1 , 8 , 3 ) = 4._RPP / 252 0._RPP c ( 1 , 0 , 2 ) = 1 0._RPP / 252 0._RPP ; c ( 1 , 0 , 1 ) =- 3 5._RPP / 252 0._RPP ; c ( 1 , 0 , 0 ) = 28 0._RPP / 252 0._RPP c ( 1 , 1 , 2 ) =- 12 5._RPP / 252 0._RPP ; c ( 1 , 1 , 1 ) = 59 5._RPP / 252 0._RPP ; c ( 1 , 1 , 0 ) = 460 9._RPP / 252 0._RPP c ( 1 , 2 , 2 ) = 95 5._RPP / 252 0._RPP ; c ( 1 , 2 , 1 ) = 334 9._RPP / 252 0._RPP ; c ( 1 , 2 , 0 ) =- 547 1._RPP / 252 0._RPP c ( 1 , 3 , 2 ) = 250 9._RPP / 252 0._RPP ; c ( 1 , 3 , 1 ) =- 253 1._RPP / 252 0._RPP ; c ( 1 , 3 , 0 ) = 628 9._RPP / 252 0._RPP c ( 1 , 4 , 2 ) =- 127 1._RPP / 252 0._RPP ; c ( 1 , 4 , 1 ) = 187 9._RPP / 252 0._RPP ; c ( 1 , 4 , 0 ) =- 547 1._RPP / 252 0._RPP c ( 1 , 5 , 2 ) = 61 9._RPP / 252 0._RPP ; c ( 1 , 5 , 1 ) =- 106 1._RPP / 252 0._RPP ; c ( 1 , 5 , 0 ) = 334 9._RPP / 252 0._RPP c ( 1 , 6 , 2 ) =- 22 1._RPP / 252 0._RPP ; c ( 1 , 6 , 1 ) = 40 9._RPP / 252 0._RPP ; c ( 1 , 6 , 0 ) =- 135 5._RPP / 252 0._RPP c ( 1 , 7 , 2 ) = 4 9._RPP / 252 0._RPP ; c ( 1 , 7 , 1 ) =- 9 5._RPP / 252 0._RPP ; c ( 1 , 7 , 0 ) = 32 5._RPP / 252 0._RPP c ( 1 , 8 , 2 ) =- 5._RPP / 252 0._RPP ; c ( 1 , 8 , 1 ) = 1 0._RPP / 252 0._RPP ; c ( 1 , 8 , 0 ) =- 3 5._RPP / 252 0._RPP ! 2 => right interface (i+1/2) c ( 2 , 8 , 0 ) = 28 0._RPP / 252 0._RPP ; c ( 2 , 8 , 1 ) =- 3 5._RPP / 252 0._RPP ; c ( 2 , 8 , 2 ) = 1 0._RPP / 252 0._RPP c ( 2 , 7 , 0 ) =- 255 5._RPP / 252 0._RPP ; c ( 2 , 7 , 1 ) = 32 5._RPP / 252 0._RPP ; c ( 2 , 7 , 2 ) =- 9 5._RPP / 252 0._RPP c ( 2 , 6 , 0 ) = 1040 5._RPP / 252 0._RPP ; c ( 2 , 6 , 1 ) =- 135 5._RPP / 252 0._RPP ; c ( 2 , 6 , 2 ) = 40 9._RPP / 252 0._RPP c ( 2 , 5 , 0 ) =- 2487 5._RPP / 252 0._RPP ; c ( 2 , 5 , 1 ) = 334 9._RPP / 252 0._RPP ; c ( 2 , 5 , 2 ) =- 106 1._RPP / 252 0._RPP c ( 2 , 4 , 0 ) = 3862 9._RPP / 252 0._RPP ; c ( 2 , 4 , 1 ) =- 547 1._RPP / 252 0._RPP ; c ( 2 , 4 , 2 ) = 187 9._RPP / 252 0._RPP c ( 2 , 3 , 0 ) =- 4075 1._RPP / 252 0._RPP ; c ( 2 , 3 , 1 ) = 628 9._RPP / 252 0._RPP ; c ( 2 , 3 , 2 ) =- 253 1._RPP / 252 0._RPP c ( 2 , 2 , 0 ) = 2980 9._RPP / 252 0._RPP ; c ( 2 , 2 , 1 ) =- 547 1._RPP / 252 0._RPP ; c ( 2 , 2 , 2 ) = 334 9._RPP / 252 0._RPP c ( 2 , 1 , 0 ) =- 1555 1._RPP / 252 0._RPP ; c ( 2 , 1 , 1 ) = 460 9._RPP / 252 0._RPP ; c ( 2 , 1 , 2 ) = 59 5._RPP / 252 0._RPP c ( 2 , 0 , 0 ) = 712 9._RPP / 252 0._RPP ; c ( 2 , 0 , 1 ) = 28 0._RPP / 252 0._RPP ; c ( 2 , 0 , 2 ) =- 3 5._RPP / 252 0._RPP c ( 2 , 8 , 3 ) =- 5._RPP / 252 0._RPP ; c ( 2 , 8 , 4 ) = 4._RPP / 252 0._RPP ; c ( 2 , 8 , 5 ) =- 5._RPP / 252 0._RPP c ( 2 , 7 , 3 ) = 4 9._RPP / 252 0._RPP ; c ( 2 , 7 , 4 ) =- 4 1._RPP / 252 0._RPP ; c ( 2 , 7 , 5 ) = 5 5._RPP / 252 0._RPP c ( 2 , 6 , 3 ) =- 22 1._RPP / 252 0._RPP ; c ( 2 , 6 , 4 ) = 19 9._RPP / 252 0._RPP ; c ( 2 , 6 , 5 ) =- 30 5._RPP / 252 0._RPP c ( 2 , 5 , 3 ) = 61 9._RPP / 252 0._RPP ; c ( 2 , 5 , 4 ) =- 64 1._RPP / 252 0._RPP ; c ( 2 , 5 , 5 ) = 137 5._RPP / 252 0._RPP c ( 2 , 4 , 3 ) =- 127 1._RPP / 252 0._RPP ; c ( 2 , 4 , 4 ) = 187 9._RPP / 252 0._RPP ; c ( 2 , 4 , 5 ) = 187 9._RPP / 252 0._RPP c ( 2 , 3 , 3 ) = 250 9._RPP / 252 0._RPP ; c ( 2 , 3 , 4 ) = 137 5._RPP / 252 0._RPP ; c ( 2 , 3 , 5 ) =- 64 1._RPP / 252 0._RPP c ( 2 , 2 , 3 ) = 95 5._RPP / 252 0._RPP ; c ( 2 , 2 , 4 ) =- 30 5._RPP / 252 0._RPP ; c ( 2 , 2 , 5 ) = 19 9._RPP / 252 0._RPP c ( 2 , 1 , 3 ) =- 12 5._RPP / 252 0._RPP ; c ( 2 , 1 , 4 ) = 5 5._RPP / 252 0._RPP ; c ( 2 , 1 , 5 ) =- 4 1._RPP / 252 0._RPP c ( 2 , 0 , 3 ) = 1 0._RPP / 252 0._RPP ; c ( 2 , 0 , 4 ) =- 5._RPP / 252 0._RPP ; c ( 2 , 0 , 5 ) = 4._RPP / 252 0._RPP c ( 2 , 8 , 6 ) = 1 0._RPP / 252 0._RPP ; c ( 2 , 8 , 7 ) =- 3 5._RPP / 252 0._RPP ; c ( 2 , 8 , 8 ) = 28 0._RPP / 252 0._RPP c ( 2 , 7 , 6 ) =- 12 5._RPP / 252 0._RPP ; c ( 2 , 7 , 7 ) = 59 5._RPP / 252 0._RPP ; c ( 2 , 7 , 8 ) = 460 9._RPP / 252 0._RPP c ( 2 , 6 , 6 ) = 95 5._RPP / 252 0._RPP ; c ( 2 , 6 , 7 ) = 334 9._RPP / 252 0._RPP ; c ( 2 , 6 , 8 ) =- 547 1._RPP / 252 0._RPP c ( 2 , 5 , 6 ) = 250 9._RPP / 252 0._RPP ; c ( 2 , 5 , 7 ) =- 253 1._RPP / 252 0._RPP ; c ( 2 , 5 , 8 ) = 628 9._RPP / 252 0._RPP c ( 2 , 4 , 6 ) =- 127 1._RPP / 252 0._RPP ; c ( 2 , 4 , 7 ) = 187 9._RPP / 252 0._RPP ; c ( 2 , 4 , 8 ) =- 547 1._RPP / 252 0._RPP c ( 2 , 3 , 6 ) = 61 9._RPP / 252 0._RPP ; c ( 2 , 3 , 7 ) =- 106 1._RPP / 252 0._RPP ; c ( 2 , 3 , 8 ) = 334 9._RPP / 252 0._RPP c ( 2 , 2 , 6 ) =- 22 1._RPP / 252 0._RPP ; c ( 2 , 2 , 7 ) = 40 9._RPP / 252 0._RPP ; c ( 2 , 2 , 8 ) =- 135 5._RPP / 252 0._RPP c ( 2 , 1 , 6 ) = 4 9._RPP / 252 0._RPP ; c ( 2 , 1 , 7 ) =- 9 5._RPP / 252 0._RPP ; c ( 2 , 1 , 8 ) = 32 5._RPP / 252 0._RPP c ( 2 , 0 , 6 ) =- 5._RPP / 252 0._RPP ; c ( 2 , 0 , 7 ) = 1 0._RPP / 252 0._RPP ; c ( 2 , 0 , 8 ) =- 3 5._RPP / 252 0._RPP endselect endassociate endsubroutine create pure subroutine compute ( self , stencil ) !< Compute interpolations. class ( interpolations_rec_js ), intent ( inout ) :: self !< Interpolations. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. integer ( I_P ) :: s1 !< Counter. integer ( I_P ) :: s2 !< Counter. integer ( I_P ) :: f !< Counter. self % values = 0._RPP do s1 = 0 , self % S - 1 ! stencils loop do s2 = 0 , self % S - 1 ! values loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = self % values ( f , s1 ) + self % coef ( f , s2 , s1 ) * stencil ( f + self % ff , - s2 + s1 ) enddo enddo enddo endsubroutine compute pure function description ( self ) result ( string ) !< Return interpolations string-description. class ( interpolations_rec_js ), intent ( in ) :: self !< Interpolations. character ( len = :), allocatable :: string !< String-description. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolations_rec_js%description to be implemented, do not use!' #endif endfunction description elemental subroutine destroy ( self ) !< Destroy interpolations. class ( interpolations_rec_js ), intent ( inout ) :: self !< Interpolations. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % coef )) deallocate ( self % coef ) endsubroutine destroy endmodule wenoof_interpolations_rec_js","tags":"","loc":"sourcefile/wenoof_interpolations_rec_js.f90.html","title":"wenoof_interpolations_rec_js.F90 – FORESEER"},{"text":"Henrick alpha (non linear weights) object. This File Depends On sourcefile~~wenoof_alpha_rec_m.f90~~EfferentGraph sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 var pansourcefilewenoof_alpha_rec_mf90EfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_rec_mf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_alpha_rec_m.f90~~AfferentGraph sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_alpha_rec_mf90AfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_rec_mf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_alpha_rec_m Source Code wenoof_alpha_rec_m.F90 Source Code !< Henrick alpha (non linear weights) object. module wenoof_alpha_rec_m !< Henrick alpha (non linear weights) object. !< !< @note The provided alpha implements the alpha coefficients defined in *Mapped weighted essentially non-oscillatory schemes: !< Achieving optimal order near critical points*, Andrew K. Henrick, Tariq D. Aslam, Joseph M. Powers, JCP, !< 2005, vol. 207, pp. 542-567, doi:10.1016/j.jcp.2005.01.023 #ifdef r16p use penf , only : I_P , RPP => R16P , str #else use penf , only : I_P , RPP => R8P , str #endif use wenoof_alpha_object use wenoof_alpha_rec_js use wenoof_alpha_rec_z use wenoof_base_object use wenoof_beta_object use wenoof_kappa_object implicit none private public :: alpha_rec_m public :: alpha_rec_m_constructor type , extends ( alpha_object_constructor ) :: alpha_rec_m_constructor !< Henrick alpha (non linear weights) object constructor. character ( len = :), allocatable :: base_type !< Base alpha coefficient type. endtype alpha_rec_m_constructor type , extends ( alpha_object ) :: alpha_rec_m !< Henrick alpha (non linear weights) object. !< !< @note The provided alpha implements the alpha coefficients defined in *Mapped weighted essentially non-oscillatory schemes: !< Achieving optimal order near critical points*, Andrew K. Henrick, Tariq D. Aslam, Joseph M. Powers, !< JCP, 2005, vol. 207, pp. 542-567, doi:10.1016/j.jcp.2005.01.023. class ( alpha_object ), allocatable :: alpha_base !< Base alpha to be re-mapped. contains ! public deferred methods procedure , pass ( self ) :: create !< Create alpha. procedure , pass ( self ) :: compute !< Compute alpha. procedure , pass ( self ) :: description !< Return alpha string-description. procedure , pass ( self ) :: destroy !< Destroy alpha. endtype alpha_rec_m contains ! deferred public methods subroutine create ( self , constructor ) !< Create alpha. class ( alpha_rec_m ), intent ( inout ) :: self !< Alpha. class ( base_object_constructor ), intent ( in ) :: constructor !< Alpha constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % values_sum ( 1 : 2 )) self % values = 0._RPP self % values_sum = 0._RPP select type ( constructor ) type is ( alpha_rec_m_constructor ) if ( allocated ( constructor % base_type )) then select case ( constructor % base_type ) case ( 'JS' ) if ( allocated ( self % alpha_base )) deallocate ( self % alpha_base ) allocate ( alpha_rec_js :: self % alpha_base ) call self % alpha_base % create ( constructor = constructor ) case ( 'Z' ) if ( allocated ( self % alpha_base )) deallocate ( self % alpha_base ) allocate ( alpha_rec_z :: self % alpha_base ) call self % alpha_base % create ( constructor = constructor ) endselect endif class default ! @TODO add error handling endselect endsubroutine create pure subroutine compute ( self , beta , kappa ) !< Compute alpha. class ( alpha_rec_m ), intent ( inout ) :: self !< Alpha. class ( beta_object ), intent ( in ) :: beta !< Beta. class ( kappa_object ), intent ( in ) :: kappa !< Kappa. real ( RPP ) :: kappa_base !< Kappa evaluated from the base alphas. integer ( I_P ) :: f , s1 !< Counters. self % values_sum = 0._RPP call self % alpha_base % compute ( beta = beta , kappa = kappa ) do s1 = 0 , self % S - 1 ! stencil loops do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) kappa_base = self % alpha_base % values ( f , s1 ) / self % alpha_base % values_sum ( f ) self % values ( f , s1 ) = & ( kappa_base * ( kappa % values ( f , s1 ) + kappa % values ( f , s1 ) * kappa % values ( f , s1 ) - & 3._RPP * kappa % values ( f , s1 ) * kappa_base + kappa_base * & kappa_base )) / & ( kappa % values ( f , s1 ) * kappa % values ( f , s1 ) + kappa_base * & ( 1._RPP - 2._RPP * kappa % values ( f , s1 ))) self % values_sum ( f ) = self % values_sum ( f ) + self % values ( f , s1 ) enddo enddo endsubroutine compute pure function description ( self ) result ( string ) !< Return alpha string-descripition. class ( alpha_rec_m ), intent ( in ) :: self !< Alpha. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '    Henrick alpha coefficients for reconstructor:' // nl string = string // '      - S   = ' // trim ( str ( self % S )) // nl string = string // '      - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '      - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '      - ff  = ' // trim ( str ( self % ff )) // nl string = string // '      - eps = ' // trim ( str ( self % eps )) // nl associate ( alpha_base => self % alpha_base ) select type ( alpha_base ) type is ( alpha_rec_js ) string = string // '      - base-mapped-alpha type = Jiang-Shu' type is ( alpha_rec_z ) string = string // '      - base-mapped-alpha type = Bogeg' endselect endassociate endfunction description elemental subroutine destroy ( self ) !< Destroy alpha. class ( alpha_rec_m ), intent ( inout ) :: self !< Alpha. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % values_sum )) deallocate ( self % values_sum ) if ( allocated ( self % alpha_base )) deallocate ( self % alpha_base ) endsubroutine destroy endmodule wenoof_alpha_rec_m","tags":"","loc":"sourcefile/wenoof_alpha_rec_m.f90.html","title":"wenoof_alpha_rec_m.F90 – FORESEER"},{"text":"Wenoof kappa factory. This File Depends On sourcefile~~wenoof_kappa_factory.f90~~EfferentGraph sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 var pansourcefilewenoof_kappa_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_kappa_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_kappa_factory.f90~~AfferentGraph sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_kappa_factoryf90AfferentGraph = svgPanZoom('#sourcefilewenoof_kappa_factoryf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_kappa_factory Source Code wenoof_kappa_factory.f90 Source Code !< Wenoof kappa factory. module wenoof_kappa_factory !< Wenoof kappa factory. use penf , only : I_P use wenoof_kappa_object use wenoof_kappa_rec_js implicit none private public :: kappa_factory type :: kappa_factory !< Factory, create an instance of concrete extension of [[kappa_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[kappa_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[kappa_object_constructor]]. endtype kappa_factory contains subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[kappa_object]] given its constructor. class ( kappa_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( kappa_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( kappa_rec_js_constructor ) allocate ( kappa_rec_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create subroutine create_constructor ( interpolator_type , S , constructor ) !< Create an instance of concrete extension of [[kappa_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( kappa_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( kappa_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( kappa_rec_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( kappa_rec_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( kappa_rec_js_constructor :: constructor ) endselect call constructor % create ( S = S ) endsubroutine create_constructor endmodule wenoof_kappa_factory","tags":"","loc":"sourcefile/wenoof_kappa_factory.f90.html","title":"wenoof_kappa_factory.f90 – FORESEER"},{"text":"Wenoof weights factory. This File Depends On sourcefile~~wenoof_weights_factory.f90~~EfferentGraph sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 var pansourcefilewenoof_weights_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_weights_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_weights_factory.f90~~AfferentGraph sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_weights_factoryf90AfferentGraph = svgPanZoom('#sourcefilewenoof_weights_factoryf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_weights_factory Source Code wenoof_weights_factory.f90 Source Code !< Wenoof weights factory. module wenoof_weights_factory !< Wenoof weights factory. use penf , only : I_P use wenoof_alpha_object use wenoof_beta_object use wenoof_kappa_object use wenoof_weights_object use wenoof_weights_js implicit none private public :: weights_factory type :: weights_factory !< Factory, create an instance of concrete extension of [[weights_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[weights_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[weights_object_constructor]]. endtype weights_factory contains subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[weights_object]] given its constructor. class ( weights_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( weights_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( weights_js_constructor ) allocate ( weights_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create subroutine create_constructor ( interpolator_type , S , alpha_constructor , beta_constructor , kappa_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[weights_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), intent ( in ) :: alpha_constructor !< Alpha constructor. class ( beta_object_constructor ), intent ( in ) :: beta_constructor !< Beta constructor. class ( kappa_object_constructor ), intent ( in ) :: kappa_constructor !< kappa constructor. class ( weights_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( weights_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( weights_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( weights_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( weights_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) select type ( constructor ) type is ( weights_js_constructor ) allocate ( constructor % alpha_constructor , source = alpha_constructor ) allocate ( constructor % beta_constructor , source = beta_constructor ) allocate ( constructor % kappa_constructor , source = kappa_constructor ) endselect endsubroutine create_constructor endmodule wenoof_weights_factory","tags":"","loc":"sourcefile/wenoof_weights_factory.f90.html","title":"wenoof_weights_factory.f90 – FORESEER"},{"text":"Wenoof interpolator factory. This File Depends On sourcefile~~wenoof_interpolator_factory.f90~~EfferentGraph sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 var pansourcefilewenoof_interpolator_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_interpolator_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_interpolator_factory.f90~~AfferentGraph sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 var pansourcefilewenoof_interpolator_factoryf90AfferentGraph = svgPanZoom('#sourcefilewenoof_interpolator_factoryf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_interpolator_factory Source Code wenoof_interpolator_factory.f90 Source Code !< Wenoof interpolator factory. module wenoof_interpolator_factory !< Wenoof interpolator factory. use penf , only : I_P use wenoof_interpolations_object use wenoof_interpolator_object ! use wenoof_interpolator_js use wenoof_reconstructor_js use wenoof_weights_object implicit none private public :: interpolator_factory type :: interpolator_factory !< Factory, create an instance of concrete extension of [[interpolator_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[interpolator_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[interpolator_object_constructor]]. endtype interpolator_factory contains subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[interpolator_object]] given its constructor. class ( interpolator_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolator_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) ! type is(interpolator_js_constructor) ! allocate(interpolator_js :: object) type is ( reconstructor_js_constructor ) allocate ( reconstructor_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create subroutine create_constructor ( interpolator_type , S , interpolations_constructor , weights_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[weights_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), intent ( in ) :: interpolations_constructor !< Interpolations const. class ( weights_object_constructor ), intent ( in ) :: weights_constructor !< Weights constructor. class ( interpolator_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left interp. logical , intent ( in ), optional :: face_right !< Activate right interp. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( reconstructor_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( reconstructor_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( reconstructor_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( reconstructor_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) select type ( constructor ) type is ( reconstructor_js_constructor ) allocate ( constructor % interpolations_constructor , source = interpolations_constructor ) allocate ( constructor % weights_constructor , source = weights_constructor ) endselect endsubroutine create_constructor endmodule wenoof_interpolator_factory","tags":"","loc":"sourcefile/wenoof_interpolator_factory.f90.html","title":"wenoof_interpolator_factory.f90 – FORESEER"},{"text":"Wenoof interpolations factory. This File Depends On sourcefile~~wenoof_interpolations_factory.f90~~EfferentGraph sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 var pansourcefilewenoof_interpolations_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_interpolations_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_interpolations_factory.f90~~AfferentGraph sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_interpolations_factoryf90AfferentGraph = svgPanZoom('#sourcefilewenoof_interpolations_factoryf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_interpolations_factory Source Code wenoof_interpolations_factory.f90 Source Code !< Wenoof interpolations factory. module wenoof_interpolations_factory !< Wenoof interpolations factory. use penf , only : I_P use wenoof_interpolations_object use wenoof_interpolations_rec_js implicit none private public :: interpolations_factory type :: interpolations_factory !< Factory, create an instance of concrete extension of [[interpolations_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[interpolations_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[interpolations_object_constructor]]. endtype interpolations_factory contains subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[interpolations_object]] given its constructor. class ( interpolations_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolations_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( interpolations_rec_js_constructor ) allocate ( interpolations_rec_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create subroutine create_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[beta_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interp. logical , intent ( in ), optional :: face_right !< Activate right-face interp. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( interpolations_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( interpolations_rec_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( interpolations_rec_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( interpolations_rec_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) endsubroutine create_constructor endmodule wenoof_interpolations_factory","tags":"","loc":"sourcefile/wenoof_interpolations_factory.f90.html","title":"wenoof_interpolations_factory.f90 – FORESEER"},{"text":"Wenoof objects factory. This File Depends On sourcefile~~wenoof_objects_factory.f90~~EfferentGraph sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_object.f90 wenoof_interpolations_object.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90 wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90 wenoof_interpolator_object.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_interpolations_rec_js.f90 wenoof_interpolations_rec_js.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_interpolations_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolations_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90 wenoof_weights_object.F90 sourcefile~penf.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_kappa_factory.f90 wenoof_kappa_factory.f90 sourcefile~penf.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~penf.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~penf.f90->sourcefile~wenoof_weights_js.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_rec_js.f90 wenoof_kappa_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~penf.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_weights_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_kappa_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolator_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_interpolations_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolations_rec_js.f90->sourcefile~wenoof_interpolations_factory.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_kappa_factory.f90 sourcefile~wenoof_kappa_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 var pansourcefilewenoof_objects_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_objects_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_objects_factory.f90~~AfferentGraph sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_objects_factory Source Code wenoof_objects_factory.f90 Source Code !< Wenoof objects factory. module wenoof_objects_factory !< Wenoof factory. #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif use wenoof_alpha_factory use wenoof_alpha_object use wenoof_beta_factory use wenoof_beta_object use wenoof_kappa_factory use wenoof_kappa_object use wenoof_interpolations_factory use wenoof_interpolations_object use wenoof_interpolator_factory use wenoof_interpolator_object use wenoof_weights_factory use wenoof_weights_object implicit none private public :: objects_factory type :: objects_factory !< Factory, create an instance of concrete extension of [[base_object]] given its constructor. contains ! public methods generic :: create => create_alpha_object , & create_beta_object , & create_kappa_object , & create_interpolations_object , & create_interpolator , & create_interpolator_object , & create_weights_object !< Create a concrete instance of [[alpha_object]], [[beta_object]], !< [[kappa_object]], [[interpolations_object]], [[interpolator_object]] or !< [[weights_object]]. generic :: create_constructor => create_alpha_object_constructor , & create_beta_object_constructor , & create_kappa_object_constructor , & create_interpolations_object_constructor , & create_interpolator_object_constructor , & create_weights_object_constructor !< Create a concrete instance of !< [[alpha_object_constructor]], [[beta_object_constructor]], !< [[kappa_object_constructor]], !< [[interpolations_object_constructor]], !< [[interpolator_object_constructor]] or !< [[weights_object_constructor]]. ! private methods procedure , nopass , private :: create_alpha_object !< Create [[alpha_object]] instance procedure , nopass , private :: create_beta_object !< Create [[beta_object]] instance. procedure , nopass , private :: create_kappa_object !< Create [[kappa_object]] instance. procedure , nopass , private :: create_interpolations_object !< Create [[interpolations_object]] instance. procedure , pass ( self ), private :: create_interpolator !< Create [[interpolator_object]] instance. procedure , nopass , private :: create_interpolator_object !< Create [[interpolator_object]] instance. procedure , nopass , private :: create_weights_object !< Create [[weights_object]] instance. procedure , nopass , private :: create_alpha_object_constructor !< Create [[alpha_object_constructor]] instance. procedure , nopass , private :: create_beta_object_constructor !< Create [[beta_object_constructor]] instance. procedure , nopass , private :: create_kappa_object_constructor !< Create [[kappa_object_constructor]] instance. procedure , nopass , private :: create_interpolations_object_constructor !< Create [[interpolations_object_constructor]] inst. procedure , nopass , private :: create_interpolator_object_constructor !< Create [[interpolator_object_constructor]] inst. procedure , nopass , private :: create_weights_object_constructor !< Create [[weights_object_constructor]] instance. endtype objects_factory contains subroutine create_alpha_object ( constructor , object ) !< Create an instance of concrete extension of [[alpha_object]] given its constructor. class ( alpha_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( alpha_object ), allocatable , intent ( out ) :: object !< Object. type ( alpha_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_alpha_object subroutine create_beta_object ( constructor , object ) !< Create an instance of concrete extension of [[beta_object]] given its constructor. class ( beta_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( beta_object ), allocatable , intent ( out ) :: object !< Object. type ( beta_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_beta_object subroutine create_kappa_object ( constructor , object ) !< Create an instance of concrete extension of [[kappa_object]] given its constructor. class ( kappa_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( kappa_object ), allocatable , intent ( out ) :: object !< Object. type ( kappa_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_kappa_object subroutine create_interpolations_object ( constructor , object ) !< Create an instance of concrete extension of [[interpolations_object]] given its constructor. class ( interpolations_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolations_object ), allocatable , intent ( out ) :: object !< Object. type ( interpolations_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_interpolations_object subroutine create_interpolator ( self , interpolator_type , S , interpolator , face_left , face_right , eps ) !< Create an instance of concrete extension of [[interpolator_object]] given user options. class ( objects_factory ), intent ( in ) :: self !< The factory. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolator_object ), allocatable , intent ( out ) :: interpolator !< Interpolator. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero/div. class ( alpha_object_constructor ), allocatable :: alpha_constructor !< Alpha constructor. class ( beta_object_constructor ), allocatable :: beta_constructor !< Beta constructor. class ( interpolations_object_constructor ), allocatable :: interpolations_constructor !< Interpolations constructor. class ( kappa_object_constructor ), allocatable :: kappa_constructor !< Kappa constructor. class ( weights_object_constructor ), allocatable :: weights_constructor !< Weights constructor. class ( interpolator_object_constructor ), allocatable :: interpolator_constructor !< Interpolator constructor. call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = alpha_constructor , & face_left = face_left , & face_right = face_right , & eps = eps ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = beta_constructor , & face_left = face_left , & face_right = face_right ) call self % create_constructor ( interpolator_type = interpolator_type , S = S , constructor = kappa_constructor ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & alpha_constructor = alpha_constructor , & beta_constructor = beta_constructor , & kappa_constructor = kappa_constructor , & constructor = weights_constructor , & face_left = face_left , & face_right = face_right ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = interpolations_constructor , & face_left = face_left , & face_right = face_right ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & interpolations_constructor = interpolations_constructor , & weights_constructor = weights_constructor , & constructor = interpolator_constructor , & face_left = face_left , & face_right = face_right ) call self % create_interpolator_object ( constructor = interpolator_constructor , object = interpolator ) endsubroutine create_interpolator subroutine create_interpolator_object ( constructor , object ) !< Create an instance of concrete extension of [[interpolator_object]] given its constructor. class ( interpolator_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolator_object ), allocatable , intent ( out ) :: object !< Object. type ( interpolator_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_interpolator_object subroutine create_weights_object ( constructor , object ) !< Create an instance of concrete extension of [[weights_object]] given its constructor. class ( weights_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( weights_object ), allocatable , intent ( out ) :: object !< Object. type ( weights_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_weights_object subroutine create_alpha_object_constructor ( interpolator_type , S , constructor , face_left , face_right , eps ) !< Create an instance of concrete extension of [[alpha_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero/division. type ( alpha_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = constructor , & face_left = face_left , & face_right = face_right , & eps = eps ) endsubroutine create_alpha_object_constructor subroutine create_beta_object_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[beta_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( beta_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. type ( beta_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_beta_object_constructor subroutine create_kappa_object_constructor ( interpolator_type , S , constructor ) !< Create an instance of concrete extension of [[kappa_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( kappa_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. type ( kappa_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , S = S , constructor = constructor ) endsubroutine create_kappa_object_constructor subroutine create_interpolations_object_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[interpolations_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interp. logical , intent ( in ), optional :: face_right !< Activate right-face interp. type ( interpolations_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_interpolations_object_constructor subroutine create_interpolator_object_constructor ( interpolator_type , S , interpolations_constructor , weights_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[interpolator_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), intent ( in ) :: interpolations_constructor !< Interpolations const. class ( weights_object_constructor ), intent ( in ) :: weights_constructor !< Weights constructor. class ( interpolator_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left interp. logical , intent ( in ), optional :: face_right !< Activate right interp. type ( interpolator_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & interpolations_constructor = interpolations_constructor , & weights_constructor = weights_constructor , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_interpolator_object_constructor subroutine create_weights_object_constructor ( interpolator_type , S , alpha_constructor , beta_constructor , kappa_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[weights_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), intent ( in ) :: alpha_constructor !< Alpha constructor. class ( beta_object_constructor ), intent ( in ) :: beta_constructor !< Beta constructor. class ( kappa_object_constructor ), intent ( in ) :: kappa_constructor !< kappa constructor. class ( weights_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interp. logical , intent ( in ), optional :: face_right !< Activate right-face interp. type ( weights_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & alpha_constructor = alpha_constructor , & beta_constructor = beta_constructor , & kappa_constructor = kappa_constructor , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_weights_object_constructor endmodule wenoof_objects_factory","tags":"","loc":"sourcefile/wenoof_objects_factory.f90.html","title":"wenoof_objects_factory.f90 – FORESEER"},{"text":"Wenoof alpha factory. This File Depends On sourcefile~~wenoof_alpha_factory.f90~~EfferentGraph sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90 wenoof_alpha_rec_z.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_rec_js.f90 wenoof_alpha_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_rec_m.f90 wenoof_alpha_rec_m.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_object.f90 wenoof_alpha_object.F90 sourcefile~penf.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_kappa_object.f90 wenoof_kappa_object.F90 sourcefile~penf.f90->sourcefile~wenoof_kappa_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_z.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_rec_js.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_alpha_rec_m.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_factory.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_alpha_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_kappa_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_z.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_rec_m.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_alpha_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_kappa_object.f90 var pansourcefilewenoof_alpha_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_alpha_factory.f90~~AfferentGraph sourcefile~wenoof_alpha_factory.f90 wenoof_alpha_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_alpha_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_alpha_factoryf90AfferentGraph = svgPanZoom('#sourcefilewenoof_alpha_factoryf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_alpha_factory Source Code wenoof_alpha_factory.f90 Source Code !< Wenoof alpha factory. module wenoof_alpha_factory !< Wenoof alpha factory. #ifdef r16p use penf , only : I_P , RPP => R16P #else use penf , only : I_P , RPP => R8P #endif use wenoof_alpha_object use wenoof_alpha_rec_js use wenoof_alpha_rec_m use wenoof_alpha_rec_z implicit none private public :: alpha_factory type :: alpha_factory !< Factory, create an instance of concrete extension of [[alpha_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[alpha_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[alpha_object_constructor]]. endtype alpha_factory contains subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[alpha_object]] given its constructor. class ( alpha_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( alpha_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( alpha_rec_js_constructor ) allocate ( alpha_rec_js :: object ) type is ( alpha_rec_m_constructor ) allocate ( alpha_rec_m :: object ) type is ( alpha_rec_z_constructor ) allocate ( alpha_rec_z :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create subroutine create_constructor ( interpolator_type , S , constructor , face_left , face_right , eps ) !< Create an instance of concrete extension of [[alpha_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero/division. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( alpha_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( alpha_rec_m_constructor :: constructor ) select type ( constructor ) type is ( alpha_rec_m_constructor ) constructor % base_type = 'JS' endselect case ( 'reconstructor-M-Z' ) allocate ( alpha_rec_m_constructor :: constructor ) select type ( constructor ) type is ( alpha_rec_m_constructor ) constructor % base_type = 'Z' endselect case ( 'reconstructor-Z' ) allocate ( alpha_rec_z_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right , eps = eps ) endsubroutine create_constructor endmodule wenoof_alpha_factory","tags":"","loc":"sourcefile/wenoof_alpha_factory.f90.html","title":"wenoof_alpha_factory.f90 – FORESEER"},{"text":"Wenoof beta factory. This File Depends On sourcefile~~wenoof_beta_factory.f90~~EfferentGraph sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_rec_js.f90 wenoof_beta_rec_js.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_beta_object.f90 wenoof_beta_object.F90 sourcefile~penf.f90->sourcefile~wenoof_beta_object.f90 sourcefile~wenoof_base_object.f90 wenoof_base_object.F90 sourcefile~penf.f90->sourcefile~wenoof_base_object.f90 sourcefile~wenoof_beta_rec_js.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_factory.f90 sourcefile~wenoof_beta_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_rec_js.f90 sourcefile~wenoof_base_object.f90->sourcefile~wenoof_beta_object.f90 var pansourcefilewenoof_beta_factoryf90EfferentGraph = svgPanZoom('#sourcefilewenoof_beta_factoryf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~wenoof_beta_factory.f90~~AfferentGraph sourcefile~wenoof_beta_factory.f90 wenoof_beta_factory.f90 sourcefile~wenoof_objects_factory.f90 wenoof_objects_factory.f90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_weights_js.f90 wenoof_weights_js.F90 sourcefile~wenoof_beta_factory.f90->sourcefile~wenoof_weights_js.f90 sourcefile~wenoof.f90 wenoof.F90 sourcefile~wenoof_objects_factory.f90->sourcefile~wenoof.f90 sourcefile~wenoof_weights_factory.f90 wenoof_weights_factory.f90 sourcefile~wenoof_weights_js.f90->sourcefile~wenoof_weights_factory.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~wenoof.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_objects_factory.f90 sourcefile~wenoof_reconstructor_js.f90 wenoof_reconstructor_js.F90 sourcefile~wenoof_weights_factory.f90->sourcefile~wenoof_reconstructor_js.f90 sourcefile~wenoof_interpolator_factory.f90 wenoof_interpolator_factory.f90 sourcefile~wenoof_reconstructor_js.f90->sourcefile~wenoof_interpolator_factory.f90 sourcefile~wenoof_interpolator_factory.f90->sourcefile~wenoof_objects_factory.f90 var pansourcefilewenoof_beta_factoryf90AfferentGraph = svgPanZoom('#sourcefilewenoof_beta_factoryf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules wenoof_beta_factory Source Code wenoof_beta_factory.f90 Source Code !< Wenoof beta factory. module wenoof_beta_factory !< Wenoof beta factory. use penf , only : I_P use wenoof_beta_object use wenoof_beta_rec_js implicit none private public :: beta_factory type :: beta_factory !< Factory, create an instance of concrete extension of [[beta_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[beta_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[beta_object_constructor]]. endtype beta_factory contains subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[beta_object]] given its constructor. class ( beta_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( beta_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( beta_rec_js_constructor ) allocate ( beta_rec_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create subroutine create_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[beta_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( beta_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( beta_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( beta_rec_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( beta_rec_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( beta_rec_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) endsubroutine create_constructor endmodule wenoof_beta_factory","tags":"","loc":"sourcefile/wenoof_beta_factory.f90.html","title":"wenoof_beta_factory.f90 – FORESEER"},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf type~~riemann_solver_compressible_llf~~InheritsGraph type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object var pantyperiemann_solver_compressible_llfInheritsGraph = svgPanZoom('#typeriemann_solver_compressible_llfInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. Note This is the implemention for conservative_compressible Riemann states. Variables a_1 a_4 d_1 d_4 e_1 e_4 g_1 g_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 solver_pvl u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_llf Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. real(kind=R8P), public :: d_1 = 0._R8P (gamma-1)/2 of state 1. real(kind=R8P), public :: d_4 = 0._R8P (gamma-1)/2 of state 4. real(kind=R8P), public :: e_1 = 0._R8P 2*g/(g-1) of state 1. real(kind=R8P), public :: e_4 = 0._R8P 2*g/(g-1) of state 4. real(kind=R8P), public :: g_1 = 0._R8P Specific heats ratio gamma=cp/cv of state 1. real(kind=R8P), public :: g_4 = 0._R8P Specific heats ratio gamma=cp/cv of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf !< Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_llf","tags":"","loc":"type/riemann_solver_compressible_llf.html","title":"riemann_solver_compressible_llf – FORESEER "},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl type~~riemann_solver_compressible_pvl~~InheritsGraph type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Primitive Variables Linearization based Riemann solver. Note This is the implemention for conservative_compressible Riemann states. Inherited By type~~riemann_solver_compressible_pvl~~InheritedByGraph type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables a_1 a_4 compute_waves_ d_1 d_4 e_1 e_4 g_1 g_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 solve_ u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_p23 compute_u23 compute_up23 compute_waves compute_waves_u23 compute_waves_up23 description initialize set_states14 solve solve_u23 solve_up23 Source Code riemann_solver_compressible_pvl Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. procedure( compute_waves_interface ), public, pointer :: compute_waves_ => compute_waves_up23 Compute waves pattern real(kind=R8P), public :: d_1 = 0._R8P (gamma-1)/2 of state 1. real(kind=R8P), public :: d_4 = 0._R8P (gamma-1)/2 of state 4. real(kind=R8P), public :: e_1 = 0._R8P 2*g/(g-1) of state 1. real(kind=R8P), public :: e_4 = 0._R8P 2*g/(g-1) of state 4. real(kind=R8P), public :: g_1 = 0._R8P Specific heats ratio gamma=cp/cv of state 1. real(kind=R8P), public :: g_4 = 0._R8P Specific heats ratio gamma=cp/cv of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. procedure( solve_interface ), public, pointer :: solve_ => solve_up23 Solve Riemann problem. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, private, pass(self) :: compute_p23 Compute interstates pressure. private elemental subroutine compute_p23 (self) Compute interstates pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. procedure, private, pass(self) :: compute_u23 Compute interstates velocity. private elemental subroutine compute_u23 (self) Compute interstates velocity. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. procedure, private, pass(self) :: compute_up23 Compute interstates velocity and pressure. private elemental subroutine compute_up23 (self) Compute interstates velocity and pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, private, pass(self) :: compute_waves_u23 Compute waves speed by u23 algorithm. private pure subroutine compute_waves_u23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, private, pass(self) :: compute_waves_up23 Compute waves speed by up23 algorithm. private pure subroutine compute_waves_up23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private pure subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: solve_u23 Compute whole pattern by u23 algorithm. private pure subroutine solve_u23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem by u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: solve_up23 Compute whole pattern by up23 algorithm. private pure subroutine solve_up23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem up23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Riemann pattern. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl !< Primitive Variables Linearization based Riemann solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. procedure ( compute_waves_interface ), pointer :: compute_waves_ => compute_waves_up23 !< Compute waves pattern procedure ( solve_interface ), pointer :: solve_ => solve_up23 !< Solve Riemann problem. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. ! private methods procedure , pass ( self ), private :: compute_p23 !< Compute interstates pressure. procedure , pass ( self ), private :: compute_u23 !< Compute interstates velocity. procedure , pass ( self ), private :: compute_up23 !< Compute interstates velocity and pressure. procedure , pass ( self ), private :: compute_waves_u23 !< Compute waves speed by `u23` algorithm. procedure , pass ( self ), private :: compute_waves_up23 !< Compute waves speed by `up23` algorithm. procedure , pass ( self ), private :: solve_u23 !< Compute whole pattern by `u23` algorithm. procedure , pass ( self ), private :: solve_up23 !< Compute whole pattern by `up23` algorithm. endtype riemann_solver_compressible_pvl","tags":"","loc":"type/riemann_solver_compressible_pvl.html","title":"riemann_solver_compressible_pvl – FORESEER "},{"text":"type, public, abstract :: riemann_solver_object Abstract Riemann Solver. Inherited By type~~riemann_solver_object~~InheritedByGraph type~riemann_solver_object riemann_solver_object type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_object->type~riemann_solver_compressible_object type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl var pantyperiemann_solver_objectInheritedByGraph = svgPanZoom('#typeriemann_solver_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures compute_waves description initialize solve Source Code riemann_solver_object Type-Bound Procedures procedure( compute_waves_interface ), public, deferred, pass(self) :: compute_waves Compute waves pattern. pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Prototype Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize solver. subroutine initialize_interface (self, config) Prototype Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure( solve_interface ), public, deferred, pass(self) :: solve Solve Riemann Problem. subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Prototype Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , abstract :: riemann_solver_object !< Abstract Riemann Solver. contains ! public deferred methods procedure ( compute_waves_interface ), pass ( self ), deferred :: compute_waves !< Compute waves pattern. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize solver. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( solve_interface ), pass ( self ), deferred :: solve !< Solve Riemann Problem. endtype riemann_solver_object","tags":"","loc":"type/riemann_solver_object.html","title":"riemann_solver_object – FORESEER "},{"text":"type, public, extends( eos_object ) :: eos_compressible type~~eos_compressible~~InheritsGraph type~eos_compressible eos_compressible type~eos_object eos_object type~eos_object->type~eos_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Equation of state (EOS) of ideal compressible object class. Inherited By type~~eos_compressible~~InheritedByGraph type~eos_compressible eos_compressible type~euler_1d euler_1d type~eos_compressible->type~euler_1d eos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables cp_ cv_ Constructor eos_compressible Type-Bound Procedures R cp cv density energy gam pressure speed_of_sound temperature Source Code eos_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), private :: cp_ = 0._R8P Specific heat at constant pressure cp . real(kind=R8P), private :: cv_ = 0._R8P Specific heat at constant volume cv . Constructor public interface eos_compressible Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Type-Bound Procedures procedure, public, pass(self) :: R Return fluid constant R=cp-cv . private elemental function R (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. procedure, public, pass(self) :: cp Return specific heat at constant pressure. private elemental function cp (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. procedure, public, pass(self) :: cv Return specific heat at constant volume. private elemental function cv (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. procedure, public, pass(self) :: density Return density. private elemental function density (self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. procedure, public, pass(self) :: energy Return specific internal energy. private elemental function energy (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. procedure, public, pass(self) :: gam Return specific heats ratio gamma=cp/cv . private elemental function gam (self) result(gam_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. procedure, public, pass(self) :: pressure Return pressure. private elemental function pressure (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. procedure, public, pass(self) :: speed_of_sound Return speed of sound. private elemental function speed_of_sound (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. procedure, public, pass(self) :: temperature Return temperature. private elemental function temperature (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code type , extends ( eos_object ) :: eos_compressible !< Equation of state (EOS) of ideal compressible object class. private real ( R8P ) :: cp_ = 0._R8P !< Specific heat at constant pressure `cp`. real ( R8P ) :: cv_ = 0._R8P !< Specific heat at constant volume `cv`. contains ! deferred methods procedure , pass ( self ) :: cp !< Return specific heat at constant pressure. procedure , pass ( self ) :: cv !< Return specific heat at constant volume. procedure , pass ( self ) :: density !< Return density. procedure , pass ( self ) :: energy !< Return specific internal energy. procedure , pass ( self ) :: gam !< Return specific heats ratio `gamma=cp/cv`. procedure , pass ( self ) :: pressure !< Return pressure. procedure , pass ( self ) :: R !< Return fluid constant `R=cp-cv`. procedure , pass ( self ) :: speed_of_sound !< Return speed of sound. procedure , pass ( self ) :: temperature !< Return temperature. endtype eos_compressible","tags":"","loc":"type/eos_compressible.html","title":"eos_compressible – FORESEER "},{"text":"type, public, abstract :: eos_object Equation of State (EOS) object class. Inherited By type~~eos_object~~InheritedByGraph type~eos_object eos_object type~eos_compressible eos_compressible type~eos_object->type~eos_compressible type~euler_1d euler_1d type~eos_compressible->type~euler_1d eos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures R cp cv density energy gam pressure speed_of_sound temperature Source Code eos_object Type-Bound Procedures procedure( R_interface ), public, deferred, pass(self) :: R Return fluid constant R=cp-cv . elemental function R_interface (self) result(R_) Prototype Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. procedure( cp_interface ), public, deferred, pass(self) :: cp Return specific heat at constant pressure. elemental function cp_interface (self) result(cp_) Prototype Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. procedure( cv_interface ), public, deferred, pass(self) :: cv Return specific heat at constant volume. elemental function cv_interface (self) result(cv_) Prototype Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. procedure( density_interface ), public, deferred, pass(self) :: density Return density. elemental function density_interface (self, energy, pressure, speed_of_sound, temperature) result(density_) Prototype Return density. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. procedure( energy_interface ), public, deferred, pass(self) :: energy Return specific internal energy. elemental function energy_interface (self, density, pressure, temperature) result(energy_) Prototype Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. procedure( gam_interface ), public, deferred, pass(self) :: gam Return specific heats ratio gamma=cp/cv . elemental function gam_interface (self) result(gam_) Prototype Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. procedure( pressure_interface ), public, deferred, pass(self) :: pressure Return pressure. elemental function pressure_interface (self, density, energy, temperature) result(pressure_) Prototype Return pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. procedure( speed_of_sound_interface ), public, deferred, pass(self) :: speed_of_sound Return speed of sound. elemental function speed_of_sound_interface (self, density, pressure) result(speed_of_sound_) Prototype Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. procedure( temperature_interface ), public, deferred, pass(self) :: temperature Return temperature. elemental function temperature_interface (self, density, energy, pressure) result(temperature_) Prototype Return temperature. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code type , abstract :: eos_object !< Equation of State (EOS) object class. contains ! deferred methods procedure ( cp_interface ), pass ( self ), deferred :: cp !< Return specific heat at constant pressure. procedure ( cv_interface ), pass ( self ), deferred :: cv !< Return specific heat at constant volume. procedure ( density_interface ), pass ( self ), deferred :: density !< Return density. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return specific internal energy. procedure ( gam_interface ), pass ( self ), deferred :: gam !< Return specific heats ratio `gamma=cp/cv`. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure. procedure ( R_interface ), pass ( self ), deferred :: R !< Return fluid constant `R=cp-cv`. procedure ( speed_of_sound_interface ), pass ( self ), deferred :: speed_of_sound !< Return speed of sound. procedure ( temperature_interface ), pass ( self ), deferred :: temperature !< Return temperature. endtype eos_object","tags":"","loc":"type/eos_object.html","title":"eos_object – FORESEER "},{"text":"type, public, extends( primitive_object ) :: primitive_compressible type~~primitive_compressible~~InheritsGraph type~primitive_compressible primitive_compressible vector vector vector->type~primitive_compressible velocity type~primitive_object primitive_object type~primitive_object->type~primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Convervative compressible object class. Variables density pressure velocity Constructor primitive_compressible Type-Bound Procedures add array assignment(=) description destroy energy initialize left_eigenvectors momentum negative operator(*) operator(+) operator(-) operator(/) positive prim_assign_prim prim_divide_real prim_multiply_prim prim_multiply_real real_multiply_prim right_eigenvectors sub Source Code primitive_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor public interface primitive_compressible Overload primitive_compressible name with its constructor. private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of primitive. private pure function array (self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy primitive. private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. procedure, public, pass(self) :: energy Return energy value. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure, public, pass(self) :: initialize Initialize primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(self) :: left_eigenvectors Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . private pure function left_eigenvectors (self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. procedure, public, pass(self) :: momentum Return momentum vector. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure, public, pass(self) :: negative Unary operator - prim . private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(*) => prim_multiply_prim , prim_multiply_real , real_multiply_prim Overload * . private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(/) => prim_divide_real Overload / . private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(self) :: positive Unary operator + prim . private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: prim_assign_prim Operator = . private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: prim_divide_real Operator prim / real . private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: prim_multiply_prim Operator * . private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: prim_multiply_real Operator prim * real . private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_multiply_prim Operator real * prim . private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(self) :: right_eigenvectors Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . private pure function right_eigenvectors (self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. procedure, public, pass(lhs) :: sub Operator - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code type , extends ( primitive_object ) :: primitive_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. contains ! public methods procedure , pass ( self ) :: left_eigenvectors !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. procedure , pass ( self ) :: right_eigenvectors !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of primitive. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. procedure , pass ( lhs ) :: prim_assign_prim !< Operator `=`. procedure , pass ( lhs ) :: prim_divide_real !< Operator `prim / real`. procedure , pass ( lhs ) :: prim_multiply_real !< Operator `prim * real`. procedure , pass ( lhs ) :: prim_multiply_prim !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_prim !< Operator `real * prim`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ prim`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- prim`. endtype primitive_compressible","tags":"","loc":"type/primitive_compressible.html","title":"primitive_compressible – FORESEER "},{"text":"type, public, extends( conservative_object ) :: conservative_compressible type~~conservative_compressible~~InheritsGraph type~conservative_compressible conservative_compressible vector vector vector->type~conservative_compressible momentum type~conservative_object conservative_object type~conservative_object->type~conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Convervative compressible object class. Inherited By type~~conservative_compressible~~InheritedByGraph type~conservative_compressible conservative_compressible type~euler_1d euler_1d type~conservative_compressible->type~euler_1d U Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables density energy momentum Constructor conservative_compressible Type-Bound Procedures add array assignment(=) compute_fluxes compute_fluxes_from_primitive cons_assign_cons cons_divide_real cons_multiply_cons cons_multiply_real description destroy initialize negative operator(*) operator(+) operator(-) operator(/) positive pressure real_multiply_cons sub velocity Source Code conservative_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: energy = 0._R8P Energy, rho * E , rho being the density and E the specific energy. type(vector), public :: momentum Momentum, rho * v , rho being the density and v the velocity vector. Constructor public interface conservative_compressible Overload conservative_compressible name with its constructor. private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of conservative. private pure function array (self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_fluxes Compute conservative fluxes. private subroutine compute_fluxes (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. procedure, public, pass(self) :: compute_fluxes_from_primitive Compute conservative fluxes from primitives at interface. private elemental subroutine compute_fluxes_from_primitive (self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(lhs) :: cons_assign_cons Operator = . private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: cons_divide_real Operator cons / real . private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: cons_multiply_cons Operator * . private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: cons_multiply_real Operator cons * real . private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy conservative. private elemental subroutine destroy (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. procedure, public, pass(self) :: initialize Initialize conservative. private subroutine initialize (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(self) :: negative Unary operator - cons . private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(*) => cons_multiply_cons , cons_multiply_real , real_multiply_cons Overload * . private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(/) => cons_divide_real Overload / . private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: positive Unary operator + cons . private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: pressure Return pressure value. private elemental function pressure (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. procedure, public, pass(rhs) :: real_multiply_cons Operator real * cons . private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub Operator - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: velocity Return velocity vector. private elemental function velocity (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code type , extends ( conservative_object ) :: conservative_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ) :: energy = 0._R8P !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. contains ! public methods procedure , pass ( self ) :: compute_fluxes_from_primitive !< Compute conservative fluxes from primitives at interface. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of conservative. procedure , pass ( self ) :: compute_fluxes !< Compute conservative fluxes. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy conservative. procedure , pass ( self ) :: initialize !< Initialize conservative. procedure , pass ( self ) :: pressure !< Return pressure value. procedure , pass ( self ) :: velocity !< Return velocity vector. procedure , pass ( lhs ) :: cons_assign_cons !< Operator `=`. procedure , pass ( lhs ) :: cons_divide_real !< Operator `cons / real`. procedure , pass ( lhs ) :: cons_multiply_real !< Operator `cons * real`. procedure , pass ( lhs ) :: cons_multiply_cons !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_cons !< Operator `real * cons`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ cons`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- cons`. endtype conservative_compressible","tags":"","loc":"type/conservative_compressible.html","title":"conservative_compressible – FORESEER "},{"text":"type, public, abstract :: conservative_object Convervative object class. Inherited By type~~conservative_object~~InheritedByGraph type~conservative_object conservative_object type~conservative_compressible conservative_compressible type~conservative_object->type~conservative_compressible type~euler_1d euler_1d type~conservative_compressible->type~euler_1d U Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assignment(=) compute_fluxes cons_assign_cons cons_divide_real cons_multiply_cons cons_multiply_real description destroy initialize negative operator(*) operator(+) operator(-) operator(/) positive pressure real_multiply_cons sub velocity Source Code conservative_object Type-Bound Procedures procedure( symmetric_operator ), public, deferred, pass(lhs) :: add Operator + . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of conservative. pure function array_interface (self) result(array_) Prototype Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure( compute_fluxes_interface ), public, deferred, pass(self) :: compute_fluxes Compute conservative fluxes. subroutine compute_fluxes_interface (self, eos, normal, fluxes) Prototype Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. procedure( assignment_interface ), public, deferred, pass(lhs) :: cons_assign_cons Operator = . pure subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure( cons_operator_real ), public, deferred, pass(lhs) :: cons_divide_real Operator cons / real . function cons_operator_real (lhs, rhs) result(operator_result) Prototype Operator cons.op.real . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: cons_multiply_cons Operator * . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( cons_operator_real ), public, deferred, pass(lhs) :: cons_multiply_real Operator cons * real . function cons_operator_real (lhs, rhs) result(operator_result) Prototype Operator cons.op.real . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy conservative. elemental subroutine destroy_interface (self) Prototype Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize conservative. subroutine initialize_interface (self, initial_state) Prototype Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - cons . function unary_operator (self) result(operator_result) Prototype Unary operator .op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(*) => cons_multiply_cons , cons_multiply_real , real_multiply_cons Overload * . private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(/) => cons_divide_real Overload / . private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + cons . function unary_operator (self) result(operator_result) Prototype Unary operator .op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( pressure_interface ), public, deferred, pass(self) :: pressure Return pressure value. elemental function pressure_interface (self, eos) result(pressure_) Prototype Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. procedure( real_operator_cons ), public, deferred, pass(rhs) :: real_multiply_cons Operator real * cons . function real_operator_cons (lhs, rhs) result(operator_result) Prototype Operator real.op.cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: sub Operator - . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( velocity_interface ), public, deferred, pass(self) :: velocity Return velocity vector. elemental function velocity_interface (self) result(velocity_) Prototype Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code type , abstract :: conservative_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of conservative. procedure ( compute_fluxes_interface ), pass ( self ), deferred :: compute_fluxes !< Compute conservative fluxes. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy conservative. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize conservative. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure value. procedure ( velocity_interface ), pass ( self ), deferred :: velocity !< Return velocity vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: cons_assign_cons !< Operator `=`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_divide_real !< Operator `cons / real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: cons_multiply_cons !< Operator `*`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_multiply_real !< Operator `cons * real`. procedure ( real_operator_cons ), pass ( rhs ), deferred :: real_multiply_cons !< Operator `real * cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- cons`. ! operators generic :: assignment ( = ) => cons_assign_cons !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => cons_multiply_cons , cons_multiply_real , real_multiply_cons !< Overload `*`. generic :: operator ( / ) => cons_divide_real !< Overload `/`. endtype conservative_object","tags":"","loc":"type/conservative_object.html","title":"conservative_object – FORESEER "},{"text":"type, public, abstract, extends( riemann_solver_object ) :: riemann_solver_compressible_object type~~riemann_solver_compressible_object~~InheritsGraph type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Riemann solver for ideal compressible fluid object class. The ideal compressible fluid generates a 3-waves pattern: 2 genuinely non-linear acoustic waves and 1\n linear-degener contact discontinuity. t &#94;                                .\n     |     S1 _       S2 _            .      _ S       _ S3       _ S4\n     |       |\\_        |\\_           .      /|      __/|       __/|\n     |          \\__        \\_     U2  .     /  U3  _/       ___/\n     |             \\___      \\_       .    /    __/     ___/\n     |                 \\____   \\_     .   /   _/    ___/\n     |                      \\___ \\_   .  / __/  ___/\n     |          UL=U1           \\__\\_ . /_/____/          UR=U4\n     |                              \\\\.///\n  ---+--------------------------------o--------------------------------->\n     |                                xo                                x Inherited By type~~riemann_solver_compressible_object~~InheritedByGraph type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl var pantyperiemann_solver_compressible_objectInheritedByGraph = svgPanZoom('#typeriemann_solver_compressible_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables a_1 a_4 d_1 d_4 e_1 e_4 g_1 g_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_object Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. real(kind=R8P), public :: d_1 = 0._R8P (gamma-1)/2 of state 1. real(kind=R8P), public :: d_4 = 0._R8P (gamma-1)/2 of state 4. real(kind=R8P), public :: e_1 = 0._R8P 2*g/(g-1) of state 1. real(kind=R8P), public :: e_4 = 0._R8P 2*g/(g-1) of state 4. real(kind=R8P), public :: g_1 = 0._R8P Specific heats ratio gamma=cp/cv of state 1. real(kind=R8P), public :: g_4 = 0._R8P Specific heats ratio gamma=cp/cv of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure( compute_waves_interface ), public, deferred, pass(self) :: compute_waves Compute waves pattern. pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Prototype Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize solver. subroutine initialize_interface (self, config) Prototype Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure( solve_interface ), public, deferred, pass(self) :: solve Solve Riemann Problem. subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Prototype Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_object ), abstract :: riemann_solver_compressible_object !< Riemann solver for ideal compressible fluid object class. !< !< The ideal compressible fluid generates a 3-waves pattern: 2 genuinely non-linear acoustic waves and 1 !< linear-degener contact discontinuity. !< !<``` !<   t &#94;                                . !<     |     S1 _       S2 _            .      _ S       _ S3       _ S4 !<     |       |\\_        |\\_           .      /|      __/|       __/| !<     |          \\__        \\_     U2  .     /  U3  _/       ___/ !<     |             \\___      \\_       .    /    __/     ___/ !<     |                 \\____   \\_     .   /   _/    ___/ !<     |                      \\___ \\_   .  / __/  ___/ !<     |          UL=U1           \\__\\_ . /_/____/          UR=U4 !<     |                              \\\\./// !<  ---+--------------------------------o---------------------------------> !<     |                                xo                                x !<``` real ( R8P ) :: g_1 = 0._R8P !< Specific heats ratio `gamma=cp/cv` of state 1. real ( R8P ) :: d_1 = 0._R8P !< `(gamma-1)/2` of state 1. real ( R8P ) :: e_1 = 0._R8P !< `2*g/(g-1)` of state 1. real ( R8P ) :: u_1 = 0._R8P !< Velocity (normal) of state 1. real ( R8P ) :: p_1 = 0._R8P !< Pressure of state 1. real ( R8P ) :: r_1 = 0._R8P !< Density of state 1. real ( R8P ) :: a_1 = 0._R8P !< Speed of sound of state 1. real ( R8P ) :: g_4 = 0._R8P !< Specific heats ratio `gamma=cp/cv` of state 4. real ( R8P ) :: d_4 = 0._R8P !< `(gamma-1)/2` of state 4. real ( R8P ) :: e_4 = 0._R8P !< `2*g/(g-1)` of state 4. real ( R8P ) :: u_4 = 0._R8P !< Velocity (normal) of state 4. real ( R8P ) :: p_4 = 0._R8P !< Pressure of state 4. real ( R8P ) :: r_4 = 0._R8P !< Density of state 4. real ( R8P ) :: a_4 = 0._R8P !< Speed of sound of state 4. real ( R8P ) :: u23 = 0._R8P !< Velocity (normal) of intermediate states. real ( R8P ) :: p23 = 0._R8P !< Pressure of intermediate states. real ( R8P ) :: r_2 = 0._R8P !< Density of state 2. real ( R8P ) :: r_3 = 0._R8P !< Density of state 3. real ( R8P ) :: s_1 = 0._R8P !< Left-front of left wave. real ( R8P ) :: s_2 = 0._R8P !< Right-front of left wave. real ( R8P ) :: s_3 = 0._R8P !< Left-front of right wave. real ( R8P ) :: s_4 = 0._R8P !< Right-front of right wave. contains ! deferred methods procedure , pass ( self ) :: description !< Return pretty-printed object description. ! public methods procedure , pass ( self ) :: compute_fluxes !< Compute fluxes at interface `x=xo`. procedure , pass ( self ) :: set_states14 !< Set states 1 and 4. endtype riemann_solver_compressible_object","tags":"","loc":"type/riemann_solver_compressible_object.html","title":"riemann_solver_compressible_object – FORESEER "},{"text":"type, public, abstract :: primitive_object Convervative object class. Inherited By type~~primitive_object~~InheritedByGraph type~primitive_object primitive_object type~primitive_compressible primitive_compressible type~primitive_object->type~primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assignment(=) description destroy energy initialize momentum negative operator(*) operator(+) operator(-) operator(/) positive prim_assign_prim prim_divide_real prim_multiply_prim prim_multiply_real real_multiply_prim sub Source Code primitive_object Type-Bound Procedures procedure( symmetric_operator ), public, deferred, pass(lhs) :: add Operator + . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of primitive. pure function array_interface (self) result(array_) Prototype Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy primitive. elemental subroutine destroy_interface (self) Prototype Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. procedure( energy_interface ), public, deferred, pass(self) :: energy Return energy value. elemental function energy_interface (self, eos) result(energy_) Prototype Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize primitive. subroutine initialize_interface (self, initial_state) Prototype Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure( momentum_interface ), public, deferred, pass(self) :: momentum Return momentum vector. elemental function momentum_interface (self) result(momentum_) Prototype Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - prim . function unary_operator (self) result(operator_result) Prototype Unary operator .op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(*) => prim_multiply_prim , prim_multiply_real , real_multiply_prim Overload * . private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(/) => prim_divide_real Overload / . private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + prim . function unary_operator (self) result(operator_result) Prototype Unary operator .op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( assignment_interface ), public, deferred, pass(lhs) :: prim_assign_prim Operator = . pure subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure( prim_operator_real ), public, deferred, pass(lhs) :: prim_divide_real Operator prim / real . function prim_operator_real (lhs, rhs) result(operator_result) Prototype Operator prim.op.real . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: prim_multiply_prim Operator * . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( prim_operator_real ), public, deferred, pass(lhs) :: prim_multiply_real Operator prim * real . function prim_operator_real (lhs, rhs) result(operator_result) Prototype Operator prim.op.real . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( real_operator_prim ), public, deferred, pass(rhs) :: real_multiply_prim Operator real * prim . function real_operator_prim (lhs, rhs) result(operator_result) Prototype Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: sub Operator - . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code type , abstract :: primitive_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of primitive. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy primitive. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return energy value. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize primitive. procedure ( momentum_interface ), pass ( self ), deferred :: momentum !< Return momentum vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: prim_assign_prim !< Operator `=`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_divide_real !< Operator `prim / real`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_multiply_real !< Operator `prim * real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: prim_multiply_prim !< Operator `*`. procedure ( real_operator_prim ), pass ( rhs ), deferred :: real_multiply_prim !< Operator `real * prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- prim`. ! operators generic :: assignment ( = ) => prim_assign_prim !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => prim_multiply_prim , prim_multiply_real , real_multiply_prim !< Overload `*`. generic :: operator ( / ) => prim_divide_real !< Overload `/`. endtype primitive_object","tags":"","loc":"type/primitive_object.html","title":"primitive_object – FORESEER "},{"text":"type, public, extends( integrand ) :: euler_1d type~~euler_1d~~InheritsGraph type~euler_1d euler_1d type~eos_compressible eos_compressible type~eos_compressible->type~euler_1d eos type~conservative_compressible conservative_compressible type~conservative_compressible->type~euler_1d U type~interpolator_object interpolator_object type~interpolator_object->type~euler_1d interpolator type~eos_object eos_object type~eos_object->type~eos_compressible vector vector vector->type~conservative_compressible momentum type~conservative_object conservative_object type~conservative_object->type~conservative_compressible type~interpolations_object interpolations_object type~interpolations_object->type~interpolator_object interpolations type~weights_object weights_object type~weights_object->type~interpolator_object weights type~base_object base_object type~base_object->type~interpolator_object type~base_object->type~interpolations_object type~base_object->type~weights_object type~integrand integrand type~integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an\n ideal (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Variables BC_L BC_R Dx Ng Ni U dummy_to_allow_extensions eos interpolator reconstruct_interfaces riemann_solver weno_order Type-Bound Procedures add assign_integrand assign_real assignment(=) destroy dt impose_boundary_conditions initialize integrand_multiply_integrand integrand_multiply_real local_error operator(*) operator(+) operator(-) operator(.lterror.) output real_multiply_integrand reconstruct_interfaces_characteristic reconstruct_interfaces_conservative reconstruct_interfaces_primitive riemann_solver_llf riemann_solver_pvl sub t Source Code euler_1d Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: BC_L Left boundary condition type. character(len=:), public, allocatable :: BC_R Right boundary condition type. real(kind=R8P), public :: Dx = 0._R8P Space step. integer(kind=I4P), public :: Ng = 0 Ghost cells number. integer(kind=I4P), public :: Ni = 0 Space dimension. type( conservative_compressible ), public, allocatable :: U (:) Integrand (state) variables. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. type( eos_compressible ), public :: eos Equation of state. class( interpolator_object ), public, allocatable :: interpolator WENO interpolator. procedure( reconstruct_interfaces_ ), public, pointer :: reconstruct_interfaces => reconstruct_interfaces_characteristic Reconstruct interface states. procedure( riemann_solver_ ), public, pointer :: riemann_solver => riemann_solver_llf Actual Riemann Problem solver. integer(kind=I4P), public :: weno_order = 0 WENO reconstruction order. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Operator + . private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Operator = . private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => euler_assign_real Operator euler = real . private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_integrand Overloading = assignament. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, steps_max, t_max, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. integer(kind=I4P), intent(in) :: steps_max Maximun number of time steps. real(kind=R8P), intent(in) :: t_max Maximum integration time. real(kind=R8P), intent(in) :: t Time. real(kind=R8P), intent(in) :: CFL CFL value. Return Value real(kind=R8P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, U) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(inout) :: U (1-self%Ng:) Conservative variables. procedure, public, pass(self) :: initialize Initialize field. private subroutine initialize (self, Ni, Dx, BC_L, BC_R, initial_state, eos, weno_order, weno_variables, riemann_solver_scheme) Initialize field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. integer(kind=I4P), intent(in) :: Ni Space dimension. real(kind=R8P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. type( primitive_compressible ), intent(in) :: initial_state (1:) Initial state of primitive variables. type( eos_compressible ), intent(in) :: eos Equation of state. integer(kind=I4P), intent(in), optional :: weno_order WENO reconstruction order. character(len=*), intent(in), optional :: weno_variables Variables on which WENO reconstruction is done. character(len=*), intent(in), optional :: riemann_solver_scheme Riemann solver scheme. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Operator * . private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Operator euler * real . private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => euler_local_error Operator ||euler-euler|| . private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. generic, public :: operator(+) => add Overloading + operator. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. generic, public :: operator(-) => sub Overloading - operator. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self, is_primitive) result(state) Output the Euler field state. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. logical, intent(in), optional :: is_primitive Output in primitive variables. Return Value real(kind=R8P),\n  allocatable, (:,:) Euler state vector. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Operator real * euler . private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure, private, pass(self) :: reconstruct_interfaces_characteristic Reconstruct (charc.) interface states. private subroutine reconstruct_interfaces_characteristic (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, private, pass(self) :: reconstruct_interfaces_conservative Reconstruct (cons.) interface states. private subroutine reconstruct_interfaces_conservative (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, private, pass(self) :: reconstruct_interfaces_primitive Reconstruct (prim.) interface states. private subroutine reconstruct_interfaces_primitive (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, private, pass(self) :: riemann_solver_llf LLF Riemann Problem solver. private subroutine riemann_solver_llf (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: riemann_solver_pvl PVL Riemann Problem solver. private subroutine riemann_solver_pvl (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, public, pass(lhs) :: sub => sub_euler Operator - . private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. real(kind=R8P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Source Code type , extends ( integrand ) :: euler_1d !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an !< ideal (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). integer ( I4P ) :: weno_order = 0 !< WENO reconstruction order. integer ( I4P ) :: Ni = 0 !< Space dimension. integer ( I4P ) :: Ng = 0 !< Ghost cells number. real ( R8P ) :: Dx = 0._R8P !< Space step. type ( eos_compressible ) :: eos !< Equation of state. type ( conservative_compressible ), allocatable :: U (:) !< Integrand (state) variables. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. procedure ( reconstruct_interfaces_ ), pointer :: reconstruct_interfaces => & reconstruct_interfaces_characteristic !< Reconstruct interface states. procedure ( riemann_solver_ ), pointer :: riemann_solver => riemann_solver_llf !< Actual Riemann Problem solver. contains ! auxiliary methods procedure , pass ( self ) :: initialize !< Initialize field. procedure , pass ( self ) :: destroy !< Destroy field. procedure , pass ( self ) :: output !< Extract Euler field. procedure , pass ( self ) :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ) :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ) :: local_error => euler_local_error !< Operator `||euler-euler||`. procedure , pass ( lhs ) :: integrand_multiply_integrand => euler_multiply_euler !< Operator `*`. procedure , pass ( lhs ) :: integrand_multiply_real => euler_multiply_real !< Operator `euler * real`. procedure , pass ( rhs ) :: real_multiply_integrand => real_multiply_euler !< Operator `real * euler`. procedure , pass ( lhs ) :: add => add_euler !< Operator `+`. procedure , pass ( lhs ) :: sub => sub_euler !< Operator `-`. procedure , pass ( lhs ) :: assign_integrand => euler_assign_euler !< Operator `=`. procedure , pass ( lhs ) :: assign_real => euler_assign_real !< Operator `euler = real`. ! private methods procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_characteristic !< Reconstruct (charc.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_conservative !< Reconstruct (cons.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_primitive !< Reconstruct (prim.) interface states. procedure , pass ( self ), private :: riemann_solver_llf !< LLF Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_pvl !< PVL Riemann Problem solver. endtype euler_1d","tags":"","loc":"type/euler_1d.html","title":"euler_1d – FORESEER "},{"text":"type, public, extends( object ) :: command_line_interface type~~command_line_interface~~InheritsGraph type~command_line_interface command_line_interface type~command_line_arguments_group command_line_arguments_group type~command_line_arguments_group->type~command_line_interface clasg type~command_line_argument command_line_argument type~command_line_argument->type~command_line_arguments_group cla type~object object type~object->type~command_line_interface type~object->type~command_line_arguments_group type~object->type~command_line_argument var pantypecommand_line_interfaceInheritsGraph = svgPanZoom('#typecommand_line_interfaceInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Command Line Interface (CLI) class. Variables args authors clasg description disable_hv epilog error error_color error_lun error_message error_style examples help help_color help_markdown help_style is_parsed_ license m_exclude progname usage_lun version version_lun Finalization Procedures finalize Type-Bound Procedures add add_group assign_object assignment(=) check check_m_exclusive cli_assign_cli errored free free_object get get_args get_args_from_invocation get_args_from_string get_cla get_cla_list get_cla_list_varying_I1P get_cla_list_varying_I2P get_cla_list_varying_I4P get_cla_list_varying_I8P get_cla_list_varying_R16P get_cla_list_varying_R4P get_cla_list_varying_R8P get_cla_list_varying_char get_cla_list_varying_logical get_clasg_indexes get_varying init is_defined is_defined_group is_parsed is_passed parse print_error_message print_usage print_version run_command save_man_page save_usage_to_markdown set_mutually_exclusive_groups signature usage Source Code command_line_interface Components Type Visibility Attributes Name Initial character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=:), public, allocatable :: authors Authors list. type( command_line_arguments_group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=:), public, allocatable :: description Detailed description. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), private, allocatable :: examples (:) Examples of correct usage. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. logical, private :: is_parsed_ = .false. Parse status. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: progname Program name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. Type-Bound Procedures procedure, public :: add Add CLA to CLI. private subroutine add (self, pref, group, group_index, switch, switch_ab, help, help_markdown, help_color, help_style, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. character(len=*), intent(in), optional :: help_markdown Longer help message, markdown formatted. character(len=*), intent(in), optional :: help_color ANSI color of help messages. character(len=*), intent(in), optional :: help_style ANSI style of help messages. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: add_group Add CLAs group CLI. private subroutine add_group (self, help, description, exclude, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => cli_assign_cli CLI assignment overloading. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. procedure, private :: check Check data consistency. private subroutine check (self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: cli_assign_cli CLI assignment overloading. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. procedure, private :: errored Trig error occurence and print meaningful message. private subroutine errored (self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. generic, public :: get => get_cla , get_cla_list Get CLA value(s) from CLAs list parsed. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. generic, private :: get_args => get_args_from_string , get_args_from_invocation Get CLAs. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_args_from_string Get CLAs from string. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values from CLAs list parsed, varying size, R16P. private subroutine get_cla_list_varying_R16P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_clasg_indexes Get CLAs groups indexes. private subroutine get_clasg_indexes (self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from CLAs list parsed, varying size list. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: init Initialize CLI. private subroutine init (self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun, error_color, error_style) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help. integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info. integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info. character(len=*), intent(in), optional :: error_color ANSI color of error messages. character(len=*), intent(in), optional :: error_style ANSI style of error messages. procedure, public :: is_defined Check if a CLA has been defined. private function is_defined (self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. procedure, public :: is_defined_group Check if a CLAs group has been defined. private function is_defined_group (self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. procedure, public :: is_parsed Check if CLI has been parsed. private elemental function is_parsed (self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. procedure, public :: is_passed Check if a CLA has been passed. private function is_passed (self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. procedure, public :: parse Parse Command Line Interfaces. private subroutine parse (self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public :: print_usage Print correct usage of CLI. private subroutine print_usage (self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: run_command => is_called_group Check if a CLAs group has been run. private function is_called_group (self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. procedure, public :: save_man_page Save man page build on CLI. private subroutine save_man_page (self, man_file, error) Save man page build on the CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: save_usage_to_markdown Save parts of the CLI as markdown. private subroutine save_usage_to_markdown (self, markdown_file, error) Save the CLI as a markdown page, for inclusion into the documentation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. private subroutine set_mutually_exclusive_groups (self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. procedure, public :: signature Get CLI signature. private function signature (self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value character(len=:),\n  allocatable Signature. procedure, public :: usage Get CLI usage. private function usage (self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),\n  allocatable Usage string. Source Code type , extends ( object ), public :: command_line_interface !< Command Line Interface (CLI) class. private type ( command_line_arguments_group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. logical :: is_parsed_ = . false . !< Parse status. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined_group !< Check if a CLAs group has been defined. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: is_parsed !< Check if CLI has been parsed. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => is_called_group !< Check if a CLAs group has been run. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from CLAs list parsed, varying size list. procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. procedure , public :: save_usage_to_markdown !< Save parts of the CLI as markdown. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check !< Check data consistency. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => & get_args_from_string , & get_args_from_invocation !< Get CLAs. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: cli_assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => cli_assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_interface","tags":"","loc":"type/command_line_interface.html","title":"command_line_interface – FORESEER "},{"text":"type, public, extends( object ) :: command_line_arguments_group type~~command_line_arguments_group~~InheritsGraph type~command_line_arguments_group command_line_arguments_group type~command_line_argument command_line_argument type~command_line_argument->type~command_line_arguments_group cla type~object object type~object->type~command_line_arguments_group type~object->type~command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Command Line Arguments Group (CLAsG) class. CLAsG are useful for building nested commands. Inherited By type~~command_line_arguments_group~~InheritedByGraph type~command_line_arguments_group command_line_arguments_group type~command_line_interface command_line_interface type~command_line_arguments_group->type~command_line_interface clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables Na Na_optional Na_required authors cla description epilog error error_color error_lun error_message error_style group help help_color help_markdown help_style is_called license m_exclude progname usage_lun version version_lun Finalization Procedures finalize Type-Bound Procedures add assign_object assignment(=) check check_m_exclusive clasg_assign_clasg errored free free_object is_defined is_passed is_required_passed parse print_error_message print_version raise_error_m_exclude sanitize_defaults signature usage Source Code command_line_arguments_group Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_optional = 0_I4P Number of optional command line arguments. integer(kind=I4P), private :: Na_required = 0_I4P Number of required command line arguments. character(len=:), public, allocatable :: authors Authors list. type( command_line_argument ), public, allocatable :: cla (:) CLA list [1:Na]. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=:), public, allocatable :: group Group name (command). character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. logical, public :: is_called = .false. Flag for checking if CLAs group has been passed to CLI. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: progname Program name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. Type-Bound Procedures procedure, public :: add Add CLA to CLAsG. private subroutine add (self, pref, cla) Add CLA to CLAs list. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => clasg_assign_clasg Assignment operator overloading. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. procedure, public :: check Check data consistency. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs have been passed. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: clasg_assign_clasg Assignment operator. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. procedure, private :: errored Trig error occurrence and print meaningful message. private subroutine errored (self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public :: is_defined Check if a CLA has been defined. private function is_defined (self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. procedure, public :: is_passed Check if a CLA has been passed. private pure function is_passed (self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. procedure, public :: is_required_passed Check if required CLAs are passed. private subroutine is_required_passed (self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: parse Parse CLAsG arguments. private subroutine parse (self, args, pref) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in) :: args (:) Command line arguments. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: sanitize_defaults Sanitize default values. private subroutine sanitize_defaults (self) Sanitize defaults values. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. procedure, public :: signature Get CLAsG signature. private function signature (self) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. Return Value character(len=:),\n  allocatable Signature. procedure, public :: usage Get correct CLAsG usage. private function usage (self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),\n  allocatable Usage string. Source Code type , extends ( object ) :: command_line_arguments_group !< Command Line Arguments Group (CLAsG) class. !< !< CLAsG are useful for building nested commands. private character ( len = :), allocatable , public :: group !< Group name (command). integer ( I4P ), public :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of required command line arguments. integer ( I4P ) :: Na_optional = 0_I4P !< Number of optional command line arguments. type ( command_line_argument ), allocatable , public :: cla (:) !< CLA list [1:Na]. logical , public :: is_called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLAs are passed. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: add !< Add CLA to CLAsG. procedure , public :: parse !< Parse CLAsG arguments. procedure , public :: usage !< Get correct CLAsG usage. procedure , public :: signature !< Get CLAsG signature. procedure , public :: sanitize_defaults !< Sanitize default values. ! private methods procedure , private :: errored !< Trig error occurrence and print meaningful message. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs have been passed. procedure , private :: clasg_assign_clasg !< Assignment operator. generic , private :: assignment ( = ) => clasg_assign_clasg !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_arguments_group","tags":"","loc":"type/command_line_arguments_group.html","title":"command_line_arguments_group – FORESEER "},{"text":"type, public, extends( object ) :: command_line_argument type~~command_line_argument~~InheritsGraph type~command_line_argument command_line_argument type~object object type~object->type~command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Command Line Argument (CLA) class. Note If not otherwise declared the action on CLA value is set to \"store\" a value. Inherited By type~~command_line_argument~~InheritedByGraph type~command_line_argument command_line_argument type~command_line_arguments_group command_line_arguments_group type~command_line_argument->type~command_line_arguments_group cla type~command_line_interface command_line_interface type~command_line_arguments_group->type~command_line_interface clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables act authors choices def description envvar epilog error error_color error_lun error_message error_style help help_color help_markdown help_style is_hidden is_passed is_positional is_required license m_exclude nargs position progname switch switch_ab usage_lun val version version_lun Finalization Procedures finalize Type-Bound Procedures assign_object assignment(=) check check_action_consistency check_choices check_envvar_consistency check_list_size check_m_exclude_consistency check_named_consistency check_optional_consistency check_positional_consistency cla_assign_cla errored free free_object get get_cla get_cla_from_buffer get_cla_list get_cla_list_from_buffer get_cla_list_varying_I1P get_cla_list_varying_I2P get_cla_list_varying_I4P get_cla_list_varying_I8P get_cla_list_varying_R16P get_cla_list_varying_R4P get_cla_list_varying_R8P get_cla_list_varying_char get_cla_list_varying_logical get_varying is_required_passed print_error_message print_version raise_error_m_exclude raise_error_nargs_insufficient raise_error_switch_unknown raise_error_value_missing sanitize_defaults signature usage Source Code command_line_argument Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: act CLA value action. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), public, allocatable :: def Default value. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: envvar Environment variable from which take value. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. logical, public :: is_hidden = .false. Flag for hiding CLA, thus it does not compare into help. logical, public :: is_passed = .false. Flag for checking if CLA has been passed to CLI. logical, public :: is_positional = .false. Flag for checking if CLA is a positional or a named CLA. logical, public :: is_required = .false. Flag for set required argument. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: nargs Number of arguments consumed by CLA. integer(kind=I4P), public :: position = 0_I4P Position of positional CLA. character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: switch Switch name. character(len=:), public, allocatable :: switch_ab Abbreviated switch name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: val CLA value. character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. Type-Bound Procedures procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => cla_assign_cla Assignment operator overloading. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. procedure, public :: check Check data consistency. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_action_consistency Check CLA action consistency. private subroutine check_action_consistency (self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_choices Check if CLA value is in allowed choices. private subroutine check_choices (self, val, pref) Check if CLA value is in allowed choices. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_envvar_consistency Check data consistency for envvar CLA. private subroutine check_envvar_consistency (self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_list_size Check CLA multiple values list size consistency. private function check_list_size (self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. procedure, private :: check_m_exclude_consistency Check mutually exclusion consistency. private subroutine check_m_exclude_consistency (self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_named_consistency Check named CLA consistency. private subroutine check_named_consistency (self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_optional_consistency Check optional CLA consistency. private subroutine check_optional_consistency (self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_positional_consistency Check positional CLA consistency. private subroutine check_positional_consistency (self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: cla_assign_cla Assignment operator. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. procedure, private :: errored Trig error occurence and print meaningful message. private subroutine errored (self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. generic, public :: get => get_cla , get_cla_list Get CLA value(s). private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. procedure, private :: get_cla Get CLA (single) value. private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_from_buffer Get CLA (single) value from a buffer. private subroutine get_cla_from_buffer (self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list Get CLA multiple values. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. procedure, private :: get_cla_list_from_buffer Get CLA (single) value from a buffer. private subroutine get_cla_list_from_buffer (self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values, varying size, I1P. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values, varying size, I2P. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values, varying size, I4P. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values, varying size, I8P. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values, varying size, R16P. private subroutine get_cla_list_varying_R16P (self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values, varying size, R4P. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values, varying size, R8P. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_char Get CLA multiple values, varying size, char. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_logical Get CLA multiple values, varying size, bool. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from varying size list. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: is_required_passed Check if required CLA is passed. private function is_required_passed (self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_nargs_insufficient Raise error insufficient number of argument values passed. private subroutine raise_error_nargs_insufficient (self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_switch_unknown Raise error switch_unknown. private subroutine raise_error_switch_unknown (self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_value_missing Raise error missing value. private subroutine raise_error_value_missing (self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: sanitize_defaults Sanitize default values. private subroutine sanitize_defaults (self) Sanitize defaults values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. procedure, public :: signature Get signature. private function signature (self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value character(len=:),\n  allocatable Signature. procedure, public :: usage Get correct usage. private function usage (self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),\n  allocatable Usage string. Source Code type , extends ( object ) :: command_line_argument !< Command Line Argument (CLA) class. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable , public :: switch !< Switch name. character ( len = :), allocatable , public :: switch_ab !< Abbreviated switch name. logical , public :: is_required = . false . !< Flag for set required argument. logical , public :: is_positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), public :: position = 0_I4P !< Position of positional CLA. logical , public :: is_passed = . false . !< Flag for checking if CLA has been passed to CLI. logical , public :: is_hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable , public :: act !< CLA value action. character ( len = :), allocatable , public :: def !< Default value. character ( len = :), allocatable , public :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable , public :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable , public :: val !< CLA value. character ( len = :), allocatable , public :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLA is passed. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: raise_error_nargs_insufficient !< Raise error insufficient number of argument values passed. procedure , public :: raise_error_value_missing !< Raise error missing value. procedure , public :: raise_error_switch_unknown !< Raise error switch_unknown. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s). generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from varying size list. procedure , public :: sanitize_defaults !< Sanitize default values. procedure , public :: usage !< Get correct usage. procedure , public :: signature !< Get signature. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check_envvar_consistency !< Check data consistency for envvar CLA. procedure , private :: check_action_consistency !< Check CLA action consistency. procedure , private :: check_optional_consistency !< Check optional CLA consistency. procedure , private :: check_m_exclude_consistency !< Check mutually exclusion consistency. procedure , private :: check_named_consistency !< Check named CLA consistency. procedure , private :: check_positional_consistency !< Check positional CLA consistency. procedure , private :: check_choices !< Check if CLA value is in allowed choices. procedure , private :: check_list_size !< Check CLA multiple values list size consistency. procedure , private :: get_cla !< Get CLA (single) value. procedure , private :: get_cla_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list !< Get CLA multiple values. procedure , private :: get_cla_list_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values, varying size, char. procedure , private :: cla_assign_cla !< Assignment operator. generic , private :: assignment ( = ) => cla_assign_cla !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_argument","tags":"","loc":"type/command_line_argument.html","title":"command_line_argument – FORESEER "},{"text":"type, public, abstract :: object Base (abstract) class upon which FLAP's concrete classes are built. Inherited By type~~object~~InheritedByGraph type~object object type~command_line_interface command_line_interface type~object->type~command_line_interface type~command_line_argument command_line_argument type~object->type~command_line_argument type~command_line_arguments_group command_line_arguments_group type~object->type~command_line_arguments_group type~command_line_argument->type~command_line_arguments_group cla type~command_line_arguments_group->type~command_line_interface clasg var pantypeobjectInheritedByGraph = svgPanZoom('#typeobjectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables authors description epilog error error_color error_lun error_message error_style help help_color help_markdown help_style license m_exclude progname usage_lun version version_lun Type-Bound Procedures assign_object free_object print_error_message print_version Source Code object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: progname Program name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Type-Bound Procedures procedure, public, pass(lhs ) :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public, pass(self) :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public, pass(self) :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public, pass(self) :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code type , abstract , public :: object !< Base (abstract) class upon which FLAP's concrete classes are built. character ( len = :), allocatable :: progname !< Program name. character ( len = :), allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), allocatable :: help_color !< ANSI color of help messages. character ( len = :), allocatable :: help_style !< ANSI style of help messages. character ( len = :), allocatable :: help_markdown !< Longer help message, markdown formatted. character ( len = :), allocatable :: description !< Detailed description. character ( len = :), allocatable :: license !< License description. character ( len = :), allocatable :: authors !< Authors list. character ( len = :), allocatable :: epilog !< Epilogue message. character ( len = :), allocatable :: m_exclude !< Mutually exclude other CLA(s group). character ( len = :), allocatable :: error_message !< Meaningful error message to standard-error. character ( len = :), allocatable :: error_color !< ANSI color of error messages. character ( len = :), allocatable :: error_style !< ANSI style of error messages. integer ( I4P ) :: error = 0_I4P !< Error trapping flag. integer ( I4P ) :: usage_lun = stderr !< Output unit to print help/usage messages integer ( I4P ) :: version_lun = stdout !< Output unit to print version message integer ( I4P ) :: error_lun = stderr !< Error unit to print error messages contains ! public methods procedure , pass ( self ) :: free_object !< Free dynamic memory. procedure , pass ( self ) :: print_version !< Print version. procedure , pass ( self ) :: print_error_message !< Print meaningful error message. procedure , pass ( lhs ) :: assign_object !< Assignment overloading. endtype object","tags":"","loc":"type/object.html","title":"object – FORESEER "},{"text":"type, public :: back_df_integrator FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order\n accurate. Note The integrator must be created or initialized (initialize the alpha and beta coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps; Variables a b error steps Type-Bound Procedures destroy init integrate is_supported max_steps min_steps update_previous Source Code back_df_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: a (:) \\alpha coefficients. real(kind=R_P), private :: b = 0.0_R_P \\beta coefficient. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: steps = 0 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Create the actual BDF integrator: initialize the alpha and beta coefficients. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . procedure, public, nopass :: max_steps Return the maximum number of steps supported. private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Source Code type :: back_df_integrator !< FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order !< accurate. !< !< @note The integrator must be created or initialized (initialize the *alpha* and *beta* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: a (:) !< \\alpha coefficients. real ( R_P ) :: b = 0.0_R_P !< \\beta coefficient. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype back_df_integrator","tags":"","loc":"type/back_df_integrator.html","title":"back_df_integrator – FORESEER "},{"text":"type, public, abstract :: integrand Abstract type for building FOODIE ODE integrators. Inherited By type~~integrand~~InheritedByGraph type~integrand integrand type~euler_1d euler_1d type~integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables dummy_to_allow_extensions Type-Bound Procedures add assign_integrand assignment(=) integrand_multiply_integrand integrand_multiply_real local_error operator(*) operator(+) operator(-) operator(.lterror.) real_multiply_integrand sub t Source Code integrand Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure( symmetric_operator ), public, deferred, pass(lhs) :: add Integrand + integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure( assignment_integrand ), public, deferred, pass(lhs) :: assign_integrand Integrand = integrand. pure subroutine assignment_integrand (lhs, rhs) Prototype Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_integrand Overloading = assignament. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_multiply_integrand Integrand * integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_multiply_real Integrand * real operator. function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure( local_error_operator ), public, deferred, pass(lhs) :: local_error ||integrand - integrand||. function local_error_operator (lhs, rhs) result(error) Prototype Estimate local truncation error between 2 solution approximations. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. generic, public :: operator(+) => add Overloading + operator. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. generic, public :: operator(-) => sub Overloading - operator. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_multiply_integrand Real * integrand operator. function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: sub Integrand - integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. procedure( time_derivative ), public, deferred, pass(self) :: t Time derivative, residuals. function time_derivative (self, t) result(dState_dt) Prototype Time derivative function of integrand class, i.e. the residuals function. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Source Code type , abstract :: integrand !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< ||integrand - integrand||. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand operator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. ! operators overloading generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – FORESEER "},{"text":"type, public :: tvd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required stages; Variables alph beta error gamm stages Type-Bound Procedures destroy init integrate is_supported max_stages min_stages Source Code tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:) \\beta Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. private elemental function is_supported (stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . procedure, public, nopass :: max_stages Return the maximum number of stages supported. private pure function max_stages () Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. procedure, public, nopass :: min_stages Return the minimum number of stages supported. private pure function min_stages () Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Source Code type :: tvd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FORESEER "},{"text":"type, public :: euler_explicit_integrator FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures integrate is_supported max_stages_steps min_stages_steps Source Code euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private subroutine integrate (U, Dt, t) Integrate field with explicit Euler scheme, 1st order. Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. procedure, public, nopass :: is_supported Check if the queried number of stages/steps is supported or not. private elemental function is_supported (stages_steps) Check if the queried number of stages/steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. Return Value logical Is true is the stages number is in supported_stages_steps . procedure, public, nopass :: max_stages_steps Return the maximum number of stages/steps supported. private pure function max_stages_steps () Return the maximum number of stages/steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages/steps supported. procedure, public, nopass :: min_stages_steps Return the minimum number of stages/steps supported. private pure function min_stages_steps () Return the minimum number of stages/steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages/steps supported. Source Code type :: euler_explicit_integrator !< FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. private contains private procedure , nopass , public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages_steps !< Return the minimum number of stages/steps supported. procedure , nopass , public :: max_stages_steps !< Return the maximum number of stages/steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages/steps is supported or not. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – FORESEER "},{"text":"type, public :: leapfrog_integrator FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values\n are suitable for the problem. Variables alpha nu Type-Bound Procedures init integrate is_supported max_steps min_steps Source Code leapfrog_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, nu, alpha) Create the actual leapfrog integrator: initialize the filter coefficient. Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, filter) Integrate field with leapfrog class scheme. Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . procedure, public, nopass :: max_steps Return the maximum number of steps supported. private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code type :: leapfrog_integrator !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.53_R_P !< Robert-Asselin-Williams filter coefficient. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype leapfrog_integrator","tags":"","loc":"type/leapfrog_integrator.html","title":"leapfrog_integrator – FORESEER "},{"text":"type, public :: adams_bashforth_integrator FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps; Inherited By type~~adams_bashforth_integrator~~InheritedByGraph type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables b error steps Type-Bound Procedures destroy init integrate is_supported max_steps min_steps update_previous Source Code adams_bashforth_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: steps = 0 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Create the actual Adams-Bashforth integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, autoupdate) Integrate field with Adams-Bashforth class scheme. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . procedure, public, nopass :: max_steps Return the maximum number of steps supported. private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Source Code type :: adams_bashforth_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< *b* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype adams_bashforth_integrator","tags":"","loc":"type/adams_bashforth_integrator.html","title":"adams_bashforth_integrator – FORESEER "},{"text":"type, public :: adams_moulton_integrator FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps; Inherited By type~~adams_moulton_integrator~~InheritedByGraph type~adams_moulton_integrator adams_moulton_integrator type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables b error steps Type-Bound Procedures destroy init integrate is_supported max_steps min_steps update_previous Source Code adams_moulton_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: steps = -1 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Create the actual Adams-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Integrate field with Adams-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . procedure, public, nopass :: max_steps Return the maximum number of steps supported. private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. private subroutine update_previous (self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Source Code type :: adams_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , pass ( self ), public :: update_previous !< Cyclic update previous time steps. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype adams_moulton_integrator","tags":"","loc":"type/adams_moulton_integrator.html","title":"adams_moulton_integrator – FORESEER "},{"text":"type, public :: ls_runge_kutta_integrator FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required stages; Variables A B C error stages Type-Bound Procedures destroy init integrate is_supported max_stages min_stages used_registers Source Code ls_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), private, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), private, allocatable :: C (:) Low storage C coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages) Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Integrate field with explicit low storage Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:registers) Runge-Kutta registers. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. private elemental function is_supported (stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . procedure, public, nopass :: max_stages Return the maximum number of stages supported. private pure function max_stages () Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. procedure, public, nopass :: min_stages Return the minimum number of stages supported. private pure function min_stages () Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. procedure, public, nopass :: used_registers Return the number of registers used. private pure function used_registers () Return the number of registers used. Arguments None Return Value integer(kind=I_P) Number of registers used. Source Code type :: ls_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: used_registers !< Return the number of registers used. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. endtype ls_runge_kutta_integrator","tags":"","loc":"type/ls_runge_kutta_integrator.html","title":"ls_runge_kutta_integrator – FORESEER "},{"text":"type, public :: emd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required stages; Variables alph beta error gamm pp1_inv stages tolerance Type-Bound Procedures destroy init integrate is_supported max_stages min_stages new_Dt Source Code emd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:,:) \\beta Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. real(kind=R_P), private :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private :: tolerance = 0._R_P Tolerance on the local truncation error. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages, tolerance) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, stage, Dt, t) Integrate field with explicit embedded Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. private elemental function is_supported (stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . procedure, public, nopass :: max_stages Return the maximum number of stages supported. private pure function max_stages () Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. procedure, public, nopass :: min_stages Return the minimum number of stages supported. private pure function min_stages () Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. private elemental subroutine new_Dt (self, error, Dt) Compute new estimation of the time step Dt. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Source Code type :: emd_runge_kutta_integrator !< FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required stages; private real ( R_P ) :: tolerance = 0._R_P !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv = 0._R_P !< 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_stages !< Return the minimum number of stages supported. procedure , nopass , public :: max_stages !< Return the maximum number of stages supported. procedure , nopass , public :: is_supported !< Check if the queried number of stages is supported or not. procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. endtype emd_runge_kutta_integrator","tags":"","loc":"type/emd_runge_kutta_integrator.html","title":"emd_runge_kutta_integrator – FORESEER "},{"text":"type, public :: adams_bashforth_moulton_integrator type~~adams_bashforth_moulton_integrator~~InheritsGraph type~adams_bashforth_moulton_integrator adams_bashforth_moulton_integrator type~adams_moulton_integrator adams_moulton_integrator type~adams_moulton_integrator->type~adams_bashforth_moulton_integrator corrector type~adams_bashforth_integrator adams_bashforth_integrator type~adams_bashforth_integrator->type~adams_bashforth_moulton_integrator predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (predictor and corrector schemes selection) before used. ### List of errors status\n+ error=0 => no error;\n+ error=1 => bad (unsupported) number of required time steps; Variables corrector error predictor steps Type-Bound Procedures destroy init integrate is_supported max_steps min_steps Source Code adams_bashforth_moulton_integrator Components Type Visibility Attributes Name Initial type( adams_moulton_integrator ), private :: corrector Corrector solver. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. type( adams_bashforth_integrator ), private :: predictor Predictor solver. integer(kind=I_P), private :: steps = -1 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, steps) Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, previous, Dt, t, iterations) Integrate field with Adams-Bashforth-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . procedure, public, nopass :: max_steps Return the maximum number of steps supported. private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code type :: adams_bashforth_moulton_integrator !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. !< !< ### List of errors status !<+ error=0 => no error; !<+ error=1 => bad (unsupported) number of required time steps; private integer ( I_P ) :: steps =- 1 !< Number of time steps. type ( adams_bashforth_integrator ) :: predictor !< Predictor solver. type ( adams_moulton_integrator ) :: corrector !< Corrector solver. integer ( I_P ) :: error = 0 !< Error status flag: trap occurrences of errors. contains private procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. procedure , nopass , public :: min_steps !< Return the minimum number of steps supported. procedure , nopass , public :: max_steps !< Return the maximum number of steps supported. procedure , nopass , public :: is_supported !< Check if the queried number of steps is supported or not. endtype adams_bashforth_moulton_integrator","tags":"","loc":"type/adams_bashforth_moulton_integrator.html","title":"adams_bashforth_moulton_integrator – FORESEER "},{"text":"type, public, abstract, extends( base_object ) :: interpolations_object type~~interpolations_object~~InheritsGraph type~interpolations_object interpolations_object type~base_object base_object type~base_object->type~interpolations_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract interpolations object. Inherited By type~~interpolations_object~~InheritedByGraph type~interpolations_object interpolations_object type~interpolator_object interpolator_object type~interpolations_object->type~interpolator_object interpolations type~reconstructor_js reconstructor_js type~interpolations_object->type~reconstructor_js interpolations type~interpolator_js interpolator_js type~interpolations_object->type~interpolator_js interpolations type~interpolations_rec_js interpolations_rec_js type~interpolations_object->type~interpolations_rec_js type~interpolator_object->type~reconstructor_js type~interpolator_object->type~interpolator_js type~euler_1d euler_1d type~interpolator_object->type~euler_1d interpolator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ Source Code interpolations_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Stencil interpolations values [1:2,0:S-1]. Type-Bound Procedures procedure( compute_interface ), public, deferred, pass(self) :: compute Compute beta. pure subroutine compute_interface (self, stencil) Prototype Compute interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_object ), intent(inout) :: self Interpolations. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( base_object ), abstract :: interpolations_object !< Abstract interpolations object. real ( RPP ), allocatable :: values (:,:) !< Stencil interpolations values [1:2,0:S-1]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute beta. endtype interpolations_object","tags":"","loc":"type/interpolations_object.html","title":"interpolations_object – FORESEER "},{"text":"type, public, abstract, extends( base_object_constructor ) :: interpolations_object_constructor type~~interpolations_object_constructor~~InheritsGraph type~interpolations_object_constructor interpolations_object_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~interpolations_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract interpolations object constructor. Inherited By type~~interpolations_object_constructor~~InheritedByGraph type~interpolations_object_constructor interpolations_object_constructor type~reconstructor_js_constructor reconstructor_js_constructor type~interpolations_object_constructor->type~reconstructor_js_constructor interpolations_constructor type~interpolator_object_constructor interpolator_object_constructor type~interpolations_object_constructor->type~interpolator_object_constructor interpolations_constructor type~interpolator_js_constructor interpolator_js_constructor type~interpolations_object_constructor->type~interpolator_js_constructor interpolations_constructor type~interpolations_rec_js_constructor interpolations_rec_js_constructor type~interpolations_object_constructor->type~interpolations_rec_js_constructor type~interpolator_object_constructor->type~reconstructor_js_constructor type~interpolator_object_constructor->type~interpolator_js_constructor var pantypeinterpolations_object_constructorInheritedByGraph = svgPanZoom('#typeinterpolations_object_constructorInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right Type-Bound Procedures create Source Code interpolations_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( base_object_constructor ), abstract :: interpolations_object_constructor !< Abstract interpolations object constructor. endtype interpolations_object_constructor","tags":"","loc":"type/interpolations_object_constructor.html","title":"interpolations_object_constructor – FORESEER "},{"text":"type, public, abstract, extends( base_object ) :: interpolator_object type~~interpolator_object~~InheritsGraph type~interpolator_object interpolator_object type~interpolations_object interpolations_object type~interpolations_object->type~interpolator_object interpolations type~weights_object weights_object type~weights_object->type~interpolator_object weights type~base_object base_object type~base_object->type~interpolator_object type~base_object->type~interpolations_object type~base_object->type~weights_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract interpolator object. Note Do not implement any actual interpolator: provide the interface for the different interpolators implemented. Inherited By type~~interpolator_object~~InheritedByGraph type~interpolator_object interpolator_object type~euler_1d euler_1d type~interpolator_object->type~euler_1d interpolator type~reconstructor_js reconstructor_js type~interpolator_object->type~reconstructor_js type~interpolator_js interpolator_js type~interpolator_object->type~interpolator_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff interpolations weights Type-Bound Procedures create create_ description destroy destroy_ interpolate interpolate_debug interpolate_standard Source Code interpolator_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( interpolations_object ), public, allocatable :: interpolations Stencil interpolations. class( weights_object ), public, allocatable :: weights Weights of interpolations. Type-Bound Procedures procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. generic, public :: interpolate => interpolate_standard , interpolate_debug Interpolate values. private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. procedure( interpolate_debug_interface ), public, deferred, pass(self) :: interpolate_debug Interpolate values, debug mode. pure subroutine interpolate_debug_interface (self, stencil, interpolation, si, weights) Prototype Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( interpolator_object ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. procedure( interpolate_standard_interface ), public, deferred, pass(self) :: interpolate_standard Interpolate values, standard mode. pure subroutine interpolate_standard_interface (self, stencil, interpolation) Prototype Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( interpolator_object ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Source Code type , extends ( base_object ), abstract :: interpolator_object !< Abstract interpolator object. !< !< @note Do not implement any actual interpolator: provide the interface for the different interpolators implemented. class ( interpolations_object ), allocatable :: interpolations !< Stencil interpolations. class ( weights_object ), allocatable :: weights !< Weights of interpolations. contains ! public deferred methods procedure ( interpolate_debug_interface ), pass ( self ), deferred :: interpolate_debug !< Interpolate values, debug mode. procedure ( interpolate_standard_interface ), pass ( self ), deferred :: interpolate_standard !< Interpolate values, standard mode. ! public methods generic :: interpolate => interpolate_standard , interpolate_debug !< Interpolate values. endtype interpolator_object","tags":"","loc":"type/interpolator_object.html","title":"interpolator_object – FORESEER "},{"text":"type, public, abstract, extends( base_object_constructor ) :: interpolator_object_constructor type~~interpolator_object_constructor~~InheritsGraph type~interpolator_object_constructor interpolator_object_constructor type~interpolations_object_constructor interpolations_object_constructor type~interpolations_object_constructor->type~interpolator_object_constructor interpolations_constructor type~weights_object_constructor weights_object_constructor type~weights_object_constructor->type~interpolator_object_constructor weights_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~interpolator_object_constructor type~base_object_constructor->type~interpolations_object_constructor type~base_object_constructor->type~weights_object_constructor var pantypeinterpolator_object_constructorInheritsGraph = svgPanZoom('#typeinterpolator_object_constructorInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract interpolator object constructor. Note Every concrete WENO interpolator implementations must define their own constructor type. Inherited By type~~interpolator_object_constructor~~InheritedByGraph type~interpolator_object_constructor interpolator_object_constructor type~reconstructor_js_constructor reconstructor_js_constructor type~interpolator_object_constructor->type~reconstructor_js_constructor type~interpolator_js_constructor interpolator_js_constructor type~interpolator_object_constructor->type~interpolator_js_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right interpolations_constructor weights_constructor Type-Bound Procedures create Source Code interpolator_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( interpolations_object_constructor ), public, allocatable :: interpolations_constructor Stencil interpolations constructor. class( weights_object_constructor ), public, allocatable :: weights_constructor Weights of interpolations constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( base_object_constructor ), abstract :: interpolator_object_constructor !< Abstract interpolator object constructor. !< !< @note Every concrete WENO interpolator implementations must define their own constructor type. class ( interpolations_object_constructor ), allocatable :: interpolations_constructor !< Stencil interpolations constructor. class ( weights_object_constructor ), allocatable :: weights_constructor !< Weights of interpolations constructor. endtype interpolator_object_constructor","tags":"","loc":"type/interpolator_object_constructor.html","title":"interpolator_object_constructor – FORESEER "},{"text":"type, public, abstract, extends( base_object ) :: beta_object type~~beta_object~~InheritsGraph type~beta_object beta_object type~base_object base_object type~base_object->type~beta_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. Inherited By type~~beta_object~~InheritedByGraph type~beta_object beta_object type~weights_js weights_js type~beta_object->type~weights_js beta type~beta_rec_js beta_rec_js type~beta_object->type~beta_rec_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ Source Code beta_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Beta values [1:2,0:S-1]. Type-Bound Procedures procedure( compute_interface ), public, deferred, pass(self) :: compute Compute beta. pure subroutine compute_interface (self, stencil) Prototype Compute beta. Arguments Type Intent Optional Attributes Name class( beta_object ), intent(inout) :: self Beta. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( base_object ), abstract :: beta_object !< Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. real ( RPP ), allocatable :: values (:,:) !< Beta values [1:2,0:S-1]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute beta. endtype beta_object","tags":"","loc":"type/beta_object.html","title":"beta_object – FORESEER "},{"text":"type, public, abstract, extends( base_object_constructor ) :: beta_object_constructor type~~beta_object_constructor~~InheritsGraph type~beta_object_constructor beta_object_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~beta_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract Beta coefficients object constructor. Inherited By type~~beta_object_constructor~~InheritedByGraph type~beta_object_constructor beta_object_constructor type~weights_js_constructor weights_js_constructor type~beta_object_constructor->type~weights_js_constructor beta_constructor type~beta_rec_js_constructor beta_rec_js_constructor type~beta_object_constructor->type~beta_rec_js_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right Type-Bound Procedures create Source Code beta_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( base_object_constructor ), abstract :: beta_object_constructor !< Abstract Beta coefficients object constructor. endtype beta_object_constructor","tags":"","loc":"type/beta_object_constructor.html","title":"beta_object_constructor – FORESEER "},{"text":"type, public, abstract, extends( base_object ) :: weights_object type~~weights_object~~InheritsGraph type~weights_object weights_object type~base_object base_object type~base_object->type~weights_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Weights of stencil interpolations object. Inherited By type~~weights_object~~InheritedByGraph type~weights_object weights_object type~interpolator_object interpolator_object type~weights_object->type~interpolator_object weights type~reconstructor_js reconstructor_js type~weights_object->type~reconstructor_js weights type~interpolator_js interpolator_js type~weights_object->type~interpolator_js weights type~weights_js weights_js type~weights_object->type~weights_js type~interpolator_object->type~reconstructor_js type~interpolator_object->type~interpolator_js type~euler_1d euler_1d type~interpolator_object->type~euler_1d interpolator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ smoothness_indicators Source Code weights_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Weights values of stencil interpolations [1:2,0:S-1]. Type-Bound Procedures procedure( compute_interface ), public, deferred, pass(self) :: compute Compute weights. pure subroutine compute_interface (self, stencil) Prototype Compute beta. Arguments Type Intent Optional Attributes Name class( weights_object ), intent(inout) :: self Weights. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure( smoothness_indicators_interface ), public, deferred, pass(self) :: smoothness_indicators Return smoothness indicators. pure function smoothness_indicators_interface (self) result(si) Prototype Return smoothness indicators. Arguments Type Intent Optional Attributes Name class( weights_object ), intent(in) :: self Weights. Return Value real(kind=RPP),\n  allocatable, (:,:) Smoothness indicators. Source Code type , extends ( base_object ), abstract :: weights_object !< Weights of stencil interpolations object. real ( RPP ), allocatable :: values (:,:) !< Weights values of stencil interpolations [1:2,0:S-1]. contains ! deferred public methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute weights. procedure ( smoothness_indicators_interface ), pass ( self ), deferred :: smoothness_indicators !< Return smoothness indicators. endtype weights_object","tags":"","loc":"type/weights_object.html","title":"weights_object – FORESEER "},{"text":"type, public, extends( base_object_constructor ) :: weights_object_constructor type~~weights_object_constructor~~InheritsGraph type~weights_object_constructor weights_object_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~weights_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract weights object constructor. Inherited By type~~weights_object_constructor~~InheritedByGraph type~weights_object_constructor weights_object_constructor type~reconstructor_js_constructor reconstructor_js_constructor type~weights_object_constructor->type~reconstructor_js_constructor weights_constructor type~interpolator_object_constructor interpolator_object_constructor type~weights_object_constructor->type~interpolator_object_constructor weights_constructor type~interpolator_js_constructor interpolator_js_constructor type~weights_object_constructor->type~interpolator_js_constructor weights_constructor type~weights_js_constructor weights_js_constructor type~weights_object_constructor->type~weights_js_constructor type~interpolator_object_constructor->type~reconstructor_js_constructor type~interpolator_object_constructor->type~interpolator_js_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right Type-Bound Procedures create Source Code weights_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( base_object_constructor ) :: weights_object_constructor !< Abstract weights object constructor. endtype weights_object_constructor","tags":"","loc":"type/weights_object_constructor.html","title":"weights_object_constructor – FORESEER "},{"text":"type, public, abstract, extends( base_object ) :: alpha_object type~~alpha_object~~InheritsGraph type~alpha_object alpha_object type~base_object base_object type~base_object->type~alpha_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract alpha (non linear weights) object. Inherited By type~~alpha_object~~InheritedByGraph type~alpha_object alpha_object type~alpha_rec_m alpha_rec_m type~alpha_object->type~alpha_rec_m alpha_base type~alpha_object->type~alpha_rec_m type~weights_js weights_js type~alpha_object->type~weights_js alpha type~alpha_rec_z alpha_rec_z type~alpha_object->type~alpha_rec_z type~alpha_rec_js alpha_rec_js type~alpha_object->type~alpha_rec_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff values values_sum Type-Bound Procedures compute create create_ description destroy destroy_ Source Code alpha_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure( compute_interface ), public, deferred, pass(self) :: compute Compute alpha. pure subroutine compute_interface (self, beta, kappa) Prototype Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_object ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( base_object ), abstract :: alpha_object !< Abstract alpha (non linear weights) object. real ( RPP ), allocatable :: values (:,:) !< Alpha coefficients [1:2,0:S-1]. real ( RPP ), allocatable :: values_sum (:) !< Sum of alpha coefficients [1:2]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute alpha. endtype alpha_object","tags":"","loc":"type/alpha_object.html","title":"alpha_object – FORESEER "},{"text":"type, public, abstract, extends( base_object_constructor ) :: alpha_object_constructor type~~alpha_object_constructor~~InheritsGraph type~alpha_object_constructor alpha_object_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~alpha_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract alpha (non linear weights) object constructor. Inherited By type~~alpha_object_constructor~~InheritedByGraph type~alpha_object_constructor alpha_object_constructor type~weights_js_constructor weights_js_constructor type~alpha_object_constructor->type~weights_js_constructor alpha_constructor type~alpha_rec_js_constructor alpha_rec_js_constructor type~alpha_object_constructor->type~alpha_rec_js_constructor type~alpha_rec_m_constructor alpha_rec_m_constructor type~alpha_object_constructor->type~alpha_rec_m_constructor type~alpha_rec_z_constructor alpha_rec_z_constructor type~alpha_object_constructor->type~alpha_rec_z_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right Type-Bound Procedures create Source Code alpha_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( base_object_constructor ), abstract :: alpha_object_constructor !< Abstract alpha (non linear weights) object constructor. contains endtype alpha_object_constructor","tags":"","loc":"type/alpha_object_constructor.html","title":"alpha_object_constructor – FORESEER "},{"text":"type, public, abstract :: base_object Abstract base object, the ancestor of all. Define a minimal, base, object that is used as ancestor of all objects, e.g. smoothness indicator, optimal weights, etc… Inherited By type~~base_object~~InheritedByGraph type~base_object base_object type~interpolations_object interpolations_object type~base_object->type~interpolations_object type~alpha_object alpha_object type~base_object->type~alpha_object type~interpolator_object interpolator_object type~base_object->type~interpolator_object type~kappa_object kappa_object type~base_object->type~kappa_object type~weights_object weights_object type~base_object->type~weights_object type~beta_object beta_object type~base_object->type~beta_object type~interpolations_object->type~interpolator_object interpolations type~reconstructor_js reconstructor_js type~interpolations_object->type~reconstructor_js interpolations type~interpolator_js interpolator_js type~interpolations_object->type~interpolator_js interpolations type~interpolations_rec_js interpolations_rec_js type~interpolations_object->type~interpolations_rec_js type~alpha_rec_m alpha_rec_m type~alpha_object->type~alpha_rec_m alpha_base type~alpha_object->type~alpha_rec_m type~weights_js weights_js type~alpha_object->type~weights_js alpha type~alpha_rec_z alpha_rec_z type~alpha_object->type~alpha_rec_z type~alpha_rec_js alpha_rec_js type~alpha_object->type~alpha_rec_js type~interpolator_object->type~reconstructor_js type~interpolator_object->type~interpolator_js type~euler_1d euler_1d type~interpolator_object->type~euler_1d interpolator type~kappa_object->type~weights_js kappa type~kappa_rec_js kappa_rec_js type~kappa_object->type~kappa_rec_js type~weights_object->type~interpolator_object weights type~weights_object->type~reconstructor_js weights type~weights_object->type~interpolator_js weights type~weights_object->type~weights_js type~beta_object->type~weights_js beta type~beta_rec_js beta_rec_js type~beta_object->type~beta_rec_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff Type-Bound Procedures create create_ description destroy destroy_ Source Code base_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. Type-Bound Procedures procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , abstract :: base_object !< Abstract base object, the ancestor of all. !< !< Define a minimal, base, object that is used as ancestor of all objects, e.g. smoothness indicator, optimal weights, etc... integer ( I_P ) :: S = 0_I_P !< Stencils dimension. integer ( I_P ) :: f1 = 1_I_P !< Lower bound of faces index. integer ( I_P ) :: f2 = 2_I_P !< Upper bound of faces index. integer ( I_P ) :: ff = 0_I_P !< Offset (step) of faces index. real ( RPP ) :: eps = EPS_DEF !< Small epsilon to avoid division by zero. contains ! public deferred methods procedure ( create_interface ), pass ( self ), deferred :: create !< Create object. procedure ( description_interface ), pass ( self ), deferred :: description !< Return object string-description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy object. ! public non overridable methods procedure , pass ( self ), non_overridable :: create_ !< Create object. procedure , pass ( self ), non_overridable :: destroy_ !< Destroy object. endtype base_object","tags":"","loc":"type/base_object.html","title":"base_object – FORESEER "},{"text":"type, public, abstract :: base_object_constructor Abstract base object constructor. Inherited By type~~base_object_constructor~~InheritedByGraph type~base_object_constructor base_object_constructor type~alpha_object_constructor alpha_object_constructor type~base_object_constructor->type~alpha_object_constructor type~beta_object_constructor beta_object_constructor type~base_object_constructor->type~beta_object_constructor type~interpolations_object_constructor interpolations_object_constructor type~base_object_constructor->type~interpolations_object_constructor type~kappa_object_constructor kappa_object_constructor type~base_object_constructor->type~kappa_object_constructor type~weights_object_constructor weights_object_constructor type~base_object_constructor->type~weights_object_constructor type~interpolator_object_constructor interpolator_object_constructor type~base_object_constructor->type~interpolator_object_constructor type~weights_js_constructor weights_js_constructor type~alpha_object_constructor->type~weights_js_constructor alpha_constructor type~alpha_rec_js_constructor alpha_rec_js_constructor type~alpha_object_constructor->type~alpha_rec_js_constructor type~alpha_rec_m_constructor alpha_rec_m_constructor type~alpha_object_constructor->type~alpha_rec_m_constructor type~alpha_rec_z_constructor alpha_rec_z_constructor type~alpha_object_constructor->type~alpha_rec_z_constructor type~beta_object_constructor->type~weights_js_constructor beta_constructor type~beta_rec_js_constructor beta_rec_js_constructor type~beta_object_constructor->type~beta_rec_js_constructor type~interpolations_object_constructor->type~interpolator_object_constructor interpolations_constructor type~reconstructor_js_constructor reconstructor_js_constructor type~interpolations_object_constructor->type~reconstructor_js_constructor interpolations_constructor type~interpolator_js_constructor interpolator_js_constructor type~interpolations_object_constructor->type~interpolator_js_constructor interpolations_constructor type~interpolations_rec_js_constructor interpolations_rec_js_constructor type~interpolations_object_constructor->type~interpolations_rec_js_constructor type~kappa_object_constructor->type~weights_js_constructor kappa_constructor type~kappa_rec_js_constructor kappa_rec_js_constructor type~kappa_object_constructor->type~kappa_rec_js_constructor type~weights_object_constructor->type~interpolator_object_constructor weights_constructor type~weights_object_constructor->type~weights_js_constructor type~weights_object_constructor->type~reconstructor_js_constructor weights_constructor type~weights_object_constructor->type~interpolator_js_constructor weights_constructor type~interpolator_object_constructor->type~reconstructor_js_constructor type~interpolator_object_constructor->type~interpolator_js_constructor var pantypebase_object_constructorInheritedByGraph = svgPanZoom('#typebase_object_constructorInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right Type-Bound Procedures create Source Code base_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , abstract :: base_object_constructor !< Abstract base object constructor. integer ( I_P ) :: S = 0_I_P !< Stencils dimension. logical :: face_left = . true . !< Activate left-face interpolation computation. logical :: face_right = . true . !< Activate right-face interpolation computation. real ( RPP ) :: eps = EPS_DEF !< Small epsilon to avoid division by zero. contains procedure , pass ( self ) :: create => create_base_object_constructor endtype base_object_constructor","tags":"","loc":"type/base_object_constructor.html","title":"base_object_constructor – FORESEER "},{"text":"type, public, abstract, extends( base_object ) :: kappa_object type~~kappa_object~~InheritsGraph type~kappa_object kappa_object type~base_object base_object type~base_object->type~kappa_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Kappa (optimal, linear weights of stencil interpolations) object. Inherited By type~~kappa_object~~InheritedByGraph type~kappa_object kappa_object type~weights_js weights_js type~kappa_object->type~weights_js kappa type~kappa_rec_js kappa_rec_js type~kappa_object->type~kappa_rec_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ Source Code kappa_object Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Kappa coefficients values [1:2,0:S-1]. Type-Bound Procedures procedure( compute_interface ), public, deferred, pass(self) :: compute Compute kappa. pure subroutine compute_interface (self) Prototype Compute kappa. Arguments Type Intent Optional Attributes Name class( kappa_object ), intent(inout) :: self Kappa. procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure( description_interface ), public, deferred, pass(self) :: description Return object string-description. pure function description_interface (self) result(string) Prototype Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( base_object ), abstract :: kappa_object !< Kappa (optimal, linear weights of stencil interpolations) object. real ( RPP ), allocatable :: values (:,:) !< Kappa coefficients values [1:2,0:S-1]. contains ! public deferred methods procedure ( compute_interface ), pass ( self ), deferred :: compute !< Compute kappa. endtype kappa_object","tags":"","loc":"type/kappa_object.html","title":"kappa_object – FORESEER "},{"text":"type, public, abstract, extends( base_object_constructor ) :: kappa_object_constructor type~~kappa_object_constructor~~InheritsGraph type~kappa_object_constructor kappa_object_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~kappa_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract kappa object constructor. Inherited By type~~kappa_object_constructor~~InheritedByGraph type~kappa_object_constructor kappa_object_constructor type~weights_js_constructor weights_js_constructor type~kappa_object_constructor->type~weights_js_constructor kappa_constructor type~kappa_rec_js_constructor kappa_rec_js_constructor type~kappa_object_constructor->type~kappa_rec_js_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables S eps face_left face_right Type-Bound Procedures create Source Code kappa_object_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( base_object_constructor ), abstract :: kappa_object_constructor !< Abstract kappa object constructor. endtype kappa_object_constructor","tags":"","loc":"type/kappa_object_constructor.html","title":"kappa_object_constructor – FORESEER "},{"text":"type, public, extends( beta_object ) :: beta_rec_js type~~beta_rec_js~~InheritsGraph type~beta_rec_js beta_rec_js type~beta_object beta_object type~beta_object->type~beta_rec_js type~base_object base_object type~base_object->type~beta_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. Note The provided beta object implements the smoothness indicators defined in Efficient Implementation of Weighted ENO\n Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Variables S coef eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ Source Code beta_rec_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), private, allocatable :: coef (:,:,:) Beta coefficients [1:2,0:S-1,0:S-1]. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Beta values [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute beta. private pure subroutine compute (self, stencil) Compute beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. procedure, public, pass(self) :: create Create beta. private subroutine create (self, constructor) Create beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. class( base_object_constructor ), intent(in) :: constructor Beta constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return beta string-description. private pure function description (self) result(string) Return beta string-description. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(in) :: self Beta. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy beta. private elemental subroutine destroy (self) Destroy beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( beta_object ) :: beta_rec_js !< Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. !< !< @note The provided beta object implements the smoothness indicators defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 private real ( RPP ), allocatable :: coef (:,:,:) !< Beta coefficients [1:2,0:S-1,0:S-1]. contains ! public deferred methods procedure , pass ( self ) :: create !< Create beta. procedure , pass ( self ) :: compute !< Compute beta. procedure , pass ( self ) :: description !< Return beta string-description. procedure , pass ( self ) :: destroy !< Destroy beta. endtype beta_rec_js","tags":"","loc":"type/beta_rec_js.html","title":"beta_rec_js – FORESEER "},{"text":"type, public, extends( beta_object_constructor ) :: beta_rec_js_constructor type~~beta_rec_js_constructor~~InheritsGraph type~beta_rec_js_constructor beta_rec_js_constructor type~beta_object_constructor beta_object_constructor type~beta_object_constructor->type~beta_rec_js_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~beta_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu and Gerolymos-Senechal-Vallet beta object constructor. Variables S eps face_left face_right Type-Bound Procedures create Source Code beta_rec_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( beta_object_constructor ) :: beta_rec_js_constructor !< Jiang-Shu and Gerolymos-Senechal-Vallet beta object constructor. endtype beta_rec_js_constructor","tags":"","loc":"type/beta_rec_js_constructor.html","title":"beta_rec_js_constructor – FORESEER "},{"text":"type, public, extends( interpolator_object ) :: reconstructor_js type~~reconstructor_js~~InheritsGraph type~reconstructor_js reconstructor_js type~interpolations_object interpolations_object type~interpolations_object->type~reconstructor_js interpolations type~interpolator_object interpolator_object type~interpolations_object->type~interpolator_object interpolations type~weights_object weights_object type~weights_object->type~reconstructor_js weights type~weights_object->type~interpolator_object weights type~base_object base_object type~base_object->type~interpolations_object type~base_object->type~weights_object type~base_object->type~interpolator_object type~interpolator_object->type~reconstructor_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu (upwind) reconstructor object. Note Provide the Efficient Implementation of Weighted ENO Schemes ,\n Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Note The supported accuracy formal order are: 3rd, 5th, 7th, 9th, 11th, 13th, 15th, 17th  corresponding to use 2, 3, 4, 5, 6,\n 7, 8, 9 stencils composed of 2, 3, 4, 5, 6, 7, 8, 9 values, respectively. Variables S eps f1 f2 ff interpolations weights Type-Bound Procedures create create_ description destroy destroy_ interpolate interpolate_debug interpolate_standard Source Code reconstructor_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( interpolations_object ), public, allocatable :: interpolations Stencil interpolations. class( weights_object ), public, allocatable :: weights Weights of interpolations. Type-Bound Procedures procedure, public, pass(self) :: create Create reconstructor. private subroutine create (self, constructor) Create interpolator. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Interpolator. class( base_object_constructor ), intent(in) :: constructor Constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return reconstructor string-description. private pure function description (self) result(string) Return reconstructor string-descripition. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(in) :: self Reconstructor. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy reconstructor. private elemental subroutine destroy (self) Destroy reconstructor. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. generic, public :: interpolate => interpolate_standard , interpolate_debug Interpolate values. private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. procedure, public, pass(self) :: interpolate_debug Interpolate values (providing also debug values). private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. procedure, public, pass(self) :: interpolate_standard Interpolate values (without providing debug values). private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Source Code type , extends ( interpolator_object ) :: reconstructor_js !< Jiang-Shu (upwind) reconstructor object. !< !< @note Provide the *Efficient Implementation of Weighted ENO Schemes*, !< Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. !< !< @note The supported accuracy formal order are: 3rd, 5th, 7th, 9th, 11th, 13th, 15th, 17th  corresponding to use 2, 3, 4, 5, 6, !< 7, 8, 9 stencils composed of 2, 3, 4, 5, 6, 7, 8, 9 values, respectively. contains ! public deferred methods procedure , pass ( self ) :: create !< Create reconstructor. procedure , pass ( self ) :: description !< Return reconstructor string-description. procedure , pass ( self ) :: destroy !< Destroy reconstructor. procedure , pass ( self ) :: interpolate_debug !< Interpolate values (providing also debug values). procedure , pass ( self ) :: interpolate_standard !< Interpolate values (without providing debug values). endtype reconstructor_js","tags":"","loc":"type/reconstructor_js.html","title":"reconstructor_js – FORESEER "},{"text":"type, public, extends( interpolator_object_constructor ) :: reconstructor_js_constructor type~~reconstructor_js_constructor~~InheritsGraph type~reconstructor_js_constructor reconstructor_js_constructor type~interpolations_object_constructor interpolations_object_constructor type~interpolations_object_constructor->type~reconstructor_js_constructor interpolations_constructor type~interpolator_object_constructor interpolator_object_constructor type~interpolations_object_constructor->type~interpolator_object_constructor interpolations_constructor type~weights_object_constructor weights_object_constructor type~weights_object_constructor->type~reconstructor_js_constructor weights_constructor type~weights_object_constructor->type~interpolator_object_constructor weights_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~interpolations_object_constructor type~base_object_constructor->type~weights_object_constructor type~base_object_constructor->type~interpolator_object_constructor type~interpolator_object_constructor->type~reconstructor_js_constructor var pantypereconstructor_js_constructorInheritsGraph = svgPanZoom('#typereconstructor_js_constructorInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu (upwind) reconstructor object constructor. Variables S eps face_left face_right interpolations_constructor weights_constructor Type-Bound Procedures create Source Code reconstructor_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( interpolations_object_constructor ), public, allocatable :: interpolations_constructor Stencil interpolations constructor. class( weights_object_constructor ), public, allocatable :: weights_constructor Weights of interpolations constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( interpolator_object_constructor ) :: reconstructor_js_constructor !< Jiang-Shu (upwind) reconstructor object constructor. endtype reconstructor_js_constructor","tags":"","loc":"type/reconstructor_js_constructor.html","title":"reconstructor_js_constructor – FORESEER "},{"text":"type, public, extends( alpha_object ) :: alpha_rec_js type~~alpha_rec_js~~InheritsGraph type~alpha_rec_js alpha_rec_js type~alpha_object alpha_object type~alpha_object->type~alpha_rec_js type~base_object base_object type~base_object->type~alpha_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu alpha object. Note The provided WENO alpha implements the alpha coefficients defined in Efficient Implementation of Weighted\n ENO Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Variables S eps f1 f2 ff values values_sum Type-Bound Procedures compute create create_ description destroy destroy_ Source Code alpha_rec_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute alpha. private pure subroutine compute (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha coefficient. class( beta_object ), intent(in) :: beta Beta coefficients. class( kappa_object ), intent(in) :: kappa Kappa coefficients. procedure, public, pass(self) :: create Create alpha. private subroutine create (self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return alpha string-description. private pure function description (self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(in) :: self Alpha coefficient. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy alpha. private elemental subroutine destroy (self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( alpha_object ) :: alpha_rec_js !< Jiang-Shu alpha object. !< !< @note The provided WENO alpha implements the alpha coefficients defined in *Efficient Implementation of Weighted !< ENO Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130. contains ! public deferred methods procedure , pass ( self ) :: create !< Create alpha. procedure , pass ( self ) :: compute !< Compute alpha. procedure , pass ( self ) :: description !< Return alpha string-description. procedure , pass ( self ) :: destroy !< Destroy alpha. endtype alpha_rec_js","tags":"","loc":"type/alpha_rec_js.html","title":"alpha_rec_js – FORESEER "},{"text":"type, public, extends( alpha_object_constructor ) :: alpha_rec_js_constructor type~~alpha_rec_js_constructor~~InheritsGraph type~alpha_rec_js_constructor alpha_rec_js_constructor type~alpha_object_constructor alpha_object_constructor type~alpha_object_constructor->type~alpha_rec_js_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~alpha_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu alpha object constructor. Variables S eps face_left face_right Type-Bound Procedures create Source Code alpha_rec_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( alpha_object_constructor ) :: alpha_rec_js_constructor !< Jiang-Shu alpha object constructor. endtype alpha_rec_js_constructor","tags":"","loc":"type/alpha_rec_js_constructor.html","title":"alpha_rec_js_constructor – FORESEER "},{"text":"type, public, extends( kappa_object ) :: kappa_rec_js type~~kappa_rec_js~~InheritsGraph type~kappa_rec_js kappa_rec_js type~kappa_object kappa_object type~kappa_object->type~kappa_rec_js type~base_object base_object type~base_object->type~kappa_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu and Gerolymos-Senechal-Vallet kappa object. Note The provided WENO kappa implements the weights defined in Efficient Implementation of Weighted ENO\n Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Variables S eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ Source Code kappa_rec_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Kappa coefficients values [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute kappa. private pure subroutine compute (self) Compute kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. procedure, public, pass(self) :: create Create kappa. private subroutine create (self, constructor) Create kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. class( base_object_constructor ), intent(in) :: constructor Kappa constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return kappa string-description. private pure function description (self) result(string) Return string-description of kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(in) :: self Kappa. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy kappa. private elemental subroutine destroy (self) Destroy kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( kappa_object ) :: kappa_rec_js !< Jiang-Shu and Gerolymos-Senechal-Vallet kappa object. !< !< @note The provided WENO kappa implements the weights defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 contains ! public deferred methods procedure , pass ( self ) :: create !< Create kappa. procedure , pass ( self ) :: compute !< Compute kappa. procedure , pass ( self ) :: description !< Return kappa string-description. procedure , pass ( self ) :: destroy !< Destroy kappa. endtype kappa_rec_js","tags":"","loc":"type/kappa_rec_js.html","title":"kappa_rec_js – FORESEER "},{"text":"type, public, extends( kappa_object_constructor ) :: kappa_rec_js_constructor type~~kappa_rec_js_constructor~~InheritsGraph type~kappa_rec_js_constructor kappa_rec_js_constructor type~kappa_object_constructor kappa_object_constructor type~kappa_object_constructor->type~kappa_rec_js_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~kappa_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu and Gerolymos-Senechal-Vallet optimal kappa object constructor. Variables S eps face_left face_right Type-Bound Procedures create Source Code kappa_rec_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( kappa_object_constructor ) :: kappa_rec_js_constructor !< Jiang-Shu and Gerolymos-Senechal-Vallet optimal kappa object constructor. endtype kappa_rec_js_constructor","tags":"","loc":"type/kappa_rec_js_constructor.html","title":"kappa_rec_js_constructor – FORESEER "},{"text":"type, public, extends( weights_object ) :: weights_js type~~weights_js~~InheritsGraph type~weights_js weights_js type~beta_object beta_object type~beta_object->type~weights_js beta type~alpha_object alpha_object type~alpha_object->type~weights_js alpha type~kappa_object kappa_object type~kappa_object->type~weights_js kappa type~base_object base_object type~base_object->type~beta_object type~base_object->type~alpha_object type~base_object->type~kappa_object type~weights_object weights_object type~base_object->type~weights_object type~weights_object->type~weights_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu and Gerolymos-Senechal-Vallet weights object. Note The provided WENO weights implements the weights defined in Efficient Implementation of Weighted ENO\n Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Variables S alpha beta eps f1 f2 ff kappa values Type-Bound Procedures compute create create_ description destroy destroy_ smoothness_indicators Source Code weights_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. class( alpha_object ), public, allocatable :: alpha Alpha coefficients (non linear weights). class( beta_object ), public, allocatable :: beta Beta coefficients (smoothness indicators). real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( kappa_object ), public, allocatable :: kappa kappa coefficients (optimal, linear weights). real(kind=RPP), public, allocatable :: values (:,:) Weights values of stencil interpolations [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute weights. private pure subroutine compute (self, stencil) Compute weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. procedure, public, pass(self) :: create Create weights. private subroutine create (self, constructor) Create reconstructor. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. class( base_object_constructor ), intent(in) :: constructor Constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return weights string-description. private pure function description (self) result(string) Return string-description of weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(in) :: self Weights. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy weights. private elemental subroutine destroy (self) Destroy weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self) :: smoothness_indicators Return smoothness indicators. private pure function smoothness_indicators (self) result(si) Return smoothness indicators.. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(in) :: self Weights. Return Value real(kind=RPP),\n  allocatable, (:,:) Smoothness indicators. Source Code type , extends ( weights_object ) :: weights_js !< Jiang-Shu and Gerolymos-Senechal-Vallet weights object. !< !< @note The provided WENO weights implements the weights defined in *Efficient Implementation of Weighted ENO !< Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 class ( alpha_object ), allocatable :: alpha !< Alpha coefficients (non linear weights). class ( beta_object ), allocatable :: beta !< Beta coefficients (smoothness indicators). class ( kappa_object ), allocatable :: kappa !< kappa coefficients (optimal, linear weights). contains ! deferred public methods procedure , pass ( self ) :: create !< Create weights. procedure , pass ( self ) :: compute !< Compute weights. procedure , pass ( self ) :: description !< Return weights string-description. procedure , pass ( self ) :: destroy !< Destroy weights. procedure , pass ( self ) :: smoothness_indicators !< Return smoothness indicators. endtype weights_js","tags":"","loc":"type/weights_js.html","title":"weights_js – FORESEER "},{"text":"type, public, extends( weights_object_constructor ) :: weights_js_constructor type~~weights_js_constructor~~InheritsGraph type~weights_js_constructor weights_js_constructor type~alpha_object_constructor alpha_object_constructor type~alpha_object_constructor->type~weights_js_constructor alpha_constructor type~kappa_object_constructor kappa_object_constructor type~kappa_object_constructor->type~weights_js_constructor kappa_constructor type~beta_object_constructor beta_object_constructor type~beta_object_constructor->type~weights_js_constructor beta_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~alpha_object_constructor type~base_object_constructor->type~kappa_object_constructor type~base_object_constructor->type~beta_object_constructor type~weights_object_constructor weights_object_constructor type~base_object_constructor->type~weights_object_constructor type~weights_object_constructor->type~weights_js_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu and Gerolymos-Senechal-Vallet optimal weights object constructor. Variables S alpha_constructor beta_constructor eps face_left face_right kappa_constructor Type-Bound Procedures create Source Code weights_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. class( alpha_object_constructor ), public, allocatable :: alpha_constructor Alpha coefficients (non linear weights) constructor. class( beta_object_constructor ), public, allocatable :: beta_constructor Beta coefficients (smoothness indicators) constructor. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( kappa_object_constructor ), public, allocatable :: kappa_constructor kappa coefficients (optimal, linear weights) constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( weights_object_constructor ) :: weights_js_constructor !< Jiang-Shu and Gerolymos-Senechal-Vallet optimal weights object constructor. class ( alpha_object_constructor ), allocatable :: alpha_constructor !< Alpha coefficients (non linear weights) constructor. class ( beta_object_constructor ), allocatable :: beta_constructor !< Beta coefficients (smoothness indicators) constructor. class ( kappa_object_constructor ), allocatable :: kappa_constructor !< kappa coefficients (optimal, linear weights) constructor. endtype weights_js_constructor","tags":"","loc":"type/weights_js_constructor.html","title":"weights_js_constructor – FORESEER "},{"text":"type, public, extends( interpolator_object ) :: interpolator_js type~~interpolator_js~~InheritsGraph type~interpolator_js interpolator_js type~interpolations_object interpolations_object type~interpolations_object->type~interpolator_js interpolations type~interpolator_object interpolator_object type~interpolations_object->type~interpolator_object interpolations type~weights_object weights_object type~weights_object->type~interpolator_js weights type~weights_object->type~interpolator_object weights type~base_object base_object type~base_object->type~interpolations_object type~base_object->type~weights_object type~base_object->type~interpolator_object type~interpolator_object->type~interpolator_js Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu (upwind) interpolator object. Variables S eps f1 f2 ff interpolations weights Type-Bound Procedures create create_ description destroy destroy_ interpolate interpolate_debug interpolate_standard Source Code interpolator_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( interpolations_object ), public, allocatable :: interpolations Stencil interpolations. class( weights_object ), public, allocatable :: weights Weights of interpolations. Type-Bound Procedures procedure( create_interface ), public, deferred, pass(self) :: create Create object. subroutine create_interface (self, constructor) Prototype Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return interpolator string-description. private pure function description (self) result(string) Return interpolator string-descripition. Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(in) :: self Interpolator. Return Value character(len=:),\n  allocatable String-description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy object. elemental subroutine destroy_interface (self) Prototype Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. generic, public :: interpolate => interpolate_standard , interpolate_debug Interpolate values. private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. procedure, public, pass(self) :: interpolate_debug Interpolate values (providing also debug values). private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. procedure, public, pass(self) :: interpolate_standard Interpolate values (without providing debug values). private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Source Code type , extends ( interpolator_object ) :: interpolator_js !< Jiang-Shu (upwind) interpolator object. contains ! public deferred methods procedure , pass ( self ) :: description !< Return interpolator string-description. procedure , pass ( self ) :: interpolate_standard !< Interpolate values (without providing debug values). procedure , pass ( self ) :: interpolate_debug !< Interpolate values (providing also debug values). endtype interpolator_js","tags":"","loc":"type/interpolator_js.html","title":"interpolator_js – FORESEER "},{"text":"type, public, extends( interpolator_object_constructor ) :: interpolator_js_constructor type~~interpolator_js_constructor~~InheritsGraph type~interpolator_js_constructor interpolator_js_constructor type~interpolations_object_constructor interpolations_object_constructor type~interpolations_object_constructor->type~interpolator_js_constructor interpolations_constructor type~interpolator_object_constructor interpolator_object_constructor type~interpolations_object_constructor->type~interpolator_object_constructor interpolations_constructor type~weights_object_constructor weights_object_constructor type~weights_object_constructor->type~interpolator_js_constructor weights_constructor type~weights_object_constructor->type~interpolator_object_constructor weights_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~interpolations_object_constructor type~base_object_constructor->type~weights_object_constructor type~base_object_constructor->type~interpolator_object_constructor type~interpolator_object_constructor->type~interpolator_js_constructor var pantypeinterpolator_js_constructorInheritsGraph = svgPanZoom('#typeinterpolator_js_constructorInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu (upwind) interpolator object constructor. Variables S eps face_left face_right interpolations_constructor weights_constructor Type-Bound Procedures create Source Code interpolator_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( interpolations_object_constructor ), public, allocatable :: interpolations_constructor Stencil interpolations constructor. class( weights_object_constructor ), public, allocatable :: weights_constructor Weights of interpolations constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( interpolator_object_constructor ) :: interpolator_js_constructor !< Jiang-Shu (upwind) interpolator object constructor. endtype interpolator_js_constructor","tags":"","loc":"type/interpolator_js_constructor.html","title":"interpolator_js_constructor – FORESEER "},{"text":"type, public, extends( alpha_object ) :: alpha_rec_z type~~alpha_rec_z~~InheritsGraph type~alpha_rec_z alpha_rec_z type~alpha_object alpha_object type~alpha_object->type~alpha_rec_z type~base_object base_object type~base_object->type~alpha_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Borges alpha (non linear weights) object. Note The provided alpha implements the alpha coefficients defined in An improved weighted essentially non-oscillatory\n scheme for hyperbolic conservation laws , Rafael Borges, Monique Carmona, Bruno Costa and Wai Sun Don, JCP,\n 2008, vol. 227, pp. 3191-3211, doi: 10.1016/j.jcp.2007.11.038. Variables S eps f1 f2 ff values values_sum Type-Bound Procedures compute create create_ description destroy destroy_ Source Code alpha_rec_z Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute alpha. private pure subroutine compute (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. procedure, public, pass(self) :: create Create alpha. private subroutine create (self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return alpha string-description. private pure function description (self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(in) :: self Alpha coefficients. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy alpha. private elemental subroutine destroy (self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( alpha_object ) :: alpha_rec_z !< Borges alpha (non linear weights) object. !< !< @note The provided alpha implements the alpha coefficients defined in *An improved weighted essentially non-oscillatory !< scheme for hyperbolic conservation laws*, Rafael Borges, Monique Carmona, Bruno Costa and Wai Sun Don, JCP, !< 2008, vol. 227, pp. 3191-3211, doi: 10.1016/j.jcp.2007.11.038. contains ! public deferred methods procedure , pass ( self ) :: create !< Create alpha. procedure , pass ( self ) :: compute !< Compute alpha. procedure , pass ( self ) :: description !< Return alpha string-description. procedure , pass ( self ) :: destroy !< Destroy alpha. endtype alpha_rec_z","tags":"","loc":"type/alpha_rec_z.html","title":"alpha_rec_z – FORESEER "},{"text":"type, public, extends( alpha_object_constructor ) :: alpha_rec_z_constructor type~~alpha_rec_z_constructor~~InheritsGraph type~alpha_rec_z_constructor alpha_rec_z_constructor type~alpha_object_constructor alpha_object_constructor type~alpha_object_constructor->type~alpha_rec_z_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~alpha_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Borges alpha (non linear weights) object constructor. Variables S eps face_left face_right Type-Bound Procedures create Source Code alpha_rec_z_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( alpha_object_constructor ) :: alpha_rec_z_constructor !< Borges alpha (non linear weights) object constructor. endtype alpha_rec_z_constructor","tags":"","loc":"type/alpha_rec_z_constructor.html","title":"alpha_rec_z_constructor – FORESEER "},{"text":"type, public, extends( interpolations_object ) :: interpolations_rec_js type~~interpolations_rec_js~~InheritsGraph type~interpolations_rec_js interpolations_rec_js type~interpolations_object interpolations_object type~interpolations_object->type~interpolations_rec_js type~base_object base_object type~base_object->type~interpolations_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. Note The provided interpolations implement the Lagrange interpolations defined in Efficient Implementation\n of Weighted ENO Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Variables S coef eps f1 f2 ff values Type-Bound Procedures compute create create_ description destroy destroy_ Source Code interpolations_rec_js Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), private, allocatable :: coef (:,:,:) Polynomial coefficients [1:2,0:S-1,0:S-1]. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Stencil interpolations values [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute interpolations. private pure subroutine compute (self, stencil) Compute interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. procedure, public, pass(self) :: create Create interpolations. private subroutine create (self, constructor) Create interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. class( base_object_constructor ), intent(in) :: constructor Interpolations constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return interpolations string-description. private pure function description (self) result(string) Return interpolations string-description. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(in) :: self Interpolations. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy interpolations. private elemental subroutine destroy (self) Destroy interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( interpolations_object ) :: interpolations_rec_js !< Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. !< !< @note The provided interpolations implement the Lagrange interpolations defined in *Efficient Implementation !< of Weighted ENO Schemes*, Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202--228, doi:10.1006/jcph.1996.0130 and !< *Very-high-order weno schemes*, G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524, !< doi:10.1016/j.jcp.2009.07.039 private real ( RPP ), allocatable :: coef (:,:,:) !< Polynomial coefficients [1:2,0:S-1,0:S-1]. contains ! public deferred methods procedure , pass ( self ) :: create !< Create interpolations. procedure , pass ( self ) :: compute !< Compute interpolations. procedure , pass ( self ) :: description !< Return interpolations string-description. procedure , pass ( self ) :: destroy !< Destroy interpolations. endtype interpolations_rec_js","tags":"","loc":"type/interpolations_rec_js.html","title":"interpolations_rec_js – FORESEER "},{"text":"type, public, extends( interpolations_object_constructor ) :: interpolations_rec_js_constructor type~~interpolations_rec_js_constructor~~InheritsGraph type~interpolations_rec_js_constructor interpolations_rec_js_constructor type~interpolations_object_constructor interpolations_object_constructor type~interpolations_object_constructor->type~interpolations_rec_js_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~interpolations_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Jiang-Shu (Lagrange) interpolations object for derivative reconstruction constructor. Variables S eps face_left face_right Type-Bound Procedures create Source Code interpolations_rec_js_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( interpolations_object_constructor ) :: interpolations_rec_js_constructor !< Jiang-Shu (Lagrange) interpolations object for derivative reconstruction constructor. endtype interpolations_rec_js_constructor","tags":"","loc":"type/interpolations_rec_js_constructor.html","title":"interpolations_rec_js_constructor – FORESEER "},{"text":"type, public, extends( alpha_object ) :: alpha_rec_m type~~alpha_rec_m~~InheritsGraph type~alpha_rec_m alpha_rec_m type~alpha_object alpha_object type~alpha_object->type~alpha_rec_m alpha_base type~alpha_object->type~alpha_rec_m type~base_object base_object type~base_object->type~alpha_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Henrick alpha (non linear weights) object. Note The provided alpha implements the alpha coefficients defined in Mapped weighted essentially non-oscillatory schemes:\n Achieving optimal order near critical points , Andrew K. Henrick, Tariq D. Aslam, Joseph M. Powers,\n JCP, 2005, vol. 207, pp. 542-567, doi:10.1016/j.jcp.2005.01.023. Variables S alpha_base eps f1 f2 ff values values_sum Type-Bound Procedures compute create create_ description destroy destroy_ Source Code alpha_rec_m Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. class( alpha_object ), public, allocatable :: alpha_base Base alpha to be re-mapped. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute alpha. private pure subroutine compute (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. procedure, public, pass(self) :: create Create alpha. private subroutine create (self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. procedure, public, pass(self), non_overridable :: create_ Create object. private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. procedure, public, pass(self) :: description Return alpha string-description. private pure function description (self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(in) :: self Alpha. Return Value character(len=:),\n  allocatable String-description. procedure, public, pass(self) :: destroy Destroy alpha. private elemental subroutine destroy (self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code type , extends ( alpha_object ) :: alpha_rec_m !< Henrick alpha (non linear weights) object. !< !< @note The provided alpha implements the alpha coefficients defined in *Mapped weighted essentially non-oscillatory schemes: !< Achieving optimal order near critical points*, Andrew K. Henrick, Tariq D. Aslam, Joseph M. Powers, !< JCP, 2005, vol. 207, pp. 542-567, doi:10.1016/j.jcp.2005.01.023. class ( alpha_object ), allocatable :: alpha_base !< Base alpha to be re-mapped. contains ! public deferred methods procedure , pass ( self ) :: create !< Create alpha. procedure , pass ( self ) :: compute !< Compute alpha. procedure , pass ( self ) :: description !< Return alpha string-description. procedure , pass ( self ) :: destroy !< Destroy alpha. endtype alpha_rec_m","tags":"","loc":"type/alpha_rec_m.html","title":"alpha_rec_m – FORESEER "},{"text":"type, public, extends( alpha_object_constructor ) :: alpha_rec_m_constructor type~~alpha_rec_m_constructor~~InheritsGraph type~alpha_rec_m_constructor alpha_rec_m_constructor type~alpha_object_constructor alpha_object_constructor type~alpha_object_constructor->type~alpha_rec_m_constructor type~base_object_constructor base_object_constructor type~base_object_constructor->type~alpha_object_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Henrick alpha (non linear weights) object constructor. Variables S base_type eps face_left face_right Type-Bound Procedures create Source Code alpha_rec_m_constructor Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. character(len=:), public, allocatable :: base_type Base alpha coefficient type. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code type , extends ( alpha_object_constructor ) :: alpha_rec_m_constructor !< Henrick alpha (non linear weights) object constructor. character ( len = :), allocatable :: base_type !< Base alpha coefficient type. endtype alpha_rec_m_constructor","tags":"","loc":"type/alpha_rec_m_constructor.html","title":"alpha_rec_m_constructor – FORESEER "},{"text":"type, public :: kappa_factory Factory, create an instance of concrete extension of kappa_object given its constructor. Type-Bound Procedures create create_constructor Source Code kappa_factory Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of kappa_object . private subroutine create (constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. procedure, public, nopass :: create_constructor Create a concrete instance of kappa_object_constructor . private subroutine create_constructor (interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor. Source Code type :: kappa_factory !< Factory, create an instance of concrete extension of [[kappa_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[kappa_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[kappa_object_constructor]]. endtype kappa_factory","tags":"","loc":"type/kappa_factory.html","title":"kappa_factory – FORESEER "},{"text":"type, public :: weights_factory Factory, create an instance of concrete extension of weights_object given its constructor. Type-Bound Procedures create create_constructor Source Code weights_factory Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of weights_object . private subroutine create (constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. procedure, public, nopass :: create_constructor Create a concrete instance of weights_object_constructor . private subroutine create_constructor (interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. Source Code type :: weights_factory !< Factory, create an instance of concrete extension of [[weights_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[weights_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[weights_object_constructor]]. endtype weights_factory","tags":"","loc":"type/weights_factory.html","title":"weights_factory – FORESEER "},{"text":"type, public :: interpolator_factory Factory, create an instance of concrete extension of interpolator_object given its constructor. Type-Bound Procedures create create_constructor Source Code interpolator_factory Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of interpolator_object . private subroutine create (constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. procedure, public, nopass :: create_constructor Create a concrete instance of interpolator_object_constructor . private subroutine create_constructor (interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp. Source Code type :: interpolator_factory !< Factory, create an instance of concrete extension of [[interpolator_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[interpolator_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[interpolator_object_constructor]]. endtype interpolator_factory","tags":"","loc":"type/interpolator_factory.html","title":"interpolator_factory – FORESEER "},{"text":"type, public :: interpolations_factory Factory, create an instance of concrete extension of interpolations_object given its constructor. Type-Bound Procedures create create_constructor Source Code interpolations_factory Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of interpolations_object . private subroutine create (constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. procedure, public, nopass :: create_constructor Create a concrete instance of interpolations_object_constructor . private subroutine create_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. Source Code type :: interpolations_factory !< Factory, create an instance of concrete extension of [[interpolations_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[interpolations_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[interpolations_object_constructor]]. endtype interpolations_factory","tags":"","loc":"type/interpolations_factory.html","title":"interpolations_factory – FORESEER "},{"text":"type, public :: objects_factory Factory, create an instance of concrete extension of base_object given its constructor. Type-Bound Procedures create create_alpha_object create_alpha_object_constructor create_beta_object create_beta_object_constructor create_constructor create_interpolations_object create_interpolations_object_constructor create_interpolator create_interpolator_object create_interpolator_object_constructor create_kappa_object create_kappa_object_constructor create_weights_object create_weights_object_constructor Source Code objects_factory Type-Bound Procedures generic, public :: create => create_alpha_object , create_beta_object , create_kappa_object , create_interpolations_object , create_interpolator , create_interpolator_object , create_weights_object Create a concrete instance of alpha_object , beta_object , kappa_object , interpolations_object , interpolator_object or weights_object . private subroutine create_alpha_object (constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. private subroutine create_beta_object (constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. private subroutine create_kappa_object (constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. private subroutine create_interpolations_object (constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. private subroutine create_interpolator (self, interpolator_type, S, interpolator, face_left, face_right, eps) Create an instance of concrete extension of interpolator_object given user options. Arguments Type Intent Optional Attributes Name class( objects_factory ), intent(in) :: self The factory. character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolator_object ), intent(out), allocatable :: interpolator Interpolator. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/div. private subroutine create_interpolator_object (constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. private subroutine create_weights_object (constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_alpha_object Create alpha_object instance private subroutine create_alpha_object (constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_alpha_object_constructor Create alpha_object_constructor instance. private subroutine create_alpha_object_constructor (interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division. procedure, private, nopass :: create_beta_object Create beta_object instance. private subroutine create_beta_object (constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_beta_object_constructor Create beta_object_constructor instance. private subroutine create_beta_object_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. generic, public :: create_constructor => create_alpha_object_constructor , create_beta_object_constructor , create_kappa_object_constructor , create_interpolations_object_constructor , create_interpolator_object_constructor , create_weights_object_constructor Create a concrete instance of alpha_object_constructor , beta_object_constructor , kappa_object_constructor , interpolations_object_constructor , interpolator_object_constructor or weights_object_constructor . private subroutine create_alpha_object_constructor (interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division. private subroutine create_beta_object_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. private subroutine create_kappa_object_constructor (interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor. private subroutine create_interpolations_object_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of interpolations_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. private subroutine create_interpolator_object_constructor (interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of interpolator_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp. private subroutine create_weights_object_constructor (interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. procedure, private, nopass :: create_interpolations_object Create interpolations_object instance. private subroutine create_interpolations_object (constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_interpolations_object_constructor Create interpolations_object_constructor inst. private subroutine create_interpolations_object_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of interpolations_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. procedure, private, pass(self) :: create_interpolator Create interpolator_object instance. private subroutine create_interpolator (self, interpolator_type, S, interpolator, face_left, face_right, eps) Create an instance of concrete extension of interpolator_object given user options. Arguments Type Intent Optional Attributes Name class( objects_factory ), intent(in) :: self The factory. character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolator_object ), intent(out), allocatable :: interpolator Interpolator. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/div. procedure, private, nopass :: create_interpolator_object Create interpolator_object instance. private subroutine create_interpolator_object (constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_interpolator_object_constructor Create interpolator_object_constructor inst. private subroutine create_interpolator_object_constructor (interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of interpolator_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp. procedure, private, nopass :: create_kappa_object Create kappa_object instance. private subroutine create_kappa_object (constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_kappa_object_constructor Create kappa_object_constructor instance. private subroutine create_kappa_object_constructor (interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor. procedure, private, nopass :: create_weights_object Create weights_object instance. private subroutine create_weights_object (constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. procedure, private, nopass :: create_weights_object_constructor Create weights_object_constructor instance. private subroutine create_weights_object_constructor (interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. Source Code type :: objects_factory !< Factory, create an instance of concrete extension of [[base_object]] given its constructor. contains ! public methods generic :: create => create_alpha_object , & create_beta_object , & create_kappa_object , & create_interpolations_object , & create_interpolator , & create_interpolator_object , & create_weights_object !< Create a concrete instance of [[alpha_object]], [[beta_object]], !< [[kappa_object]], [[interpolations_object]], [[interpolator_object]] or !< [[weights_object]]. generic :: create_constructor => create_alpha_object_constructor , & create_beta_object_constructor , & create_kappa_object_constructor , & create_interpolations_object_constructor , & create_interpolator_object_constructor , & create_weights_object_constructor !< Create a concrete instance of !< [[alpha_object_constructor]], [[beta_object_constructor]], !< [[kappa_object_constructor]], !< [[interpolations_object_constructor]], !< [[interpolator_object_constructor]] or !< [[weights_object_constructor]]. ! private methods procedure , nopass , private :: create_alpha_object !< Create [[alpha_object]] instance procedure , nopass , private :: create_beta_object !< Create [[beta_object]] instance. procedure , nopass , private :: create_kappa_object !< Create [[kappa_object]] instance. procedure , nopass , private :: create_interpolations_object !< Create [[interpolations_object]] instance. procedure , pass ( self ), private :: create_interpolator !< Create [[interpolator_object]] instance. procedure , nopass , private :: create_interpolator_object !< Create [[interpolator_object]] instance. procedure , nopass , private :: create_weights_object !< Create [[weights_object]] instance. procedure , nopass , private :: create_alpha_object_constructor !< Create [[alpha_object_constructor]] instance. procedure , nopass , private :: create_beta_object_constructor !< Create [[beta_object_constructor]] instance. procedure , nopass , private :: create_kappa_object_constructor !< Create [[kappa_object_constructor]] instance. procedure , nopass , private :: create_interpolations_object_constructor !< Create [[interpolations_object_constructor]] inst. procedure , nopass , private :: create_interpolator_object_constructor !< Create [[interpolator_object_constructor]] inst. procedure , nopass , private :: create_weights_object_constructor !< Create [[weights_object_constructor]] instance. endtype objects_factory","tags":"","loc":"type/objects_factory.html","title":"objects_factory – FORESEER "},{"text":"type, public :: alpha_factory Factory, create an instance of concrete extension of alpha_object given its constructor. Type-Bound Procedures create create_constructor Source Code alpha_factory Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of alpha_object . private subroutine create (constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. procedure, public, nopass :: create_constructor Create a concrete instance of alpha_object_constructor . private subroutine create_constructor (interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division. Source Code type :: alpha_factory !< Factory, create an instance of concrete extension of [[alpha_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[alpha_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[alpha_object_constructor]]. endtype alpha_factory","tags":"","loc":"type/alpha_factory.html","title":"alpha_factory – FORESEER "},{"text":"type, public :: beta_factory Factory, create an instance of concrete extension of beta_object given its constructor. Type-Bound Procedures create create_constructor Source Code beta_factory Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of beta_object . private subroutine create (constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. procedure, public, nopass :: create_constructor Create a concrete instance of beta_object_constructor . private subroutine create_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. Source Code type :: beta_factory !< Factory, create an instance of concrete extension of [[beta_object]] given its constructor. contains ! public methods procedure , nopass :: create !< Create a concrete instance of [[beta_object]]. procedure , nopass :: create_constructor !< Create a concrete instance of [[beta_object_constructor]]. endtype beta_factory","tags":"","loc":"type/beta_factory.html","title":"beta_factory – FORESEER "},{"text":"abstract interface private pure subroutine compute_waves_interface(self, eos_left, state_left, eos_right, state_right, normal, waves) Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Description Compute waves pattern.","tags":"","loc":"interface/compute_waves_interface.html","title":"compute_waves_interface – FORESEER"},{"text":"abstract interface private pure subroutine solve_interface(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Description Solve Riemann problem.","tags":"","loc":"interface/solve_interface.html","title":"solve_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure subroutine compute_waves_interface(self, eos_left, state_left, eos_right, state_right, normal, waves) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Description Compute waves pattern. This compute only the waves pattern, not the fluxes: this is useful for building solvers being hybrid of other solvers.","tags":"","loc":"interface/compute_waves_interface~2.html","title":"compute_waves_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine initialize_interface(self, config) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Description Initialize solver.","tags":"","loc":"interface/initialize_interface.html","title":"initialize_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine solve_interface(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Description Solve Riemann Problem.","tags":"","loc":"interface/solve_interface~2.html","title":"solve_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function R_interface(self) result(R_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. Description Return fluid constant R=cp-cv .","tags":"","loc":"interface/r_interface.html","title":"R_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function cp_interface(self) result(cp_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. Description Return specific heat at constant pressure.","tags":"","loc":"interface/cp_interface.html","title":"cp_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function cv_interface(self) result(cv_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. Description Return specific heat at constant volume.","tags":"","loc":"interface/cv_interface.html","title":"cv_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function density_interface(self, energy, pressure, speed_of_sound, temperature) result(density_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. Description Return density.","tags":"","loc":"interface/density_interface.html","title":"density_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function energy_interface(self, density, pressure, temperature) result(energy_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. Description Return specific internal energy.","tags":"","loc":"interface/energy_interface.html","title":"energy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function gam_interface(self) result(gam_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. Description Return specific heats ratio gamma=cp/cv .","tags":"","loc":"interface/gam_interface.html","title":"gam_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function pressure_interface(self, density, energy, temperature) result(pressure_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. Description Return pressure.","tags":"","loc":"interface/pressure_interface.html","title":"pressure_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function speed_of_sound_interface(self, density, pressure) result(speed_of_sound_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. Description Return speed of sound.","tags":"","loc":"interface/speed_of_sound_interface.html","title":"speed_of_sound_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function temperature_interface(self, density, energy, pressure) result(temperature_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Description Return temperature.","tags":"","loc":"interface/temperature_interface.html","title":"temperature_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function array_interface(self) result(array_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of conservative. Description Return serialized array of conservative.","tags":"","loc":"interface/array_interface.html","title":"array_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private pure subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface.html","title":"assignment_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine compute_fluxes_interface(self, eos, normal, fluxes) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. Description Compute conservative fluxes.","tags":"","loc":"interface/compute_fluxes_interface.html","title":"compute_fluxes_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function cons_operator_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Description Operator cons.op.real .","tags":"","loc":"interface/cons_operator_real.html","title":"cons_operator_real – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~2.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. Description Destroy conservative.","tags":"","loc":"interface/destroy_interface.html","title":"destroy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine initialize_interface(self, initial_state) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. Description Initialize conservative.","tags":"","loc":"interface/initialize_interface~2.html","title":"initialize_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function pressure_interface(self, eos) result(pressure_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. Description Return pressure value.","tags":"","loc":"interface/pressure_interface~2.html","title":"pressure_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function real_operator_cons(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Description Operator real.op.cons .","tags":"","loc":"interface/real_operator_cons.html","title":"real_operator_cons – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Description Symmetric operator cons.op.cons .","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function unary_operator(self) result(operator_result) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. Description Unary operator .op.cons .","tags":"","loc":"interface/unary_operator.html","title":"unary_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function velocity_interface(self) result(velocity_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Description Return velocity vector.","tags":"","loc":"interface/velocity_interface.html","title":"velocity_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function array_interface(self) result(array_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of primitive. Description Return serialized array of primitive.","tags":"","loc":"interface/array_interface~2.html","title":"array_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private pure subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface~2.html","title":"assignment_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~3.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. Description Destroy primitive.","tags":"","loc":"interface/destroy_interface~2.html","title":"destroy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function energy_interface(self, eos) result(energy_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Description Return energy value.","tags":"","loc":"interface/energy_interface~2.html","title":"energy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private subroutine initialize_interface(self, initial_state) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Description Initialize primitive.","tags":"","loc":"interface/initialize_interface~3.html","title":"initialize_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function momentum_interface(self) result(momentum_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Description Return momentum vector.","tags":"","loc":"interface/momentum_interface.html","title":"momentum_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function prim_operator_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Description Operator prim.op.real .","tags":"","loc":"interface/prim_operator_real.html","title":"prim_operator_real – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function real_operator_prim(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Description Operator real * prim .","tags":"","loc":"interface/real_operator_prim.html","title":"real_operator_prim – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Description Symmetric operator prim.op.prim .","tags":"","loc":"interface/symmetric_operator~2.html","title":"symmetric_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function unary_operator(self) result(operator_result) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Description Unary operator .op.prim .","tags":"","loc":"interface/unary_operator~2.html","title":"unary_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine reconstruct_interfaces_(self, conservative, r_conservative) Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative variables. Description Reconstruct interface states.","tags":"","loc":"interface/reconstruct_interfaces_.html","title":"reconstruct_interfaces_ – FORESEER"},{"text":"abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine riemann_solver_(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Description Riemann Problem solver.","tags":"","loc":"interface/riemann_solver_.html","title":"riemann_solver_ – FORESEER"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private pure subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FORESEER"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FORESEER"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations.","tags":"","loc":"interface/local_error_operator.html","title":"local_error_operator – FORESEER"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FORESEER"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator~3.html","title":"symmetric_operator – FORESEER"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FORESEER"},{"text":"abstract interface Abstract interfaces of interpolations_object . private pure subroutine compute_interface(self, stencil) Arguments Type Intent Optional Attributes Name class( interpolations_object ), intent(inout) :: self Interpolations. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Description Compute interpolations.","tags":"","loc":"interface/compute_interface.html","title":"compute_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of interpolator_object . private pure subroutine interpolate_debug_interface(self, stencil, interpolation, si, weights) Arguments Type Intent Optional Attributes Name class( interpolator_object ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. Description Interpolate values (providing also debug values).","tags":"","loc":"interface/interpolate_debug_interface.html","title":"interpolate_debug_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of interpolator_object . private pure subroutine interpolate_standard_interface(self, stencil, interpolation) Arguments Type Intent Optional Attributes Name class( interpolator_object ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Description Interpolate values (without providing debug values).","tags":"","loc":"interface/interpolate_standard_interface.html","title":"interpolate_standard_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of beta_object . private pure subroutine compute_interface(self, stencil) Arguments Type Intent Optional Attributes Name class( beta_object ), intent(inout) :: self Beta. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Description Compute beta.","tags":"","loc":"interface/compute_interface~2.html","title":"compute_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of weights_object . private pure subroutine compute_interface(self, stencil) Arguments Type Intent Optional Attributes Name class( weights_object ), intent(inout) :: self Weights. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Description Compute beta.","tags":"","loc":"interface/compute_interface~3.html","title":"compute_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of weights_object . private pure function smoothness_indicators_interface(self) result(si) Arguments Type Intent Optional Attributes Name class( weights_object ), intent(in) :: self Weights. Return Value real(kind=RPP),\n  allocatable,(:,:) Smoothness indicators. Description Return smoothness indicators.","tags":"","loc":"interface/smoothness_indicators_interface.html","title":"smoothness_indicators_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of alpha_object . private pure subroutine compute_interface(self, beta, kappa) Arguments Type Intent Optional Attributes Name class( alpha_object ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. Description Compute alpha.","tags":"","loc":"interface/compute_interface~4.html","title":"compute_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of base_object . private subroutine create_interface(self, constructor) Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. Description Create object. Note Before call this method a concrete constructor must be instantiated.","tags":"","loc":"interface/create_interface.html","title":"create_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of base_object . private pure function description_interface(self) result(string) Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. Description Return object string-description.","tags":"","loc":"interface/description_interface~4.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of base_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Description Destroy object.","tags":"","loc":"interface/destroy_interface~3.html","title":"destroy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of kappa_object . private pure subroutine compute_interface(self) Arguments Type Intent Optional Attributes Name class( kappa_object ), intent(inout) :: self Kappa. Description Compute kappa.","tags":"","loc":"interface/compute_interface~5.html","title":"compute_interface – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead\n of a non linear fan one. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves","tags":"","loc":"proc/compute_waves.html","title":"compute_waves – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. call self % solver_pvl % initialize ( config = 'u23' ) endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FORESEER"},{"text":"private subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Calls proc~~solve~~CallsGraph proc~solve solve proc~conservative_compressible_pointer conservative_compressible_pointer proc~solve->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code solve Source Code subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( conservative_compressible ) :: fluxes_left !< Fluxes of left state. type ( conservative_compressible ) :: fluxes_right !< Fluxes of right state. type ( conservative_compressible ) :: fluxes_ !< Fluxes, local variable. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: lmax !< Maximum wave speed estimation. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) lmax = maxval ( abs ( waves )) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) select type ( fluxes ) type is ( conservative_compressible ) #ifdef __GFORTRAN__ fluxes = 0.5_R8P * ( fluxes_left + fluxes_right - ( lmax * ( state_right_ - state_left_ ))) #else ! Intel Fortran has issue in resolving the equation with multiple operators... it must be split fluxes_ = state_right_ - state_left_ fluxes_ = lmax * fluxes_ fluxes = fluxes_left + fluxes_right fluxes = fluxes - fluxes_ fluxes = 0.5_R8P * fluxes #endif endselect endsubroutine solve","tags":"","loc":"proc/solve.html","title":"solve – FORESEER"},{"text":"private elemental subroutine compute_p23(self) Compute interstates pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. Source Code compute_p23 Source Code elemental subroutine compute_p23 ( self ) !< Compute interstates pressure. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. self % p23 = 0.5_R8P * (( self % p_1 + self % p_4 ) - 0.25_R8P * ( self % u_4 - self % u_1 ) * ( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 )) endsubroutine compute_p23","tags":"","loc":"proc/compute_p23.html","title":"compute_p23 – FORESEER"},{"text":"private elemental subroutine compute_u23(self) Compute interstates velocity. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. Source Code compute_u23 Source Code elemental subroutine compute_u23 ( self ) !< Compute interstates velocity. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. self % u23 = 0.5_R8P * ( self % u_1 + self % u_4 ) - 2.0_R8P * ( self % p_4 - self % p_1 ) / (( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 )) endsubroutine compute_u23","tags":"","loc":"proc/compute_u23.html","title":"compute_u23 – FORESEER"},{"text":"private elemental subroutine compute_up23(self) Compute interstates velocity and pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. Source Code compute_up23 Source Code elemental subroutine compute_up23 ( self ) !< Compute interstates velocity and pressure. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. real ( R8P ) :: ram !< Mean value of `r * a`. ram = 0.25_R8P * ( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 ) self % u23 = 0.5_R8P * (( self % u_1 + self % u_4 ) - ( self % p_4 - self % p_1 ) / ram ) self % p23 = 0.5_R8P * (( self % p_1 + self % p_4 ) - ( self % u_4 - self % u_1 ) * ram ) endsubroutine compute_up23","tags":"","loc":"proc/compute_up23.html","title":"compute_up23 – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead\n of a non linear fan one. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % compute_waves_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves","tags":"","loc":"proc/compute_waves~2.html","title":"compute_waves – FORESEER"},{"text":"private pure subroutine compute_waves_u23(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Use Primitive Variables Linearization algorithm by means of only u23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves_u23 Source Code pure subroutine compute_waves_u23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. real ( R8P ) :: x !< Dummy variable. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_u23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock x = 0.25_R8P * ( self % g_1 + 1._R8P ) * ( self % u23 - self % u_1 ) / self % a_1 self % s_1 = self % u_1 + self % a_1 * ( x - sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock x = 0.25_R8P * ( self % g_4 + 1._R8P ) * ( self % u23 - self % u_4 ) / self % a_4 self % s_4 = self % u_4 + self % a_4 * ( x + sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_u23","tags":"","loc":"proc/compute_waves_u23.html","title":"compute_waves_u23 – FORESEER"},{"text":"private pure subroutine compute_waves_up23(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Use Primitive Variables Linearization algorithm by means of only up23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves_up23 Source Code pure subroutine compute_waves_up23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_up23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock self % s_1 = self % u_1 - self % a_1 * sqrt ( 1._R8P + 0.5_R8P * ( self % g_1 + 1._R8P ) / self % g_1 * ( self % p23 / self % p_1 - 1._R8P )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock self % s_4 = self % u_4 + self % a_4 * sqrt ( 1._R8P + 0.5_R8P * ( self % g_4 + 1._R8P ) / self % g_4 * ( self % p23 / self % p_4 - 1._R8P )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_up23","tags":"","loc":"proc/compute_waves_up23.html","title":"compute_waves_up23 – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local var. self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 config_ = '' ; if ( present ( config )) config_ = config select case ( config_ ) case ( 'u23' ) self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 case ( 'up23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 case ( 'upr23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 endselect endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – FORESEER"},{"text":"private pure subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve Source Code pure subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. call self % solve_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , fluxes = fluxes ) endsubroutine solve","tags":"","loc":"proc/solve~2.html","title":"solve – FORESEER"},{"text":"private pure subroutine solve_u23(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem by u23 algorithm. Use Primitive Variables Linearization algorithm by means of only u23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve_u23 Source Code pure subroutine solve_u23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem by `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_u23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_u23","tags":"","loc":"proc/solve_u23.html","title":"solve_u23 – FORESEER"},{"text":"private pure subroutine solve_up23(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem up23 algorithm. Use Primitive Variables Linearization algorithm by means of only up23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Riemann pattern. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve_up23 Source Code pure subroutine solve_up23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem `up23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Riemann pattern. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_up23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_up23","tags":"","loc":"proc/solve_up23.html","title":"solve_up23 – FORESEER"},{"text":"public elemental function conservative_to_primitive_compressible(conservative, eos) result(primitive_) Return a primitive_compressible state transforming a given conservative_compressible state. Arguments Type Intent Optional Attributes Name type( conservative_compressible ), intent(in) :: conservative Conservative state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( primitive_compressible ) Primitive state. Called By proc~~conservative_to_primitive_compressible~~CalledByGraph proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~save_time_serie save_time_serie proc~save_time_serie->proc~conservative_to_primitive_compressible proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~reconstruct_interfaces_primitive->proc~conservative_to_primitive_compressible proc~output output proc~output->proc~conservative_to_primitive_compressible proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~reconstruct_interfaces_characteristic->proc~conservative_to_primitive_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~save_time_serie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_to_primitive_compressible Source Code elemental function conservative_to_primitive_compressible ( conservative , eos ) result ( primitive_ ) !< Return a [[primitive_compressible]] state transforming a given [[conservative_compressible]] state. type ( conservative_compressible ), intent ( in ) :: conservative !< Conservative state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( primitive_compressible ) :: primitive_ !< Primitive state. primitive_ % density = conservative % density primitive_ % velocity = conservative % velocity () primitive_ % pressure = conservative % pressure ( eos = eos ) endfunction conservative_to_primitive_compressible","tags":"","loc":"proc/conservative_to_primitive_compressible.html","title":"conservative_to_primitive_compressible – FORESEER"},{"text":"public elemental function primitive_to_conservative_compressible(primitive, eos) result(conservative_) Return a conservative_compressible state transforming a given primitive_compressible state. Arguments Type Intent Optional Attributes Name type( primitive_compressible ), intent(in) :: primitive Primitive state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( conservative_compressible ) Conservative state. Called By proc~~primitive_to_conservative_compressible~~CalledByGraph proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~reconstruct_interfaces_primitive->proc~primitive_to_conservative_compressible proc~initialize~5 initialize proc~initialize~5->proc~primitive_to_conservative_compressible proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~reconstruct_interfaces_characteristic->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_to_conservative_compressible Source Code elemental function primitive_to_conservative_compressible ( primitive , eos ) result ( conservative_ ) !< Return a [[conservative_compressible]] state transforming a given [[primitive_compressible]] state. type ( primitive_compressible ), intent ( in ) :: primitive !< Primitive state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( conservative_compressible ) :: conservative_ !< Conservative state. conservative_ % density = primitive % density conservative_ % momentum = primitive % momentum () conservative_ % energy = primitive % energy ( eos = eos ) endfunction primitive_to_conservative_compressible","tags":"","loc":"proc/primitive_to_conservative_compressible.html","title":"primitive_to_conservative_compressible – FORESEER"},{"text":"private elemental function R(self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. Source Code R Source Code elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % cp_ - self % cv_ endfunction R","tags":"","loc":"proc/r.html","title":"R – FORESEER"},{"text":"private elemental function cp(self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. Source Code cp Source Code elemental function cp ( self ) result ( cp_ ) !< Return specific heat at constant pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. cp_ = self % cp_ endfunction cp","tags":"","loc":"proc/cp.html","title":"cp – FORESEER"},{"text":"private elemental function cv(self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. Source Code cv Source Code elemental function cv ( self ) result ( cv_ ) !< Return specific heat at constant volume. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. cv_ = self % cv_ endfunction cv","tags":"","loc":"proc/cv.html","title":"cv – FORESEER"},{"text":"private elemental function density(self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. Source Code density Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % gam () - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % gam () * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R () * temperature ) endif endfunction density","tags":"","loc":"proc/density.html","title":"density – FORESEER"},{"text":"private elemental function energy(self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. Source Code energy Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % gam () - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % gam () * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R () * temperature ) endif endfunction density elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % gam () - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy","tags":"","loc":"proc/energy.html","title":"energy – FORESEER"},{"text":"private elemental function eos_compressible_instance(cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Note This procedure is used for overloading eos_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Called By proc~~eos_compressible_instance~~CalledByGraph proc~eos_compressible_instance eos_compressible_instance interface~eos_compressible eos_compressible interface~eos_compressible->proc~eos_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eos_compressible_instance Source Code elemental function eos_compressible_instance ( cp , cv , gam , R ) result ( instance ) !< Return and instance of [[eos_compressible]]. !< !< @note This procedure is used for overloading [[eos_compressible]] name. real ( R8P ), intent ( in ), optional :: cp !< Specific heat at constant pressure `cp` value. real ( R8P ), intent ( in ), optional :: cv !< Specific heat at constant volume `cv` value. real ( R8P ), intent ( in ), optional :: gam !< Specific heats ratio `gamma=cp/cv` value. real ( R8P ), intent ( in ), optional :: R !< Fluid constant `R=cp-cv` value. type ( eos_compressible ) :: instance !< Instance of [[eos_compressible]]. if ( present ( cp ). and . present ( cv )) then instance % cp_ = cp instance % cv_ = cv elseif ( present ( gam ). and . present ( R )) then instance % cv_ = R / ( gam - 1._R8P ) instance % cp_ = gam * instance % cv_ elseif ( present ( gam ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp / gam elseif ( present ( gam ). and . present ( cv )) then instance % cp_ = gam * cv instance % cv_ = cv elseif ( present ( R ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp - R elseif ( present ( R ). and . present ( cv )) then instance % cp_ = cv + R instance % cv_ = cv endif endfunction eos_compressible_instance","tags":"","loc":"proc/eos_compressible_instance.html","title":"eos_compressible_instance – FORESEER"},{"text":"private elemental function gam(self) result(gam_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. Source Code gam Source Code elemental function gam ( self ) result ( gam_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gam_ !< Specific heats ratio value. gam_ = self % cp_ / self % cv_ endfunction gam","tags":"","loc":"proc/gam.html","title":"gam – FORESEER"},{"text":"private elemental function pressure(self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. Source Code pressure Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % gam () - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % gam () * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R () * temperature ) endif endfunction density elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % gam () - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy elemental function gam ( self ) result ( gam_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gam_ !< Specific heats ratio value. gam_ = self % cp_ / self % cv_ endfunction gam elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % gam () - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R () * temperature endif endfunction pressure","tags":"","loc":"proc/pressure.html","title":"pressure – FORESEER"},{"text":"private elemental function speed_of_sound(self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. Source Code speed_of_sound Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % gam () - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % gam () * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R () * temperature ) endif endfunction density elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % gam () - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy elemental function gam ( self ) result ( gam_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gam_ !< Specific heats ratio value. gam_ = self % cp_ / self % cv_ endfunction gam elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % gam () - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R () * temperature endif endfunction pressure elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % cp_ - self % cv_ endfunction R elemental function speed_of_sound ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. speed_of_sound_ = sqrt ( self % gam () * pressure / density ) endfunction speed_of_sound","tags":"","loc":"proc/speed_of_sound.html","title":"speed_of_sound – FORESEER"},{"text":"private elemental function temperature(self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code temperature Source Code elemental function temperature ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. temperature_ = 0._R8P if ( present ( density ). and . present ( pressure )) then temperature_ = pressure / ( self % R () * density ) elseif ( present ( energy )) then temperature_ = energy / self % cv () endif endfunction temperature","tags":"","loc":"proc/temperature.html","title":"temperature – FORESEER"},{"text":"public interface eos_compressible Overload eos_compressible name with its constructor. Calls interface~~eos_compressible~~CallsGraph interface~eos_compressible eos_compressible proc~eos_compressible_instance eos_compressible_instance interface~eos_compressible->proc~eos_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures eos_compressible_instance Module Procedures private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible .","tags":"","loc":"interface/eos_compressible.html","title":"eos_compressible – FORESEER"},{"text":"private function add(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code add Source Code function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density + rhs % density operator_result % velocity = lhs % velocity + rhs % velocity operator_result % pressure = lhs % pressure + rhs % pressure endselect endselect endfunction add","tags":"","loc":"proc/add.html","title":"add – FORESEER"},{"text":"private pure function array(self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of primitive. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of primitive. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of primitive. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endfunction array","tags":"","loc":"proc/array.html","title":"array – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~~CallsGraph proc~description description interface~str str proc~description->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endfunction description","tags":"","loc":"proc/description.html","title":"description – FORESEER"},{"text":"private elemental function energy(self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Source Code energy Source Code elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % gam () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy","tags":"","loc":"proc/energy~2.html","title":"energy – FORESEER"},{"text":"private pure function left_eigenvectors(self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. Source Code left_eigenvectors Source Code pure function left_eigenvectors ( self , eos ) result ( eig ) !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_a !< `g*p/a`. gp = eos % gam () * self % pressure gp_a = gp / eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0._R8P ; eig ( 1 , 2 ) = - gp_a ; eig ( 1 , 3 ) = 1._R8P eig ( 2 , 1 ) = gp / self % density ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - 1._R8P eig ( 3 , 1 ) = 0._R8P ; eig ( 3 , 2 ) = gp_a ; eig ( 3 , 3 ) = 1._R8P endfunction left_eigenvectors","tags":"","loc":"proc/left_eigenvectors.html","title":"left_eigenvectors – FORESEER"},{"text":"private elemental function momentum(self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Source Code momentum Source Code elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum","tags":"","loc":"proc/momentum.html","title":"momentum – FORESEER"},{"text":"private function negative(self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( operator_result ) !< Unary operator `- prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = - self % density operator_result % velocity = - self % velocity operator_result % pressure = - self % pressure endselect endfunction negative","tags":"","loc":"proc/negative.html","title":"negative – FORESEER"},{"text":"private function positive(self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( operator_result ) !< Unary operator `+ prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = + self % density operator_result % velocity = + self % velocity operator_result % pressure = + self % pressure endselect endfunction positive","tags":"","loc":"proc/positive.html","title":"positive – FORESEER"},{"text":"private function prim_divide_real(lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code prim_divide_real Source Code function prim_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim / real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density / rhs operator_result % velocity = lhs % velocity / rhs operator_result % pressure = lhs % pressure / rhs endselect endfunction prim_divide_real","tags":"","loc":"proc/prim_divide_real.html","title":"prim_divide_real – FORESEER"},{"text":"private function prim_multiply_prim(lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code prim_multiply_prim Source Code function prim_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs % density operator_result % velocity = lhs % velocity * rhs % velocity operator_result % pressure = lhs % pressure * rhs % pressure endselect endselect endfunction prim_multiply_prim","tags":"","loc":"proc/prim_multiply_prim.html","title":"prim_multiply_prim – FORESEER"},{"text":"private function prim_multiply_real(lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code prim_multiply_real Source Code function prim_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim * real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs operator_result % velocity = lhs % velocity * rhs operator_result % pressure = lhs % pressure * rhs endselect endfunction prim_multiply_real","tags":"","loc":"proc/prim_multiply_real.html","title":"prim_multiply_real – FORESEER"},{"text":"private elemental function primitive_compressible_instance(density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Note This procedure is used for overloading primitive_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . Called By proc~~primitive_compressible_instance~~CalledByGraph proc~primitive_compressible_instance primitive_compressible_instance interface~primitive_compressible primitive_compressible interface~primitive_compressible->proc~primitive_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_compressible_instance Source Code elemental function primitive_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[primitive_compressible]]. !< !< @note This procedure is used for overloading [[primitive_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: velocity !< Velocity, `v`. real ( R8P ), intent ( in ), optional :: pressure !< Pressure, `p`. type ( primitive_compressible ) :: instance !< Instance of [[primitive_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure endfunction primitive_compressible_instance","tags":"","loc":"proc/primitive_compressible_instance.html","title":"primitive_compressible_instance – FORESEER"},{"text":"public function primitive_compressible_pointer(to, error_message) result(pointer_) Return primitive_compressible pointer associated to primitive_object or its extensions until primitive_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( primitive_compressible ),\n  pointer Associated pointer. Source Code primitive_compressible_pointer Source Code function primitive_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[primitive_compressible]] pointer associated to [[primitive_object]] or its extensions until !< [[primitive_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( primitive_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( primitive_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( primitive_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast primitive_object to primitive_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction primitive_compressible_pointer","tags":"","loc":"proc/primitive_compressible_pointer.html","title":"primitive_compressible_pointer – FORESEER"},{"text":"private function real_multiply_prim(lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code real_multiply_prim Source Code function real_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `real * prim`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs * rhs % density operator_result % velocity = lhs * rhs % velocity operator_result % pressure = lhs * rhs % pressure endselect endfunction real_multiply_prim","tags":"","loc":"proc/real_multiply_prim.html","title":"real_multiply_prim – FORESEER"},{"text":"private pure function right_eigenvectors(self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. Source Code right_eigenvectors Source Code pure function right_eigenvectors ( self , eos ) result ( eig ) !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_inv !< `1/(g*p)`. real ( R8P ) :: a !< Speed of sound, `sqrt(g*p/r)`. gp = eos % gam () * self % pressure gp_inv = 1._R8P / gp a = eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0.5_R8P * self % density * gp_inv ; eig ( 1 , 2 ) = self % density * gp_inv ; eig ( 1 , 3 ) = eig ( 1 , 1 ) eig ( 2 , 1 ) = - 0.5_R8P * a * gp_inv ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - eig ( 2 , 1 ) eig ( 3 , 1 ) = 0.5_R8P ; eig ( 3 , 2 ) = 0._R8P ; eig ( 3 , 3 ) = eig ( 3 , 1 ) endfunction right_eigenvectors","tags":"","loc":"proc/right_eigenvectors.html","title":"right_eigenvectors – FORESEER"},{"text":"private function sub(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code sub Source Code function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density - rhs % density operator_result % velocity = lhs % velocity - rhs % velocity operator_result % pressure = lhs % pressure - rhs % pressure endselect endselect endfunction sub","tags":"","loc":"proc/sub.html","title":"sub – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FORESEER"},{"text":"private subroutine initialize(self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize","tags":"","loc":"proc/initialize~3.html","title":"initialize – FORESEER"},{"text":"private pure subroutine prim_assign_prim(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Source Code prim_assign_prim Source Code pure subroutine prim_assign_prim ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure endselect endsubroutine prim_assign_prim","tags":"","loc":"proc/prim_assign_prim.html","title":"prim_assign_prim – FORESEER"},{"text":"public interface primitive_compressible Overload primitive_compressible name with its constructor. Calls interface~~primitive_compressible~~CallsGraph interface~primitive_compressible primitive_compressible proc~primitive_compressible_instance primitive_compressible_instance interface~primitive_compressible->proc~primitive_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures primitive_compressible_instance Module Procedures private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible .","tags":"","loc":"interface/primitive_compressible.html","title":"primitive_compressible – FORESEER"},{"text":"private function add(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code add Source Code function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density + rhs % density operator_result % momentum = lhs % momentum + rhs % momentum operator_result % energy = lhs % energy + rhs % energy endselect endselect endfunction add","tags":"","loc":"proc/add~2.html","title":"add – FORESEER"},{"text":"private pure function array(self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of conservative. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of conservative. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of conservative. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % momentum % x array_ ( 3 ) = self % momentum % y array_ ( 4 ) = self % momentum % z array_ ( 5 ) = self % energy endfunction array","tags":"","loc":"proc/array~2.html","title":"array – FORESEER"},{"text":"private function cons_divide_real(lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code cons_divide_real Source Code function cons_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons / real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density / rhs operator_result % momentum = lhs % momentum / rhs operator_result % energy = lhs % energy / rhs endselect endfunction cons_divide_real","tags":"","loc":"proc/cons_divide_real.html","title":"cons_divide_real – FORESEER"},{"text":"private function cons_multiply_cons(lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code cons_multiply_cons Source Code function cons_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs % density operator_result % momentum = lhs % momentum * rhs % momentum operator_result % energy = lhs % energy * rhs % energy endselect endselect endfunction cons_multiply_cons","tags":"","loc":"proc/cons_multiply_cons.html","title":"cons_multiply_cons – FORESEER"},{"text":"private function cons_multiply_real(lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code cons_multiply_real Source Code function cons_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons * real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs operator_result % momentum = lhs % momentum * rhs operator_result % energy = lhs % energy * rhs endselect endfunction cons_multiply_real","tags":"","loc":"proc/cons_multiply_real.html","title":"cons_multiply_real – FORESEER"},{"text":"private elemental function conservative_compressible_instance(density, momentum, energy) result(instance) Return and instance of conservative_compressible . Note This procedure is used for overloading conservative_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . Called By proc~~conservative_compressible_instance~~CalledByGraph proc~conservative_compressible_instance conservative_compressible_instance interface~conservative_compressible conservative_compressible interface~conservative_compressible->proc~conservative_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_compressible_instance Source Code elemental function conservative_compressible_instance ( density , momentum , energy ) result ( instance ) !< Return and instance of [[conservative_compressible]]. !< !< @note This procedure is used for overloading [[conservative_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ), intent ( in ), optional :: energy !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. type ( conservative_compressible ) :: instance !< Instance of [[conservative_compressible]]. if ( present ( density )) instance % density = density if ( present ( momentum )) instance % momentum = momentum if ( present ( energy )) instance % energy = energy endfunction conservative_compressible_instance","tags":"","loc":"proc/conservative_compressible_instance.html","title":"conservative_compressible_instance – FORESEER"},{"text":"public function conservative_compressible_pointer(to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( conservative_compressible ),\n  pointer Associated pointer. Called By proc~~conservative_compressible_pointer~~CalledByGraph proc~conservative_compressible_pointer conservative_compressible_pointer proc~solve solve proc~solve->proc~conservative_compressible_pointer program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible program~foreseer_test_conservative_compressible->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_compressible_pointer Source Code function conservative_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( conservative_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( conservative_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( conservative_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast conservative_object to conservative_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction conservative_compressible_pointer","tags":"","loc":"proc/conservative_compressible_pointer.html","title":"conservative_compressible_pointer – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~2~~CallsGraph proc~description~2 description interface~str str proc~description~2->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'momentum = ' // trim ( str ( n = [ self % momentum % x , self % momentum % y , self % momentum % z ])) // NL desc = desc // prefix_ // 'energy   = ' // trim ( str ( n = self % energy )) endfunction description","tags":"","loc":"proc/description~2.html","title":"description – FORESEER"},{"text":"private function negative(self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( operator_result ) !< Unary operator `- cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = - self % density operator_result % momentum = - self % momentum operator_result % energy = - self % energy endselect endfunction negative","tags":"","loc":"proc/negative~2.html","title":"negative – FORESEER"},{"text":"private function positive(self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( operator_result ) !< Unary operator `+ cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = + self % density operator_result % momentum = + self % momentum operator_result % energy = + self % energy endselect endfunction positive","tags":"","loc":"proc/positive~2.html","title":"positive – FORESEER"},{"text":"private elemental function pressure(self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. Source Code pressure Source Code elemental function pressure ( self , eos ) result ( pressure_ ) !< Return pressure value. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % velocity () pressure_ = ( eos % gam () - 1._R8P ) * ( self % energy - 0.5_R8P * self % density * velocity_ % sq_norm ()) endfunction pressure","tags":"","loc":"proc/pressure~2.html","title":"pressure – FORESEER"},{"text":"private function real_multiply_cons(lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code real_multiply_cons Source Code function real_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `real * cons`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs * rhs % density operator_result % momentum = lhs * rhs % momentum operator_result % energy = lhs * rhs % energy endselect endfunction real_multiply_cons","tags":"","loc":"proc/real_multiply_cons.html","title":"real_multiply_cons – FORESEER"},{"text":"private function sub(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code sub Source Code function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density - rhs % density operator_result % momentum = lhs % momentum - rhs % momentum operator_result % energy = lhs % energy - rhs % energy endselect endselect endfunction sub","tags":"","loc":"proc/sub~2.html","title":"sub – FORESEER"},{"text":"private elemental function velocity(self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code velocity Source Code elemental function velocity ( self ) result ( velocity_ ) !< Return velocity vector. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % momentum / self % density endfunction velocity","tags":"","loc":"proc/velocity.html","title":"velocity – FORESEER"},{"text":"private subroutine compute_fluxes(self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. Source Code compute_fluxes Source Code subroutine compute_fluxes ( self , eos , normal , fluxes ) !< Compute conservative fluxes. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. real ( R8P ) :: velocity_normal_ !< Velocity component parallel to given normal. select type ( fluxes ) class is ( conservative_compressible ) pressure_ = self % pressure ( eos = eos ) velocity_ = self % velocity () velocity_normal_ = velocity_ . dot . normal fluxes % density = self % momentum . dot . normal fluxes % momentum = self % density * velocity_ * velocity_normal_ + pressure_ * normal fluxes % energy = ( self % energy + pressure_ ) * velocity_normal_ endselect endsubroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes.html","title":"compute_fluxes – FORESEER"},{"text":"private elemental subroutine compute_fluxes_from_primitive(self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. Source Code compute_fluxes_from_primitive Source Code elemental subroutine compute_fluxes_from_primitive ( self , eos , p , r , u , normal ) !< Compute conservative fluxes from primitives at interface. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: p !< Pressure at interface. real ( R8P ), intent ( in ) :: r !< Density at interface. real ( R8P ), intent ( in ) :: u !< Velocity (normal component) at interface. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. self % density = r * u self % momentum = ( r * u * u + p ) * normal self % energy = ( r * eos % energy ( density = r , pressure = p ) + r * u * u * 0.5_R8P + p ) * u endsubroutine compute_fluxes_from_primitive","tags":"","loc":"proc/compute_fluxes_from_primitive.html","title":"compute_fluxes_from_primitive – FORESEER"},{"text":"private pure subroutine cons_assign_cons(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Source Code cons_assign_cons Source Code pure subroutine cons_assign_cons ( lhs , rhs ) !< Operator `=`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( conservative_compressible ) lhs % density = rhs % density lhs % momentum = rhs % momentum lhs % energy = rhs % energy endselect endsubroutine cons_assign_cons","tags":"","loc":"proc/cons_assign_cons.html","title":"cons_assign_cons – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. type ( conservative_compressible ) :: fresh !< Fresh instance of conservative object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FORESEER"},{"text":"private subroutine initialize(self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( conservative_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( conservative_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – FORESEER"},{"text":"public interface conservative_compressible Overload conservative_compressible name with its constructor. Calls interface~~conservative_compressible~~CallsGraph interface~conservative_compressible conservative_compressible proc~conservative_compressible_instance conservative_compressible_instance interface~conservative_compressible->proc~conservative_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures conservative_compressible_instance Module Procedures private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible .","tags":"","loc":"interface/conservative_compressible.html","title":"conservative_compressible – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~3~~CallsGraph proc~description~3 description interface~str str proc~description~3->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'u_1 = ' // trim ( str ( n = self % u_1 )) // NL desc = desc // prefix_ // 'u_4 = ' // trim ( str ( n = self % u_4 )) // NL desc = desc // prefix_ // 'p_1 = ' // trim ( str ( n = self % p_1 )) // NL desc = desc // prefix_ // 'p_4 = ' // trim ( str ( n = self % p_4 )) // NL desc = desc // prefix_ // 'r_1 = ' // trim ( str ( n = self % r_1 )) // NL desc = desc // prefix_ // 'r_4 = ' // trim ( str ( n = self % r_4 )) // NL desc = desc // prefix_ // 'a_1 = ' // trim ( str ( n = self % a_1 )) // NL desc = desc // prefix_ // 'a_4 = ' // trim ( str ( n = self % a_4 )) // NL desc = desc // prefix_ // 'u23 = ' // trim ( str ( n = self % u23 )) // NL desc = desc // prefix_ // 'p23 = ' // trim ( str ( n = self % p23 )) // NL desc = desc // prefix_ // 'r_2 = ' // trim ( str ( n = self % r_2 )) // NL desc = desc // prefix_ // 'r_3 = ' // trim ( str ( n = self % r_3 )) // NL desc = desc // prefix_ // 's_1 = ' // trim ( str ( n = self % s_1 )) // NL desc = desc // prefix_ // 's_2 = ' // trim ( str ( n = self % s_2 )) // NL desc = desc // prefix_ // 's_3 = ' // trim ( str ( n = self % s_3 )) // NL desc = desc // prefix_ // 's_4 = ' // trim ( str ( n = self % s_4 )) endfunction description","tags":"","loc":"proc/description~3.html","title":"description – FORESEER"},{"text":"private elemental subroutine compute_fluxes(self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Sampling the pattern the interface states are computed. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . Source Code compute_fluxes Source Code elemental subroutine compute_fluxes ( self , eos_left , eos_right , normal , fluxes ) !< Compute fluxes at interface `x=xo`. !< !< Sampling the pattern the interface states are computed. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes at interface `x=xo`. real ( R8P ) :: a !< Speed of sound at interface `x=xo`. real ( R8P ) :: p !< Pressure at interface `x=xo`. real ( R8P ) :: r !< Desnity at interface `x=xo`. call fluxes % destroy associate ( s1 => self % s_1 , s2 => self % s_2 , u23 => self % u23 , s3 => self % s_3 , s4 => self % s_4 , & p1 => self % p_1 , r1 => self % r_1 , u1 => self % u_1 , a1 => self % a_1 , g1 => self % g_1 , d1 => self % d_1 , e1 => self % e_1 , & p4 => self % p_4 , r4 => self % r_4 , u4 => self % u_4 , a4 => self % a_4 , g4 => self % g_4 , d4 => self % d_4 , e4 => self % e_4 , & p23 => self % p23 , r2 => self % r_2 , r3 => self % r_3 ) select type ( fluxes ) class is ( conservative_compressible ) select case ( minloc ([ - s1 , s1 * s2 , s2 * u23 , u23 * s3 , s3 * s4 , s4 ], dim = 1 )) case ( 1 ) ! left supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p1 , r = r1 , u = u1 , normal = normal ) case ( 2 ) ! left transonic a = ( a1 + u1 * d1 ) / ( 1._R8P + d1 ) p = p1 * ( a / a1 ) ** e1 r = eos_left % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p , r = r , u = a , normal = normal ) case ( 3 ) ! left subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p23 , r = r2 , u = u23 , normal = normal ) case ( 4 ) ! right subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p23 , r = r3 , u = u23 , normal = normal ) case ( 5 ) ! right transonic a = ( a4 - u4 * d4 ) / ( 1._R8P + d4 ) p = p4 * ( a / a4 ) ** e4 r = eos_right % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p , r = r , u =- a , normal = normal ) case ( 6 ) ! right supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p4 , r = r4 , u = u4 , normal = normal ) endselect endselect endassociate endsubroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~2.html","title":"compute_fluxes – FORESEER"},{"text":"private elemental subroutine set_states14(self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. Source Code set_states14 Source Code elemental subroutine set_states14 ( self , eos_left , state_left , eos_right , state_right , normal ) !< Set states 1 and 4. class ( riemann_solver_compressible_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. select type ( state_left ) class is ( conservative_compressible ) self % g_1 = eos_left % gam () self % d_1 = ( self % g_1 - 1._R8P ) * 0.5_R8P self % e_1 = 2._R8P * self % g_1 / ( self % g_1 - 1._R8P ) self % u_1 = state_left % velocity (). dot . normal self % p_1 = state_left % pressure ( eos = eos_left ) self % r_1 = state_left % density self % a_1 = eos_left % speed_of_sound ( density = state_left % density , pressure = self % p_1 ) endselect select type ( state_right ) class is ( conservative_compressible ) self % g_4 = eos_right % gam () self % d_4 = ( self % g_4 - 1._R8P ) * 0.5_R8P self % e_4 = 2._R8P * self % g_4 / ( self % g_4 - 1._R8P ) self % u_4 = state_right % velocity (). dot . normal self % p_4 = state_right % pressure ( eos = eos_right ) self % r_4 = state_right % density self % a_4 = eos_right % speed_of_sound ( density = state_right % density , pressure = self % p_4 ) endselect endsubroutine set_states14","tags":"","loc":"proc/set_states14.html","title":"set_states14 – FORESEER"},{"text":"private function add_euler(lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Source Code add_euler Source Code function add_euler ( lhs , rhs ) result ( opr ) !< Add two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) + rhs % U ( i ) enddo endselect endselect endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FORESEER"},{"text":"private pure function compute_dt(self, steps_max, t_max, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. integer(kind=I4P), intent(in) :: steps_max Maximun number of time steps. real(kind=R8P), intent(in) :: t_max Maximum integration time. real(kind=R8P), intent(in) :: t Time. real(kind=R8P), intent(in) :: CFL CFL value. Return Value real(kind=R8P) Time step. Source Code compute_dt Source Code pure function compute_dt ( self , steps_max , t_max , t , CFL ) result ( Dt ) !< Compute the current time step by means of CFL condition. class ( euler_1d ), intent ( in ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: steps_max !< Maximun number of time steps. real ( R8P ), intent ( in ) :: t_max !< Maximum integration time. real ( R8P ), intent ( in ) :: t !< Time. real ( R8P ), intent ( in ) :: CFL !< CFL value. real ( R8P ) :: Dt !< Time step. type ( vector ) :: u !< Velocity vector. real ( R8P ) :: a !< Speed of sound. real ( R8P ) :: vmax !< Maximum propagation speed of signals. integer ( I4P ) :: i !< Counter. associate ( Ni => self % Ni , Dx => self % Dx ) vmax = 0._R8P do i = 1 , Ni u = self % U ( i )% velocity () a = self % eos % speed_of_sound ( density = self % U ( i )% density , pressure = self % U ( i )% pressure ( eos = self % eos )) vmax = max ( vmax , u % normL2 () + a ) enddo Dt = Dx * CFL / vmax if ( steps_max <= 0 . and . t_max > 0._R8P ) then if (( t + Dt ) > t_max ) Dt = t_max - t endif endassociate endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FORESEER"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. real(kind=R8P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Source Code dEuler_dt Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !< Time derivative of Euler field, the residuals function. class ( euler_1d ), intent ( in ) :: self !< Euler field. real ( R8P ), intent ( in ), optional :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. type ( conservative_compressible ) :: U ( 1 - self % Ng : self % Ni + self % Ng ) !< Conservative variables. type ( conservative_compressible ) :: UR ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed conservative variables. type ( conservative_compressible ) :: F ( 0 : self % Ni ) !< Fluxes of conservative variables. integer ( I4P ) :: i !< Counter. do i = 1 , self % Ni U ( i ) = self % U ( i ) enddo call self % impose_boundary_conditions ( U = U ) call self % reconstruct_interfaces ( conservative = U , r_conservative = UR ) do i = 0 , self % Ni call self % riemann_solver ( eos_left = self % eos , state_left = UR ( 2 , i ), & eos_right = self % eos , state_right = UR ( 1 , i + 1 ), normal = ex , fluxes = F ( i )) enddo allocate ( euler_1d :: dState_dt ) select type ( dState_dt ) class is ( euler_1d ) dState_dt = self do i = 1 , self % Ni dState_dt % U ( i ) = ( F ( i - 1 ) - F ( i )) / self % Dx enddo endselect endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FORESEER"},{"text":"private function euler_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. Source Code euler_local_error Source Code function euler_local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. real ( R8P ) :: error !< Error estimation. real ( R8P ), allocatable :: U_lhs (:) !< Serialized conservative variables. real ( R8P ), allocatable :: U_rhs (:) !< Serialized conservative variables. integer ( I4P ) :: i !< Space counter. integer ( I4P ) :: v !< Variables counter. select type ( rhs ) class is ( euler_1d ) error = 0._R8P do i = 1 , lhs % Ni U_lhs = lhs % U ( i )% array () U_rhs = rhs % U ( i )% array () do v = 1 , size ( U_lhs , dim = 1 ) error = error + ( U_lhs ( v ) - U_rhs ( v )) ** 2 / U_lhs ( v ) ** 2 enddo enddo error = sqrt ( error ) endselect endfunction euler_local_error","tags":"","loc":"proc/euler_local_error.html","title":"euler_local_error – FORESEER"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Source Code euler_multiply_euler Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by another one. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) * rhs % U ( i ) enddo endselect endselect endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FORESEER"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Source Code euler_multiply_real Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by a real scalar. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs do i = 1 , lhs % Ni opr % U ( i ) = rhs * lhs % U ( i ) enddo endselect endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FORESEER"},{"text":"private pure function output(self, is_primitive) result(state) Output the Euler field state. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. logical, intent(in), optional :: is_primitive Output in primitive variables. Return Value real(kind=R8P),\n  allocatable,(:,:) Euler state vector. Calls proc~~output~~CallsGraph proc~output output proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~output->proc~conservative_to_primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code output Source Code pure function output ( self , is_primitive ) result ( state ) !< Output the Euler field state. class ( euler_1d ), intent ( in ) :: self !< Euler field. logical , intent ( in ), optional :: is_primitive !< Output in primitive variables. real ( R8P ), allocatable :: state (:,:) !< Euler state vector. real ( R8P ), allocatable :: state_ (:) !< Euler state vector, local variable. logical :: is_primitive_ !< Output in primitive variables, local variable. type ( primitive_compressible ) :: primitive !< Primitive state. integer ( I4P ) :: i !< Counter. is_primitive_ = . false . ; if ( present ( is_primitive )) is_primitive_ = is_primitive if ( is_primitive_ ) then allocate ( state ( 1 : size ( primitive % array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni primitive = conservative_to_primitive_compressible ( conservative = self % U ( i ), eos = self % eos ) state_ = primitive % array () enddo else allocate ( state ( 1 : size ( self % U ( 1 )% array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni state_ = self % U ( i )% array () state (:, i ) = state_ enddo endif endfunction output","tags":"","loc":"proc/output.html","title":"output – FORESEER"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Source Code real_multiply_euler Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply a real scalar by an Euler field. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( euler_1d ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = rhs do i = 1 , rhs % Ni opr % U ( i ) = lhs * rhs % U ( i ) enddo endselect endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FORESEER"},{"text":"private function sub_euler(lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Source Code sub_euler Source Code function sub_euler ( lhs , rhs ) result ( opr ) !< Subtract two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) - rhs % U ( i ) enddo endselect endselect endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – FORESEER"},{"text":"private pure subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. Source Code destroy Source Code pure subroutine destroy ( self ) !< Destroy field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. self % weno_order = 0 self % Ni = 0 self % Ng = 0 self % Dx = 0._R8P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) if ( allocated ( self % interpolator )) deallocate ( self % interpolator ) endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FORESEER"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !< Assign one Euler field to another. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. select type ( rhs ) class is ( euler_1d ) lhs % weno_order = rhs % weno_order lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Dx = rhs % Dx lhs % eos = rhs % eos if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Ni )) select type ( rhs ) class is ( euler_1d ) if ( allocated ( rhs % U )) then do i = 1 , lhs % Ni lhs % U ( i ) = rhs % U ( i ) enddo endif endselect endif if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R if ( allocated ( rhs % interpolator )) then if ( allocated ( lhs % interpolator )) deallocate ( lhs % interpolator ) allocate ( lhs % interpolator , source = rhs % interpolator ) endif if ( associated ( rhs % reconstruct_interfaces )) lhs % reconstruct_interfaces => rhs % reconstruct_interfaces if ( associated ( rhs % riemann_solver )) lhs % riemann_solver => rhs % riemann_solver endselect endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FORESEER"},{"text":"private subroutine euler_assign_real(lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code euler_assign_real Source Code subroutine euler_assign_real ( lhs , rhs ) !< Assign one real to an Euler field. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. if ( allocated ( lhs % U )) then do i = 1 , lhs % Ni lhs % U ( i )% density = rhs lhs % U ( i )% momentum = rhs lhs % U ( i )% energy = rhs enddo endif endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FORESEER"},{"text":"private pure subroutine impose_boundary_conditions(self, U) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(inout) :: U (1-self%Ng:) Conservative variables. Source Code impose_boundary_conditions Source Code pure subroutine impose_boundary_conditions ( self , U ) !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( inout ) :: U ( 1 - self % Ng :) !< Conservative variables. ! type(primitive_compressible), intent(inout) :: P(1-self%Ng:) !< Primitive variables. integer ( I4P ) :: i !< Space counter. select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 ! P(i) = P(-i+1) U ( i ) = U ( - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 ! P(i)%density  =   P(-i+1)%density ! P(i)%velocity = - P(-i+1)%velocity ! P(i)%pressure =   P(-i+1)%pressure U ( i )% density = U ( - i + 1 )% density U ( i )% momentum = - U ( - i + 1 )% momentum U ( i )% energy = U ( - i + 1 )% energy enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i) = P(self%Ni-(i-self%Ni-1)) U ( i ) = U ( self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i)%density  =   P(self%Ni-(i-self%Ni-1))%density ! P(i)%velocity = - P(self%Ni-(i-self%Ni-1))%velocity ! P(i)%pressure =   P(self%Ni-(i-self%Ni-1))%pressure U ( i )% density = U ( self % Ni - ( i - self % Ni - 1 ))% density U ( i )% momentum = - U ( self % Ni - ( i - self % Ni - 1 ))% momentum U ( i )% energy = U ( self % Ni - ( i - self % Ni - 1 ))% energy enddo endselect endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FORESEER"},{"text":"private subroutine initialize(self, Ni, Dx, BC_L, BC_R, initial_state, eos, weno_order, weno_variables, riemann_solver_scheme) Initialize field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. integer(kind=I4P), intent(in) :: Ni Space dimension. real(kind=R8P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. type( primitive_compressible ), intent(in) :: initial_state (1:) Initial state of primitive variables. type( eos_compressible ), intent(in) :: eos Equation of state. integer(kind=I4P), intent(in), optional :: weno_order WENO reconstruction order. character(len=*), intent(in), optional :: weno_variables Variables on which WENO reconstruction is done. character(len=*), intent(in), optional :: riemann_solver_scheme Riemann solver scheme. Calls proc~~initialize~5~~CallsGraph proc~initialize~5 initialize proc~wenoof_create wenoof_create proc~initialize~5->proc~wenoof_create proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~initialize~5->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , Ni , Dx , BC_L , BC_R , initial_state , eos , weno_order , weno_variables , riemann_solver_scheme ) !< Initialize field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: Ni !< Space dimension. real ( R8P ), intent ( in ) :: Dx !< Space step. character ( * ), intent ( in ) :: BC_L !< Left boundary condition type. character ( * ), intent ( in ) :: BC_R !< Right boundary condition type. type ( primitive_compressible ), intent ( in ) :: initial_state ( 1 :) !< Initial state of primitive variables. type ( eos_compressible ), intent ( in ) :: eos !< Equation of state. integer ( I4P ), intent ( in ), optional :: weno_order !< WENO reconstruction order. character ( * ), intent ( in ), optional :: weno_variables !< Variables on which WENO reconstruction is done. character ( * ), intent ( in ), optional :: riemann_solver_scheme !< Riemann solver scheme. character (:), allocatable :: weno_variables_ !< WENO Variables, local variable. character (:), allocatable :: riemann_solver_scheme_ !< Riemann solver scheme, local variable. integer ( I4P ) :: i !< Space couner. call self % destroy self % weno_order = 1 ; if ( present ( weno_order )) self % weno_order = weno_order self % Ni = Ni self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = Dx self % eos = eos if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 - self % Ng : self % Ni + self % Ng )) do i = 1 , Ni self % U ( i ) = primitive_to_conservative_compressible ( primitive = initial_state ( i ), eos = eos ) enddo self % BC_L = BC_L self % BC_R = BC_R if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = self % interpolator ) weno_variables_ = 'llf' if ( present ( weno_variables )) weno_variables_ = trim ( adjustl ( weno_variables )) select case ( weno_variables_ ) case ( 'characteristic' ) self % reconstruct_interfaces => reconstruct_interfaces_characteristic case ( 'conservative' ) self % reconstruct_interfaces => reconstruct_interfaces_conservative case ( 'primitive' ) self % reconstruct_interfaces => reconstruct_interfaces_primitive case default error stop 'error: WENO reconstruction variables set \"' // weno_variables_ // '\" unknown!' endselect riemann_solver_scheme_ = 'llf' if ( present ( riemann_solver_scheme )) riemann_solver_scheme_ = trim ( adjustl ( riemann_solver_scheme )) select case ( riemann_solver_scheme_ ) case ( 'llf' ) self % riemann_solver => riemann_solver_llf case ( 'pvl' ) self % riemann_solver => riemann_solver_pvl case default error stop 'error: Riemann Solver scheme \"' // riemann_solver_scheme_ // '\" unknown!' endselect endsubroutine initialize","tags":"","loc":"proc/initialize~5.html","title":"initialize – FORESEER"},{"text":"private subroutine reconstruct_interfaces_characteristic(self, conservative, r_conservative) Reconstruct interfaces states. The reconstruction is done in pseudo characteristic variables. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Calls proc~~reconstruct_interfaces_characteristic~~CallsGraph proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~wenoof_create wenoof_create proc~reconstruct_interfaces_characteristic->proc~wenoof_create proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~reconstruct_interfaces_characteristic->proc~conservative_to_primitive_compressible proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~reconstruct_interfaces_characteristic->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code reconstruct_interfaces_characteristic Source Code subroutine reconstruct_interfaces_characteristic ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in pseudo characteristic variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. type ( primitive_compressible ) :: Pm ( 1 : 2 ) !< Mean of primitive variables. real ( R8P ) :: LPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R8P ) :: RPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean right eigenvectors matrix. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. real ( R8P ) :: buffer ( 1 : 3 ) !< Dummy buffer. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm ( f ) = 0.5_R8P * ( primitive ( i + f - 2 ) + primitive ( i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = Pm ( f )% left_eigenvectors ( eos = self % eos ) RPm (:, :, f ) = Pm ( f )% right_eigenvectors ( eos = self % eos ) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , 3 C ( f , j - i , v ) = dot_product ( LPm ( v , :, f ), [ primitive ( j )% density , primitive ( j )% velocity % x , primitive ( j )% pressure ]) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , 3 buffer ( v ) = dot_product ( RPm ( v , :, f ), CR ( f , :)) enddo r_primitive ( f , i )% density = buffer ( 1 ) r_primitive ( f , i )% velocity = buffer ( 2 ) * ex r_primitive ( f , i )% pressure = buffer ( 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_characteristic","tags":"","loc":"proc/reconstruct_interfaces_characteristic.html","title":"reconstruct_interfaces_characteristic – FORESEER"},{"text":"private subroutine reconstruct_interfaces_conservative(self, conservative, r_conservative) Reconstruct interfaces states. The reconstruction is done in conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Calls proc~~reconstruct_interfaces_conservative~~CallsGraph proc~reconstruct_interfaces_conservative reconstruct_interfaces_conservative proc~wenoof_create wenoof_create proc~reconstruct_interfaces_conservative->proc~wenoof_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code reconstruct_interfaces_conservative Source Code subroutine reconstruct_interfaces_conservative ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in conservative variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. real ( R8P ), allocatable :: U (:) !< Serialized conservative variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng U = conservative ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = U ( 1 ) C ( f , j - i , 2 ) = U ( 2 ) C ( f , j - i , 3 ) = U ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_conservative ( f , i )% density = CR ( f , 1 ) r_conservative ( f , i )% momentum = CR ( f , 2 ) * ex r_conservative ( f , i )% energy = CR ( f , 3 ) enddo enddo endselect endsubroutine reconstruct_interfaces_conservative","tags":"","loc":"proc/reconstruct_interfaces_conservative.html","title":"reconstruct_interfaces_conservative – FORESEER"},{"text":"private subroutine reconstruct_interfaces_primitive(self, conservative, r_conservative) Reconstruct interfaces states. The reconstruction is done in primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Calls proc~~reconstruct_interfaces_primitive~~CallsGraph proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~wenoof_create wenoof_create proc~reconstruct_interfaces_primitive->proc~wenoof_create proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~reconstruct_interfaces_primitive->proc~conservative_to_primitive_compressible proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~reconstruct_interfaces_primitive->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code reconstruct_interfaces_primitive Source Code subroutine reconstruct_interfaces_primitive ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in primitive variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R8P ), allocatable :: P (:) !< Serialized primitive variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng P = primitive ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = P ( 1 ) C ( f , j - i , 2 ) = P ( 2 ) C ( f , j - i , 3 ) = P ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_primitive ( f , i )% density = CR ( f , 1 ) r_primitive ( f , i )% velocity = CR ( f , 2 ) * ex r_primitive ( f , i )% pressure = CR ( f , 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_primitive","tags":"","loc":"proc/reconstruct_interfaces_primitive.html","title":"reconstruct_interfaces_primitive – FORESEER"},{"text":"private subroutine riemann_solver_llf(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_llf Source Code subroutine riemann_solver_llf ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_llf","tags":"","loc":"proc/riemann_solver_llf.html","title":"riemann_solver_llf – FORESEER"},{"text":"private subroutine riemann_solver_pvl(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_pvl Source Code subroutine riemann_solver_pvl ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_pvl","tags":"","loc":"proc/riemann_solver_pvl.html","title":"riemann_solver_pvl – FORESEER"},{"text":"subroutine initialize() Initialize the test. Arguments None Calls proc~~initialize~6~~CallsGraph proc~initialize~6 initialize proc~parse_command_line_interface parse_command_line_interface proc~initialize~6->proc~parse_command_line_interface interface~cton cton proc~parse_command_line_interface->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~initialize~6~~CalledByGraph proc~initialize~6 initialize program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , Ni , Dx , BC_L , BC_R , initial_state , eos , weno_order , weno_variables , riemann_solver_scheme ) !< Initialize field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: Ni !< Space dimension. real ( R8P ), intent ( in ) :: Dx !< Space step. character ( * ), intent ( in ) :: BC_L !< Left boundary condition type. character ( * ), intent ( in ) :: BC_R !< Right boundary condition type. type ( primitive_compressible ), intent ( in ) :: initial_state ( 1 :) !< Initial state of primitive variables. type ( eos_compressible ), intent ( in ) :: eos !< Equation of state. integer ( I4P ), intent ( in ), optional :: weno_order !< WENO reconstruction order. character ( * ), intent ( in ), optional :: weno_variables !< Variables on which WENO reconstruction is done. character ( * ), intent ( in ), optional :: riemann_solver_scheme !< Riemann solver scheme. character (:), allocatable :: weno_variables_ !< WENO Variables, local variable. character (:), allocatable :: riemann_solver_scheme_ !< Riemann solver scheme, local variable. integer ( I4P ) :: i !< Space couner. call self % destroy self % weno_order = 1 ; if ( present ( weno_order )) self % weno_order = weno_order self % Ni = Ni self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = Dx self % eos = eos if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 - self % Ng : self % Ni + self % Ng )) do i = 1 , Ni self % U ( i ) = primitive_to_conservative_compressible ( primitive = initial_state ( i ), eos = eos ) enddo self % BC_L = BC_L self % BC_R = BC_R if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = self % interpolator ) weno_variables_ = 'llf' if ( present ( weno_variables )) weno_variables_ = trim ( adjustl ( weno_variables )) select case ( weno_variables_ ) case ( 'characteristic' ) self % reconstruct_interfaces => reconstruct_interfaces_characteristic case ( 'conservative' ) self % reconstruct_interfaces => reconstruct_interfaces_conservative case ( 'primitive' ) self % reconstruct_interfaces => reconstruct_interfaces_primitive case default error stop 'error: WENO reconstruction variables set \"' // weno_variables_ // '\" unknown!' endselect riemann_solver_scheme_ = 'llf' if ( present ( riemann_solver_scheme )) riemann_solver_scheme_ = trim ( adjustl ( riemann_solver_scheme )) select case ( riemann_solver_scheme_ ) case ( 'llf' ) self % riemann_solver => riemann_solver_llf case ( 'pvl' ) self % riemann_solver => riemann_solver_pvl case default error stop 'error: Riemann Solver scheme \"' // riemann_solver_scheme_ // '\" unknown!' endselect endsubroutine initialize","tags":"","loc":"proc/initialize~6.html","title":"initialize – FORESEER"},{"text":"subroutine parse_command_line_interface() Parse Command Line Interface (CLI). Arguments None Calls proc~~parse_command_line_interface~~CallsGraph proc~parse_command_line_interface parse_command_line_interface interface~cton cton proc~parse_command_line_interface->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~parse_command_line_interface~~CalledByGraph proc~parse_command_line_interface parse_command_line_interface proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parse_command_line_interface Source Code subroutine parse_command_line_interface () !< Parse Command Line Interface (CLI). type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I4P ) :: error !< Error handler. character ( len = :), allocatable :: buffer !< String buffer. call cli % init ( description = 'FORESEER test: shock tube tester, 1D Euler equations' , & examples = [ \"foreseer_test_shock_tube         \" , & \"foreseer_test_shock_tube --tserie\" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '60' ) call cli % add ( switch = '--t-max' , help = 'Maximum integration time' , required = . false ., act = 'store' , def = '0.' ) call cli % add ( switch = '--riemann' , help = 'Riemann Problem solver' , required = . false ., act = 'store' , def = 'llf' , choices = 'llf,pvl' ) call cli % add ( switch = '--s-scheme' , help = 'Space intergation scheme' , required = . false ., act = 'store' , def = 'weno-char-1' , & choices = 'weno-char-1,weno-char-3,weno-char-5,weno-char-7,weno-char-9,weno-char-11,weno-char-13,weno-char-15,weno-char-17,' // & 'weno-cons-1,weno-cons-3,weno-cons-5,weno-cons-7,weno-cons-9,weno-cons-11,weno-cons-13,weno-cons-15,weno-cons-17,' // & 'weno-prim-1,weno-prim-3,weno-prim-5,weno-prim-7,weno-prim-9,weno-prim-11,weno-prim-13,weno-prim-15,weno-prim-17' ) call cli % add ( switch = '--t-scheme' , help = 'Time intergation scheme' , required = . false ., act = 'store' , def = 'tvd-rk-1' , & choices = 'tvd-rk-1,tvd-rk-2,tvd-rk-3,tvd-rk-5' ) call cli % add ( switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.7' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-max' , val = t_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--riemann' , val = riemann_solver_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--s-scheme' , val = s_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-scheme' , val = t_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--cfl' , val = CFL , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop if ( t_max > 0._R8P ) steps_max = 0 buffer = trim ( adjustl ( s_scheme )) select case ( buffer ( 6 : 9 )) case ( 'char' ) weno_variables = 'characteristic' case ( 'cons' ) weno_variables = 'conservative' case ( 'prim' ) weno_variables = 'primitive' endselect weno_order = cton ( buffer ( 11 :), knd = 1_I4P ) select case ( trim ( adjustl ( t_scheme ))) case ( 'tvd-rk-1' ) rk_stages_number = 1 case ( 'tvd-rk-2' ) rk_stages_number = 2 case ( 'tvd-rk-3' ) rk_stages_number = 3 case ( 'tvd-rk-5' ) rk_stages_number = 5 endselect endsubroutine parse_command_line_interface","tags":"","loc":"proc/parse_command_line_interface.html","title":"parse_command_line_interface – FORESEER"},{"text":"subroutine save_time_serie(filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R8P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~~CallsGraph proc~save_time_serie save_time_serie interface~str str proc~save_time_serie->interface~str proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~save_time_serie->proc~conservative_to_primitive_compressible proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string var panprocsave_time_serieCallsGraph = svgPanZoom('#procsave_time_serieCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~~CalledByGraph proc~save_time_serie save_time_serie program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~save_time_serie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( filename , finish , t ) !< Save time-serie results. character ( * ), intent ( in ), optional :: filename !< Output filename. logical , intent ( in ), optional :: finish !< Flag for triggering the file closing. real ( R8P ), intent ( in ) :: t !< Current integration time. integer ( I4P ), save :: tsfile !< File unit for saving time serie results. type ( primitive_compressible ) :: primitive !< Primitive variables. integer ( I4P ) :: i !< Counter. if ( time_serie ) then if ( present ( filename )) then open ( newunit = tsfile , file = filename ) endif write ( tsfile , '(A)' ) 'VARIABLES = \"x\" \"rho\" \"u\" \"p\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni primitive = conservative_to_primitive_compressible ( conservative = domain % U ( i ), eos = domain % eos ) write ( tsfile , '(4' // '(' // FR8P // ',1X))' ) x ( i ), primitive % density , primitive % velocity % x , primitive % pressure enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FORESEER"},{"text":"private elemental function color_index(color) Return the array-index corresponding to the queried color. Note Because Foreground and backround colors lists share the same name, no matter what array is used to find the color index.\n Thus, the foreground array is used. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: color Color definition. Return Value integer(kind=int32) Index into the colors arrays. Called By proc~~color_index~~CalledByGraph proc~color_index color_index proc~colorize colorize proc~colorize->proc~color_index proc~errored~2 errored proc~errored~2->proc~colorize proc~errored errored proc~errored->proc~colorize proc~styles_samples styles_samples proc~styles_samples->proc~colorize proc~usage~3 usage proc~usage~3->proc~colorize proc~errored~3 errored proc~errored~3->proc~colorize proc~colors_samples colors_samples proc~colors_samples->proc~colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code color_index Source Code elemental function color_index ( color ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the array-index corresponding to the queried color. !< !< @note Because Foreground and backround colors lists share the same name, no matter what array is used to find the color index. !< Thus, the foreground array is used. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: color !< Color definition. integer ( int32 ) :: color_index !< Index into the colors arrays. integer ( int32 ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- color_index = 0 do c = 1 , size ( COLORS_FG , dim = 2 ) if ( trim ( COLORS_FG ( 1 , c )) == trim ( adjustl ( color ))) then color_index = c exit endif enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction color_index","tags":"","loc":"proc/color_index.html","title":"color_index – FORESEER"},{"text":"public pure function colorize(string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),\n  allocatable Colorized string. Calls proc~~colorize~~CallsGraph proc~colorize colorize proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~colorize~~CalledByGraph proc~colorize colorize proc~errored~2 errored proc~errored~2->proc~colorize proc~errored errored proc~errored->proc~colorize proc~styles_samples styles_samples proc~styles_samples->proc~colorize proc~usage~3 usage proc~usage~3->proc~colorize proc~errored~3 errored proc~errored~3->proc~colorize proc~colors_samples colors_samples proc~colors_samples->proc~colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code colorize Source Code pure function colorize ( string , color_fg , color_bg , style ) result ( colorized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Colorize and stylize strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< Input string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color definition. character ( len =* ), intent ( in ), optional :: color_bg !< Background color definition. character ( len =* ), intent ( in ), optional :: style !< Style definition. character ( len = :), allocatable :: colorized !< Colorized string. integer ( int32 ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- colorized = string if ( present ( color_fg )) then i = color_index ( upper ( color_fg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_FG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( color_bg )) then i = color_index ( upper ( color_bg )) if ( i > 0 ) colorized = CODE_START // trim ( COLORS_BG ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif if ( present ( style )) then i = style_index ( upper ( style )) if ( i > 0 ) colorized = CODE_START // trim ( STYLES ( 2 , i )) // CODE_END // colorized // CODE_CLEAR endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction colorize","tags":"","loc":"proc/colorize.html","title":"colorize – FORESEER"},{"text":"private elemental function style_index(style) Return the array-index corresponding to the queried style. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: style Style definition. Return Value integer(kind=int32) Index into the styles array. Called By proc~~style_index~~CalledByGraph proc~style_index style_index proc~colorize colorize proc~colorize->proc~style_index proc~errored~2 errored proc~errored~2->proc~colorize proc~errored errored proc~errored->proc~colorize proc~styles_samples styles_samples proc~styles_samples->proc~colorize proc~usage~3 usage proc~usage~3->proc~colorize proc~errored~3 errored proc~errored~3->proc~colorize proc~colors_samples colors_samples proc~colors_samples->proc~colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code style_index Source Code elemental function style_index ( style ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the array-index corresponding to the queried style. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: style !< Style definition. integer ( int32 ) :: style_index !< Index into the styles array. integer ( int32 ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- style_index = 0 do s = 1 , size ( STYLES , dim = 2 ) if ( trim ( STYLES ( 1 , s )) == trim ( adjustl ( style ))) then style_index = s exit endif enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction style_index","tags":"","loc":"proc/style_index.html","title":"style_index – FORESEER"},{"text":"private elemental function upper(string) Return a string with all uppercase characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. Return Value character(len=len(string)) Upper case string. Called By proc~~upper~~CalledByGraph proc~upper upper proc~colorize colorize proc~colorize->proc~upper proc~errored~2 errored proc~errored~2->proc~colorize proc~errored errored proc~errored->proc~colorize proc~styles_samples styles_samples proc~styles_samples->proc~colorize proc~usage~3 usage proc~usage~3->proc~colorize proc~errored~3 errored proc~errored~3->proc~colorize proc~colors_samples colors_samples proc~colors_samples->proc~colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code upper Source Code elemental function upper ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< Input string. character ( len = len ( string )) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- upper = string do n1 = 1 , len ( string ) n2 = index ( LOWER_ALPHABET , string ( n1 : n1 )) if ( n2 > 0 ) upper ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper","tags":"","loc":"proc/upper.html","title":"upper – FORESEER"},{"text":"public subroutine colors_samples() Print to standard output all colors samples. Arguments None Calls proc~~colors_samples~~CallsGraph proc~colors_samples colors_samples proc~colorize colorize proc~colors_samples->proc~colorize proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code colors_samples Source Code subroutine colors_samples () !--------------------------------------------------------------------------------------------------------------------------------- !< Print to standard output all colors samples. !--------------------------------------------------------------------------------------------------------------------------------- integer ( int32 ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print '(A)' , colorize ( 'Foreground colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_FG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_FG ( 1 , c ) // '\", color_fg=\"' // COLORS_FG ( 1 , c ) // '\") => ' // & colorize ( COLORS_FG ( 1 , c ), color_fg = COLORS_FG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_FG ( 2 , c )), color_fg = COLORS_FG ( 1 , c ), style = 'inverse_on' ) enddo print '(A)' , colorize ( 'Background colors samples' , color_fg = 'red_intense' ) do c = 1 , size ( COLORS_BG , dim = 2 ) print '(A)' , '  colorize(\"' // COLORS_BG ( 1 , c ) // '\", color_bg=\"' // COLORS_BG ( 1 , c ) // '\") => ' // & colorize ( COLORS_BG ( 1 , c ), color_bg = COLORS_BG ( 1 , c )) // & ' code: ' // colorize ( trim ( COLORS_BG ( 2 , c )), color_bg = COLORS_BG ( 1 , c ), style = 'inverse_on' ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine colors_samples","tags":"","loc":"proc/colors_samples.html","title":"colors_samples – FORESEER"},{"text":"public subroutine styles_samples() Print to standard output all styles samples. Arguments None Calls proc~~styles_samples~~CallsGraph proc~styles_samples styles_samples proc~colorize colorize proc~styles_samples->proc~colorize proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code styles_samples Source Code subroutine styles_samples () !--------------------------------------------------------------------------------------------------------------------------------- !< Print to standard output all styles samples. !--------------------------------------------------------------------------------------------------------------------------------- integer ( int32 ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print '(A)' , colorize ( 'Styles samples' , color_fg = 'red_intense' ) do s = 1 , size ( STYLES , dim = 2 ) print '(A)' , '  colorize(\"' // STYLES ( 1 , s ) // '\", style=\"' // STYLES ( 1 , s ) // '\") => ' // & colorize ( STYLES ( 1 , s ), style = STYLES ( 1 , s )) // & ' code: ' // colorize ( trim ( STYLES ( 2 , s )), color_fg = 'magenta' , style = 'inverse_on' ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine styles_samples","tags":"","loc":"proc/styles_samples.html","title":"styles_samples – FORESEER"},{"text":"private function is_called_group(self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Source Code is_called_group Source Code function is_called_group ( self , group ) result ( called ) !< Check if a CLAs group has been run. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. called = . false . if ( self % is_defined_group ( group = group , g = g )) called = self % clasg ( g )% is_called endfunction is_called_group","tags":"","loc":"proc/is_called_group.html","title":"is_called_group – FORESEER"},{"text":"private function is_defined(self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Source Code is_defined Source Code function is_defined ( self , switch , group ) !< Check if a CLA has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLAs. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. is_defined = . false . if (. not . present ( group )) then is_defined = self % clasg ( 0 )% is_defined ( switch = switch ) else if ( self % is_defined_group ( group = group , g = g )) is_defined = self % clasg ( g )% is_defined ( switch = switch ) endif endfunction is_defined","tags":"","loc":"proc/is_defined.html","title":"is_defined – FORESEER"},{"text":"private function is_defined_group(self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Source Code is_defined_group Source Code function is_defined_group ( self , group , g ) result ( defined ) !< Check if a CLAs group has been defined. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( out ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. defined = . false . do gg = 0 , size ( self % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( self % clasg ( gg )% group )) defined = ( self % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg endfunction is_defined_group","tags":"","loc":"proc/is_defined_group.html","title":"is_defined_group – FORESEER"},{"text":"private elemental function is_parsed(self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. Source Code is_parsed Source Code elemental function is_parsed ( self ) !< Check if CLI has been parsed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical :: is_parsed !< Parsed status. is_parsed = self % is_parsed_ endfunction is_parsed","tags":"","loc":"proc/is_parsed.html","title":"is_parsed – FORESEER"},{"text":"private function is_passed(self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Source Code is_passed Source Code function is_passed ( self , group , switch , position ) !< Check if a CLA has been passed. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. is_passed = . false . if (. not . present ( group )) then if ( present ( switch )) then is_passed = self % clasg ( 0 )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( 0 )% is_passed ( position = position ) endif else if ( self % is_defined_group ( group = group , g = g )) then if ( present ( switch )) then is_passed = self % clasg ( g )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( g )% is_passed ( position = position ) endif endif endif endfunction is_passed","tags":"","loc":"proc/is_passed.html","title":"is_passed – FORESEER"},{"text":"private function signature(self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value character(len=:),\n  allocatable Signature. Source Code signature Source Code function signature ( self ) !< Get signature. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: g !< Counter. signature = self % clasg ( 0 )% signature () if ( size ( self % clasg , dim = 1 ) > 1 ) then signature = signature // ' {' // self % clasg ( 1 )% group do g = 2 , size ( self % clasg , dim = 1 ) - 1 signature = signature // ',' // self % clasg ( g )% group enddo signature = signature // '} ...' endif endfunction signature","tags":"","loc":"proc/signature.html","title":"signature – FORESEER"},{"text":"private function usage(self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),\n  allocatable Usage string. Source Code usage Source Code function usage ( self , g , pref , no_header , no_examples , no_epilog , markdown ) result ( usaged ) !< Print correct usage of CLI. class ( command_line_interface ), intent ( in ) :: self !< CLI data. integer ( I4P ), intent ( in ) :: g !< Group index. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( in ) :: no_epilog !< Avoid insert epilogue to usage. logical , optional , intent ( in ) :: markdown !< Format things with markdown character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. logical :: markdownd !< Format for markdown. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = self % clasg ( g )% usage ( pref = prefd , no_header = no_headerd , markdown = markdownd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // self % help // self % progname // ' ' // self % signature () if ( self % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description endif if ( self % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // self % clasg ( 0 )% usage ( pref = prefd , no_header = . true ., markdown = markdownd ) if ( size ( self % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // self % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % progname // ' ' // self % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( self % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( self % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( self % examples ( e )) enddo endif if ( self % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // self % epilog endfunction usage","tags":"","loc":"proc/usage.html","title":"usage – FORESEER"},{"text":"private subroutine add(self, pref, group, group_index, switch, switch_ab, help, help_markdown, help_color, help_style, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. Note If CLA belongs to a not yet present group it is created on the fly. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. character(len=*), intent(in), optional :: help_markdown Longer help message, markdown formatted. character(len=*), intent(in), optional :: help_color ANSI color of help messages. character(len=*), intent(in), optional :: help_style ANSI style of help messages. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~add~3~~CallsGraph proc~add~3 add proc~upper_case upper_case proc~add~3->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code subroutine add ( self , pref , group , group_index , switch , switch_ab , help , help_markdown , help_color , help_style , & required , positional , position , hidden , act , def , nargs , choices , exclude , envvar , error ) !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( in ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( in ) :: help !< Help message describing the CLA. character ( * ), optional , intent ( in ) :: help_color !< ANSI color of help messages. character ( * ), optional , intent ( in ) :: help_style !< ANSI style of help messages. character ( * ), optional , intent ( in ) :: help_markdown !< Longer help message, markdown formatted. logical , optional , intent ( in ) :: required !< Flag for set required argument. logical , optional , intent ( in ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical , optional , intent ( in ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( in ) :: act !< CLA value action. character ( * ), optional , intent ( in ) :: def !< Default value. character ( * ), optional , intent ( in ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( in ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( in ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( in ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. type ( command_line_argument ) :: cla !< CLA data. integer ( I4P ) :: g !< Counter. ! initialize CLA call cla % assign_object ( self ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % help_color = '' ; if ( present ( help_color )) cla % help_color = help_color cla % help_style = '' ; if ( present ( help_style )) cla % help_style = help_style cla % help_markdown = '' ; if ( present ( help_markdown )) cla % help_markdown = help_markdown cla % is_required = . false . ; if ( present ( required )) cla % is_required = required cla % is_positional = . false . ; if ( present ( positional )) cla % is_positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % is_hidden = . false . ; if ( present ( hidden )) cla % is_hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar call cla % check ( pref = pref ) ; self % error = cla % error if ( self % error /= 0 ) then if ( present ( error )) error = self % error return endif ! add CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call self % clasg ( 0 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( 0 )% error elseif ( present ( group )) then if ( self % is_defined_group ( group = group , g = g )) then call self % clasg ( g )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( g )% error else call self % add_group ( group = group ) call self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( self % clasg , dim = 1 ) - 1 ) then call self % clasg ( group_index )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( group_index )% error endif endif if ( present ( error )) error = self % error endsubroutine add","tags":"","loc":"proc/add~3.html","title":"add – FORESEER"},{"text":"private subroutine add_group(self, help, description, exclude, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Source Code add_group Source Code subroutine add_group ( self , help , description , exclude , group ) !< Add CLAs group to CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: help !< Help message. character ( * ), optional , intent ( in ) :: description !< Detailed description. character ( * ), optional , intent ( in ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( in ) :: group !< Name of the grouped CLAs. type ( command_line_arguments_group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index if (. not . self % is_defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( self % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = self%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = self % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( self ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( self % clasg ) allocate ( self % clasg ( 0 : Ng )) self % clasg = clasg_list_new deallocate ( clasg_list_new ) endif endsubroutine add_group","tags":"","loc":"proc/add_group.html","title":"add_group – FORESEER"},{"text":"private subroutine check(self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code check Source Code subroutine check ( self , pref , error ) !< Check data consistency. class ( command_line_interface ), intent ( INOUT ) :: self !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 0 , size ( self % clasg , dim = 1 ) - 1 ! check group consistency call self % clasg ( g )% check ( pref = pref ) self % error = self % clasg ( g )% error if ( present ( error )) error = self % error if ( self % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( self % clasg ( g )% m_exclude /= '' ) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) self % clasg ( gg )% m_exclude = self % clasg ( g )% group endif endif enddo endsubroutine check","tags":"","loc":"proc/check.html","title":"check – FORESEER"},{"text":"private subroutine check_m_exclusive(self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_m_exclusive Source Code subroutine check_m_exclusive ( self , pref ) !< Check if two mutually exclusive CLAs group have been called. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. do g = 1 , size ( self % clasg , dim = 1 ) - 1 if ( self % clasg ( g )% is_called . and .( self % clasg ( g )% m_exclude /= '' )) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) then if ( self % clasg ( gg )% is_called ) then call self % clasg ( g )% raise_error_m_exclude ( pref = pref ) self % error = self % clasg ( g )% error exit endif endif endif enddo endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive.html","title":"check_m_exclusive – FORESEER"},{"text":"private elemental subroutine cli_assign_cli(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. Source Code cli_assign_cli Source Code elemental subroutine cli_assign_cli ( lhs , rhs ) !< Assignment operator. class ( command_line_interface ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_interface ), intent ( in ) :: rhs !< Right hand side. ! object members call lhs % assign_object ( rhs ) ! command_line_interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv endsubroutine cli_assign_cli","tags":"","loc":"proc/cli_assign_cli.html","title":"cli_assign_cli – FORESEER"},{"text":"private subroutine errored(self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. Calls proc~~errored~~CallsGraph proc~errored errored proc~colorize colorize proc~errored->proc~colorize proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code errored Source Code subroutine errored ( self , error , pref , group , switch ) !< Trig error occurrence and print meaningful message. class ( command_line_interface ), intent ( inout ) :: self !< Object data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Group name. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_MISSING_CLA ) self % error_message = prefd // ': there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( ERROR_MISSING_SELECTION_CLA ) self % error_message = prefd // ': to get an option value one of switch \"name\" or \"position\" must be provided!' case ( ERROR_MISSING_GROUP ) self % error_message = prefd // ': ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( ERROR_TOO_FEW_CLAS ) ! self%error_message = prefd//': too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,self%Na_required))//')' endselect write ( self % error_lun , '(A)' ) call self % print_error_message endif endsubroutine errored","tags":"","loc":"proc/errored.html","title":"errored – FORESEER"},{"text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. Source Code finalize Source Code elemental subroutine finalize ( self ) !< Free dynamic memory when finalizing. type ( command_line_interface ), intent ( inout ) :: self !< CLI data. call self % free endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FORESEER"},{"text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. Source Code free Source Code elemental subroutine free ( self ) !< Free dynamic memory. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ) :: g !< Counter. ! object members call self % free_object ! command_line_interface members if ( allocated ( self % clasg )) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 call self % clasg ( g )% free enddo deallocate ( self % clasg ) endif if ( allocated ( self % args )) deallocate ( self % args ) if ( allocated ( self % examples )) deallocate ( self % examples ) self % disable_hv = . false . self % is_parsed_ = . false . endsubroutine free","tags":"","loc":"proc/free.html","title":"free – FORESEER"},{"text":"private subroutine get_args_from_invocation(self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Source Code get_args_from_invocation Source Code subroutine get_args_from_invocation ( self , ai ) !< Get CLAs from CLI invocation. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. if ( allocated ( self % args )) deallocate ( self % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: self % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) self % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call self % get_clasg_indexes ( ai = ai ) endsubroutine get_args_from_invocation","tags":"","loc":"proc/get_args_from_invocation.html","title":"get_args_from_invocation – FORESEER"},{"text":"private subroutine get_args_from_string(self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Calls proc~~get_args_from_string~~CallsGraph proc~get_args_from_string get_args_from_string proc~tokenize tokenize proc~get_args_from_string->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_args_from_string Source Code subroutine get_args_from_string ( self , args , ai ) !< Get CLAs from string. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif ! prepare CLI arguments list if ( allocated ( self % args )) deallocate ( self % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate CLI arguments list #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: self % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 self % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call self % get_clasg_indexes ( ai = ai ) contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. character ( * ), intent ( in ) :: argsin !< Arguments string. character ( * ), intent ( in ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) endfunction sanitize_args endsubroutine get_args_from_string","tags":"","loc":"proc/get_args_from_string.html","title":"get_args_from_string – FORESEER"},{"text":"private subroutine get_cla(self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla Source Code subroutine get_cla ( self , val , pref , args , group , switch , position , error ) !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( self % error == 0 ) then if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( position )% error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif endif if ( self % error == 0. and .(. not . self % clasg ( g )% is_called )) then ! TODO warn (if liked) for non invoked group querying endif if ( present ( error )) error = self % error endsubroutine get_cla","tags":"","loc":"proc/get_cla.html","title":"get_cla – FORESEER"},{"text":"private subroutine get_cla_list(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list Source Code subroutine get_cla_list ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list.html","title":"get_cla_list – FORESEER"},{"text":"private subroutine get_cla_list_varying_I1P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I1P Source Code subroutine get_cla_list_varying_I1P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p.html","title":"get_cla_list_varying_I1P – FORESEER"},{"text":"private subroutine get_cla_list_varying_I2P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I2P Source Code subroutine get_cla_list_varying_I2P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p.html","title":"get_cla_list_varying_I2P – FORESEER"},{"text":"private subroutine get_cla_list_varying_I4P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I4P Source Code subroutine get_cla_list_varying_I4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p.html","title":"get_cla_list_varying_I4P – FORESEER"},{"text":"private subroutine get_cla_list_varying_I8P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I8P Source Code subroutine get_cla_list_varying_I8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p.html","title":"get_cla_list_varying_I8P – FORESEER"},{"text":"private subroutine get_cla_list_varying_R16P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_R16P Source Code subroutine get_cla_list_varying_R16P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p.html","title":"get_cla_list_varying_R16P – FORESEER"},{"text":"private subroutine get_cla_list_varying_R4P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_R4P Source Code subroutine get_cla_list_varying_R4P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p.html","title":"get_cla_list_varying_R4P – FORESEER"},{"text":"private subroutine get_cla_list_varying_R8P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_R8P Source Code subroutine get_cla_list_varying_R8P ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p.html","title":"get_cla_list_varying_R8P – FORESEER"},{"text":"private subroutine get_cla_list_varying_char(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_char Source Code subroutine get_cla_list_varying_char ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char.html","title":"get_cla_list_varying_char – FORESEER"},{"text":"private subroutine get_cla_list_varying_logical(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_logical Source Code subroutine get_cla_list_varying_logical ( self , val , pref , args , group , switch , position , error ) !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical.html","title":"get_cla_list_varying_logical – FORESEER"},{"text":"private subroutine get_clasg_indexes(self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Source Code get_clasg_indexes Source Code subroutine get_clasg_indexes ( self , ai ) !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. allocate ( ai ( 0 : size ( self % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( self % args )) then Na = size ( self % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( self % is_defined_group ( group = trim ( self % args ( a )), g = g )) then found = . true . self % clasg ( g )% is_called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( self % is_defined_group ( group = trim ( self % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 self % clasg ( 0 )% is_called = . true . elseif ( all ( ai == 0 )) then self % clasg ( 0 )% is_called = . true . endif else self % clasg ( 0 )% is_called = . true . endif endsubroutine get_clasg_indexes","tags":"","loc":"proc/get_clasg_indexes.html","title":"get_clasg_indexes – FORESEER"},{"text":"private subroutine init(self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun, error_color, error_style) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help. integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info. integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info. character(len=*), intent(in), optional :: error_color ANSI color of error messages. character(len=*), intent(in), optional :: error_style ANSI style of error messages. Source Code init Source Code subroutine init ( self , progname , version , help , description , license , authors , examples , epilog , disable_hv , & usage_lun , error_lun , version_lun , error_color , error_style ) !< Initialize CLI. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: progname !< Program name. character ( * ), optional , intent ( in ) :: version !< Program version. character ( * ), optional , intent ( in ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( in ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( in ) :: license !< License description. character ( * ), optional , intent ( in ) :: authors !< Authors list. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( in ) :: epilog !< Epilog message. logical , optional , intent ( in ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. integer ( I4P ), optional , intent ( in ) :: usage_lun !< Unit number to print usage/help. integer ( I4P ), optional , intent ( in ) :: version_lun !< Unit number to print version/license info. integer ( I4P ), optional , intent ( in ) :: error_lun !< Unit number to print error info. character ( * ), optional , intent ( in ) :: error_color !< ANSI color of error messages. character ( * ), optional , intent ( in ) :: error_style !< ANSI style of error messages. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. call self % free if ( present ( progname )) then self % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then self % progname = prog_invocation else self % progname = 'program' endif endif self % version = 'unknown' ; if ( present ( version )) self % version = version self % help = 'usage: ' ; if ( present ( help )) self % help = help self % description = '' ; if ( present ( description )) self % description = description self % license = '' ; if ( present ( license )) self % license = license self % authors = '' ; if ( present ( authors )) self % authors = authors if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( self % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: self % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif self % examples = examples endif self % epilog = '' ; if ( present ( epilog )) self % epilog = epilog if ( present ( disable_hv )) self % disable_hv = disable_hv ! default set by self%free if ( present ( usage_lun )) self % usage_lun = usage_lun ! default set by self%free if ( present ( version_lun )) self % version_lun = version_lun ! default set by self%free if ( present ( error_lun )) self % error_lun = error_lun ! default set by self%free self % error_color = '' ; if ( present ( error_color )) self % error_color = error_color self % error_style = '' ; if ( present ( error_style )) self % error_style = error_style ! initialize only the first default group allocate ( self % clasg ( 0 : 0 )) call self % clasg ( 0 )% assign_object ( self ) self % clasg ( 0 )% group = '' endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FORESEER"},{"text":"private subroutine parse(self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Note The leading and trailing white spaces are removed from CLA values. Note If the args argument is passed the command line arguments are taken from it and not from the actual program CLI\n invocations. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code parse Source Code subroutine parse ( self , pref , args , error ) !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. if ( present ( error )) error = 0 if ( self % is_parsed_ ) return ! add help and version switches if not done by user if (. not . self % disable_hv ) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--help' ). and .& self % is_defined ( group = self % clasg ( g )% group , switch = '-h' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--version' ). and . & self % is_defined ( group = self % clasg ( g )% group , switch = '-v' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not . self % is_defined ( group = self % clasg ( g )% group , switch = '--' )) & call self % add ( pref = pref , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parse passed CLAs grouping in indexes if ( present ( args )) then call self % get_args ( args = args , ai = ai ) else call self % get_args ( ai = ai ) endif ! check CLI consistency call self % check ( pref = pref ) if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! parse CLI do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) then call self % clasg ( g )% parse ( args = self % args ( ai ( g , 1 ): ai ( g , 2 )), pref = pref ) else call self % clasg ( g )% sanitize_defaults endif self % error = self % clasg ( g )% error if ( self % error /= 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! trap the special cases of version/help printing if ( self % error == STATUS_PRINT_V ) then call self % print_version ( pref = pref ) stop elseif ( self % error == STATUS_PRINT_H ) then write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = g ) stop endif ! check if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call self % clasg ( g )% is_required_passed ( pref = pref ) self % error = self % clasg ( g )% error if ( self % error > 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! check mutually exclusive interaction call self % check_m_exclusive ( pref = pref ) self % is_parsed_ = . true . if ( present ( error )) error = self % error endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse – FORESEER"},{"text":"private subroutine print_usage(self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code print_usage Source Code subroutine print_usage ( self , pref ) !< Print correct usage. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = 0 ) endsubroutine print_usage","tags":"","loc":"proc/print_usage.html","title":"print_usage – FORESEER"},{"text":"private subroutine save_man_page(self, man_file, error) Save man page build on the CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~save_man_page~~CallsGraph proc~save_man_page save_man_page interface~strz strz proc~save_man_page->interface~strz proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_man_page Source Code subroutine save_man_page ( self , man_file , error ) !< Save man page build on the CLI. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. call date_and_time ( values = idate ) man = '.TH ' // self % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // self % version // & '\" \"' // self % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // self % progname // ' - manual page for ' // self % progname // ' version ' // self % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // self % progname // new_line ( 'a' ) // trim ( adjustl ( self % signature ())) if ( self % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( self % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( self % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // self % authors if ( self % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // self % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) endsubroutine save_man_page","tags":"","loc":"proc/save_man_page.html","title":"save_man_page – FORESEER"},{"text":"private subroutine save_usage_to_markdown(self, markdown_file, error) Save the CLI as a markdown page, for inclusion into the documentation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code save_usage_to_markdown Source Code subroutine save_usage_to_markdown ( self , markdown_file , error ) !< Save the CLI as a markdown page, for inclusion into the documentation. class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: markdown_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. ! add the other tags here. man = '' ! add the short description if ( self % description /= '' ) man = man // new_line ( 'a' ) // '### Short description' // new_line ( 'a' ) // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // new_line ( 'a' ) // '### Command line options:' man = man // new_line ( 'a' ) // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 , markdown = . true .) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '### Examples' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) man = man // new_line ( 'a' ) // '`' // trim ( self % examples ( e )) // '` ' enddo endif open ( newunit = u , file = trim ( adjustl ( markdown_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) endsubroutine save_usage_to_markdown","tags":"","loc":"proc/save_usage_to_markdown.html","title":"save_usage_to_markdown – FORESEER"},{"text":"private subroutine set_mutually_exclusive_groups(self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Source Code set_mutually_exclusive_groups Source Code subroutine set_mutually_exclusive_groups ( self , group1 , group2 ) !< Set two CLAs group ad mutually exclusive. class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( in ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. if ( self % is_defined_group ( group = group1 , g = g1 ). and . self % is_defined_group ( group = group2 , g = g2 )) then self % clasg ( g1 )% m_exclude = group2 self % clasg ( g2 )% m_exclude = group1 endif endsubroutine set_mutually_exclusive_groups","tags":"","loc":"proc/set_mutually_exclusive_groups.html","title":"set_mutually_exclusive_groups – FORESEER"},{"text":"private function is_defined(self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Source Code is_defined Source Code function is_defined ( self , switch , pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( out ) :: pos !< CLA position. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_defined = . false . if ( present ( pos )) pos = 0 if ( self % Na > 0 ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined","tags":"","loc":"proc/is_defined~2.html","title":"is_defined – FORESEER"},{"text":"private pure function is_passed(self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Source Code is_passed Source Code pure function is_passed ( self , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_passed = . false . if ( self % Na > 0 ) then if ( present ( switch )) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_passed = self % cla ( a )% is_passed exit endif endif enddo elseif ( present ( position )) then is_passed = self % cla ( position )% is_passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_passed","tags":"","loc":"proc/is_passed~2.html","title":"is_passed – FORESEER"},{"text":"private function signature(self) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. Return Value character(len=:),\n  allocatable Signature. Source Code signature Source Code function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAsG signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signature = '' do a = 1 , self % Na signature = signature // self % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature~2.html","title":"signature – FORESEER"},{"text":"private function usage(self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),\n  allocatable Usage string. Source Code usage Source Code function usage ( self , pref , no_header , markdown ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAsG usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: markdown !< Format things form markdown. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: markdownd !< Markdonw format, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref usage = self % progname ; if ( self % group /= '' ) usage = self % progname // ' ' // self % group usage = prefd // self % help // ' ' // usage // self % signature () if ( self % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( self % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , self % Na if ( self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif if ( self % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , self % Na if (. not . self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage~2.html","title":"usage – FORESEER"},{"text":"private subroutine add(self, pref, cla) Add CLA to CLAs list. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. Source Code add Source Code subroutine add ( self , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. type ( command_line_argument ), intent ( in ) :: cla !< CLA data. type ( command_line_argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % Na > 0_I4P ) then if (. not . cla % is_positional ) then allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , self % Na cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( self % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , self % Na + 1 cla_list_new ( c ) = self % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = self % cla ) self % Na = self % Na + 1 if ( cla % is_required ) then self % Na_required = self % Na_required + 1 else self % Na_optional = self % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) call self % check ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add","tags":"","loc":"proc/add~4.html","title":"add – FORESEER"},{"text":"private subroutine check(self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check Source Code subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! verify if CLAs switches are unique CLA_unique : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then do aa = 1 , self % Na if (( a /= aa ). and .(. not . self % cla ( aa )% is_positional )) then if (( self % cla ( a )% switch == self % cla ( aa )% switch ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch ). or .& ( self % cla ( a )% switch == self % cla ( aa )% switch_ab ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch_ab )) then call self % errored ( pref = pref , error = ERROR_CONSISTENCY , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! update mutually exclusive relations CLA_exclude : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_defined ( switch = self % cla ( a )% m_exclude , pos = aa )) then self % cla ( aa )% m_exclude = self % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check~2.html","title":"check – FORESEER"},{"text":"private subroutine check_m_exclusive(self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_m_exclusive Source Code subroutine check_m_exclusive ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if ( self % cla ( a )% is_passed ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_passed ( switch = self % cla ( a )% m_exclude )) then call self % cla ( a )% raise_error_m_exclude ( pref = pref ) self % error = self % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive~2.html","title":"check_m_exclusive – FORESEER"},{"text":"private elemental subroutine clasg_assign_clasg(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. Source Code clasg_assign_clasg Source Code elemental subroutine clasg_assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( INOUT ) :: lhs !< Left hand side. type ( command_line_arguments_group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_arguments_group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % is_called = rhs % is_called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine clasg_assign_clasg","tags":"","loc":"proc/clasg_assign_clasg.html","title":"clasg_assign_clasg – FORESEER"},{"text":"private subroutine errored(self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. Calls proc~~errored~2~~CallsGraph proc~errored~2 errored interface~str str proc~errored~2->interface~str proc~colorize colorize proc~errored~2->proc~colorize proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code errored Source Code subroutine errored ( self , error , pref , a1 , a2 ) !< Trig error occurrence and print meaningful message. class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( in ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( in ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_CONSISTENCY ) if ( self % group /= '' ) then self % error_message = prefd // ': group (command) name: \"' // self % group // '\" consistency error:' else self % error_message = prefd // ': consistency error:' endif self % error_message = self % error_message // ' \"' // trim ( str ( a1 , . true .)) // & '-th\" option has the same switch or abbreviated switch of \"' // & trim ( str ( a2 , . true .)) // '-th\" option:' // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a1 , . true .)) // ') switches = ' // self % cla ( a1 )% switch // ' ' // & self % cla ( a1 )% switch_ab // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a2 , . true .)) // ') switches = ' // self % cla ( a2 )% switch // ' ' // & self % cla ( a2 )% switch_ab case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the group \"' // self % group // '\" and \"' // self % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect call self % print_error_message endif endsubroutine errored","tags":"","loc":"proc/errored~2.html","title":"errored – FORESEER"},{"text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. Source Code finalize Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – FORESEER"},{"text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. Source Code free Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_arguments_group members if ( allocated ( self % group )) deallocate ( self % group ) if ( allocated ( self % cla )) then call self % cla % free deallocate ( self % cla ) endif self % Na = 0_I4P self % Na_required = 0_I4P self % Na_optional = 0_I4P self % is_called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~2.html","title":"free – FORESEER"},{"text":"private subroutine is_required_passed(self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code is_required_passed Source Code subroutine is_required_passed ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_required_passed ( pref = pref )) then self % error = self % cla ( a )% error write ( self % usage_lun , '(A)' ) self % usage ( pref = pref ) return endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine is_required_passed","tags":"","loc":"proc/is_required_passed.html","title":"is_required_passed – FORESEER"},{"text":"private subroutine parse(self, args, pref) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in) :: args (:) Command line arguments. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~parse~2~~CallsGraph proc~parse~2 parse interface~cton cton proc~parse~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parse Source Code subroutine parse ( self , args , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAsG arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), intent ( in ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , self % Na ! loop over CLAs group clas named options if (. not . self % cla ( a )% is_positional ) then if ( trim ( adjustl ( self % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( self % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then found_val = . false . if ( self % cla ( a )% act == action_store ) then if ( allocated ( self % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = self % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then self % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( self % cla ( a )% def )) then self % cla ( a )% val = self % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( self % cla ( a )% nargs )) then self % cla ( a )% val = '' select case ( self % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( self % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) enddo found_val = . true . arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call self % cla ( a )% raise_error_value_missing ( pref = pref ) self % error = self % cla ( a )% error return endif arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( self % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! flush default to val if default is set if ( allocated ( self % cla ( a )% def )) self % cla ( a )% val = self % cla ( a )% def endif elseif ( self % cla ( a )% act == action_print_help ) then self % error = STATUS_PRINT_H elseif ( self % cla ( a )% act == action_print_vers ) then self % error = STATUS_PRINT_V endif self % cla ( a )% is_passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . self % cla ( arg )% is_positional ) then ! current argument (arg-th) is not positional... there is a problem! call self % cla ( arg )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error return else ! positional CLA always stores a value self % cla ( arg )% val = trim ( adjustl ( args ( arg ))) self % cla ( arg )% is_passed = . true . endif endif enddo call self % check_m_exclusive ( pref = pref ) call self % sanitize_defaults endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse~2.html","title":"parse – FORESEER"},{"text":"private subroutine raise_error_m_exclude(self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_m_exclude Source Code subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude","tags":"","loc":"proc/raise_error_m_exclude.html","title":"raise_error_m_exclude – FORESEER"},{"text":"private subroutine sanitize_defaults(self) Sanitize defaults values. It is necessary to sanitize the default values of non-passed, optional CLAs. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. Source Code sanitize_defaults Source Code subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na call self % cla ( a )% sanitize_defaults enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults","tags":"","loc":"proc/sanitize_defaults.html","title":"sanitize_defaults – FORESEER"},{"text":"private elemental function count_substring(string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Called By proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code count_substring Source Code elemental function count_substring ( string , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string )) return c1 = 1 do c2 = index ( string = string ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring","tags":"","loc":"proc/count_substring.html","title":"count_substring – FORESEER"},{"text":"public pure function replace(string, substring, restring) result(newstring) Replace substring (only first occurrence) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. Called By proc~~replace~~CalledByGraph proc~replace replace proc~replace_all replace_all proc~replace_all->proc~replace proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~replace_all proc~usage~3 usage proc~usage~3->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code replace Source Code pure function replace ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (only first occurrence) into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. integer ( I4P ) :: pos !< Position from which replace the substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos = index ( string = string , substring = substring ) newstring = string if ( pos > 0 ) then if ( pos == 1 ) then newstring = restring // string ( len ( substring ) + 1 :) else newstring = string ( 1 : pos - 1 ) // restring // string ( pos + len ( substring ):) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace – FORESEER"},{"text":"public pure function replace_all(string, substring, restring) result(newstring) Replace substring (all occurrences) into a string. Note Leading and trailing white spaces are stripped out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. Calls proc~~replace_all~~CallsGraph proc~replace_all replace_all proc~wstrip wstrip proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~replace_all~~CalledByGraph proc~replace_all replace_all proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~replace_all proc~usage~3 usage proc~usage~3->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code replace_all Source Code pure function replace_all ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (all occurrences) into a string. !< !< @note Leading and trailing white spaces are stripped out. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- newstring = wstrip ( string ) do if ( index ( newstring , substring ) > 0 ) then newstring = replace ( string = newstring , substring = substring , restring = restring ) else exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_all","tags":"","loc":"proc/replace_all.html","title":"replace_all – FORESEER"},{"text":"public elemental function unique(string, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be parsed. character(len=*), intent(in) :: substring Substring which multiple occurences must be reduced to one. Return Value character(len=len(string)) String parsed. Called By proc~~unique~~CalledByGraph proc~unique unique proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~unique Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code unique Source Code elemental function unique ( string , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be parsed. character ( len =* ), intent ( in ) :: substring !< Substring which multiple occurences must be reduced to one. character ( len = len ( string )) :: uniq !< String parsed. integer ( I4P ) :: Lsub !< Lenght of substring. integer ( I4P ) :: c1 !< Counter. integer ( I4P ) :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- uniq = string Lsub = len ( substring ) if ( Lsub > len ( string )) return c1 = 1 Loop1 : do if ( c1 >= len_trim ( uniq )) exit Loop1 if ( uniq ( c1 : c1 + Lsub - 1 ) == substring . and . uniq ( c1 + Lsub : c1 + 2 * Lsub - 1 ) == substring ) then c2 = c1 + Lsub Loop2 : do if ( c2 >= len_trim ( uniq )) exit Loop2 if ( uniq ( c2 : c2 + Lsub - 1 ) == substring ) then c2 = c2 + Lsub else exit Loop2 endif enddo Loop2 uniq = uniq ( 1 : c1 ) // uniq ( c2 :) else c1 = c1 + Lsub endif enddo Loop1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique – FORESEER"},{"text":"public elemental function upper_case(string) Convert the lower case characters of a string to upper case one. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Called By proc~~upper_case~~CalledByGraph proc~upper_case upper_case proc~add~3 add proc~add~3->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code upper_case Source Code elemental function upper_case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be converted. character ( len = len ( string )) :: upper_case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- upper_case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) upper_case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper_case","tags":"","loc":"proc/upper_case.html","title":"upper_case – FORESEER"},{"text":"public pure function wstrip(string) result(newstring) Strip out leading and trailing white spaces from a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. Return Value character(len=:),\n  allocatable New modified string. Called By proc~~wstrip~~CalledByGraph proc~wstrip wstrip proc~sanitize_defaults~2 sanitize_defaults proc~sanitize_defaults~2->proc~wstrip proc~replace_all replace_all proc~sanitize_defaults~2->proc~replace_all proc~replace_all->proc~wstrip proc~usage~3 usage proc~usage~3->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code wstrip Source Code pure function wstrip ( string ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Strip out leading and trailing white spaces from a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( newstring , source = trim ( adjustl ( string ))) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction wstrip","tags":"","loc":"proc/wstrip.html","title":"wstrip – FORESEER"},{"text":"public pure subroutine tokenize(strin, delimiter, toks, Nt) Tokenize a string in order to parse it. Note The dummy array containing tokens must allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to input string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Called By proc~~tokenize~~CalledByGraph proc~tokenize tokenize proc~get_cla_list~2 get_cla_list proc~get_cla_list~2->proc~tokenize proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->proc~tokenize proc~check_choices check_choices proc~check_choices->proc~tokenize proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->proc~tokenize proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->proc~tokenize proc~get_cla_list_varying_logical~2 get_cla_list_varying_logical proc~get_cla_list_varying_logical~2->proc~tokenize proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->proc~tokenize proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->proc~tokenize proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->proc~tokenize proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->proc~tokenize proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->proc~tokenize proc~get_cla_list_varying_char~2 get_cla_list_varying_char proc~get_cla_list_varying_char~2->proc~tokenize proc~get_args_from_string get_args_from_string proc~get_args_from_string->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tokenize Source Code pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to input string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: strin !< String to be tokenized. character ( len =* ), intent ( in ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( out ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( out ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = strin ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize.html","title":"tokenize – FORESEER"},{"text":"public interface count Overload intrinsic function count for counting substring occurences into strings. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures count_substring Module Procedures private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences.","tags":"","loc":"interface/count.html","title":"count – FORESEER"},{"text":"private function check_list_size(self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Source Code check_list_size Source Code function check_list_size ( self , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: Nv !< Number of values. character ( * ), intent ( in ) :: val !< First value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size","tags":"","loc":"proc/check_list_size.html","title":"check_list_size – FORESEER"},{"text":"private function is_required_passed(self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Source Code is_required_passed Source Code function is_required_passed ( self , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLA is passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if (((. not . self % is_passed ). and . self % is_required ). or .((. not . self % is_passed ). and .(. not . allocated ( self % def )))) then call self % errored ( pref = pref , error = ERROR_MISSING_REQUIRED ) is_ok = . false . endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_required_passed","tags":"","loc":"proc/is_required_passed~2.html","title":"is_required_passed – FORESEER"},{"text":"private function signature(self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value character(len=:),\n  allocatable Signature. Calls proc~~signature~3~~CallsGraph proc~signature~3 signature interface~str str proc~signature~3->interface~str interface~cton cton proc~signature~3->interface~cton proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code signature Source Code function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( in ) :: self !< CLA data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then select case ( self % nargs ) case ( '+' ) signature = ' value#1 [value#2 value#3...]' case ( '*' ) signature = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) signature = '' do a = 1 , nargs signature = signature // ' value#' // trim ( str ( a , . true .)) enddo endselect else signature = ' value' endif if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) // signature else signature = ' [' // trim ( adjustl ( self % switch )) // signature // ']' endif else if ( self % is_required ) then signature = ' value' else signature = ' [value]' endif endif elseif ( self % act == action_store_star ) then signature = ' [value]' else if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) else signature = ' [' // trim ( adjustl ( self % switch )) // ']' endif endif else signature = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature~3.html","title":"signature – FORESEER"},{"text":"private function usage(self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),\n  allocatable Usage string. Calls proc~~usage~3~~CallsGraph proc~usage~3 usage interface~str str proc~usage~3->interface~str proc~replace_all replace_all proc~usage~3->proc~replace_all proc~colorize colorize proc~usage~3->proc~colorize interface~cton cton proc~usage~3->interface~cton proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~wstrip wstrip proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code usage Source Code function usage ( self , pref , markdown ) !< Get correct usage. class ( command_line_argument ), intent ( in ) :: self !< CLAs group data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: markdown !< Format for markdown character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: switch_ !< Switch name, local variable. character ( len = :), allocatable :: switch_ab_ !< Abbreviated switch name, local variable. integer ( I4P ) :: a !< Counter. logical :: markdownd !< Format for markdown integer :: indent !< how many spaces to indent markdownd = . false . ; if ( present ( markdown )) markdownd = markdown indent = 4 switch_ = colorize ( trim ( adjustl ( self % switch )), color_fg = self % help_color , style = self % help_style ) switch_ab_ = colorize ( trim ( adjustl ( self % switch_ab )), color_fg = self % help_color , style = self % help_style ) if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then usage = '' select case ( self % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str ( a , . true .)) enddo endselect if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`, `' // trim ( adjustl ( self % switch_ab )) // usage // '`' else usage = '   ' // switch_ // usage // ', ' // switch_ab_ // usage endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`' else usage = '   ' // switch_ // usage endif endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`, `' // trim ( adjustl ( self % switch_ab )) // ' value' // '`' else usage = '   ' // switch_ // ' value, ' // switch_ab_ // ' value' endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`' else usage = '   ' // switch_ // ' value' endif endif endif else usage = '  value' endif if ( allocated ( self % choices )) then usage = usage // ', value in: `' // self % choices // '`' endif elseif ( self % act == action_store_star ) then usage = '  [value]' if ( allocated ( self % choices )) then usage = usage // ', value in: (' // self % choices // ')' endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`, `' // trim ( adjustl ( self % switch_ab )) // '`' else usage = '   ' // switch_ // ', ' // switch_ab_ endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`' else usage = '   ' // switch_ endif endif endif prefd = '' ; if ( present ( pref )) prefd = pref usage = prefd // usage if ( self % is_positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( str ( self % position , . true .)) // & '-th argument' if ( allocated ( self % envvar )) then if ( self % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( self % envvar )) // '\"' endif endif if (. not . self % is_required ) then if ( self % def /= '' ) then if ( markdownd ) then ! two spaces make a line break in markdown. usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) endif endif endif if ( self % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'mutually exclude \"' // self % m_exclude // '\"' if ( markdownd ) then usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // trim ( adjustl ( self % help )) if ( self % help_markdown /= '' ) then usage = usage // trim ( adjustl ( self % help_markdown )) endif else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( adjustl ( self % help )) endif else usage = '' endif endfunction usage","tags":"","loc":"proc/usage~3.html","title":"usage – FORESEER"},{"text":"private subroutine check(self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check Source Code subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % check_envvar_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_action_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_optional_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_m_exclude_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_named_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_positional_consistency ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check~3.html","title":"check – FORESEER"},{"text":"private subroutine check_action_consistency(self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_action_consistency Source Code subroutine check_action_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA action consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % act )) then if ( self % act == ACTION_STORE_STAR . and . self % is_positional ) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_POSITIONAL ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_NARGS ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % envvar )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_ENVVAR ) return endif if ( self % act /= ACTION_STORE . and . & self % act /= ACTION_STORE_STAR . and . & self % act /= ACTION_STORE_TRUE . and . & self % act /= ACTION_STORE_FALSE . and .& self % act /= ACTION_PRINT_HELP . and . & self % act /= ACTION_PRINT_VERS ) then call self % errored ( pref = pref , error = ERROR_ACTION_UNKNOWN ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_action_consistency","tags":"","loc":"proc/check_action_consistency.html","title":"check_action_consistency – FORESEER"},{"text":"private subroutine check_choices(self, val, pref) Check if CLA value is in allowed choices. Note This procedure can be called if and only if cla%choices has been allocated. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~check_choices~~CallsGraph proc~check_choices check_choices interface~str str proc~check_choices->interface~str proc~tokenize tokenize proc~check_choices->proc~tokenize interface~cton cton proc~check_choices->interface~cton proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_choices Source Code subroutine check_choices ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( in ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len ( self % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = self % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) call self % errored ( pref = pref , error = ERROR_CHOICES_LOGICAL ) endselect if (. not . val_in . and .( self % error == 0 )) then call self % errored ( pref = pref , error = ERROR_NOT_IN_CHOICES , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices","tags":"","loc":"proc/check_choices.html","title":"check_choices – FORESEER"},{"text":"private subroutine check_envvar_consistency(self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_envvar_consistency Source Code subroutine check_envvar_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency for envvar CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % envvar )) then if ( self % is_positional ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_POSITIONAL ) return endif if (. not . allocated ( self % act )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return else if ( self % act /= action_store ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return endif endif if ( allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NARGS ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_envvar_consistency","tags":"","loc":"proc/check_envvar_consistency.html","title":"check_envvar_consistency – FORESEER"},{"text":"private subroutine check_m_exclude_consistency(self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_m_exclude_consistency Source Code subroutine check_m_exclude_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check mutually exclusion consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_required ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_REQUIRED_M_EXCLUDE ) return endif if (( self % is_positional ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_M_EXCLUDE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclude_consistency","tags":"","loc":"proc/check_m_exclude_consistency.html","title":"check_m_exclude_consistency – FORESEER"},{"text":"private subroutine check_named_consistency(self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_named_consistency Source Code subroutine check_named_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check named CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_positional ). and .(. not . allocated ( self % switch ))) call self % errored ( pref = pref , error = ERROR_NAMED_NO_NAME ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_named_consistency","tags":"","loc":"proc/check_named_consistency.html","title":"check_named_consistency – FORESEER"},{"text":"private subroutine check_optional_consistency(self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_optional_consistency Source Code subroutine check_optional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check optional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_required ). and .(. not . allocated ( self % def ))) call self % errored ( pref = pref , error = ERROR_OPTIONAL_NO_DEF ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_optional_consistency","tags":"","loc":"proc/check_optional_consistency.html","title":"check_optional_consistency – FORESEER"},{"text":"private subroutine check_positional_consistency(self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_positional_consistency Source Code subroutine check_positional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check positional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_positional ). and .( self % position == 0_I4P )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_POSITION ) return elseif (( self % is_positional ). and .( self % act /= action_store )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_STORE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_positional_consistency","tags":"","loc":"proc/check_positional_consistency.html","title":"check_positional_consistency – FORESEER"},{"text":"private elemental subroutine cla_assign_cla(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. Source Code cla_assign_cla Source Code elemental subroutine cla_assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_argument ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % is_required = rhs % is_required lhs % is_positional = rhs % is_positional lhs % position = rhs % position lhs % is_passed = rhs % is_passed lhs % is_hidden = rhs % is_hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine cla_assign_cla","tags":"","loc":"proc/cla_assign_cla.html","title":"cla_assign_cla – FORESEER"},{"text":"private subroutine errored(self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. Calls proc~~errored~3~~CallsGraph proc~errored~3 errored interface~str str proc~errored~3->interface~str proc~colorize colorize proc~errored~3->proc~colorize proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~style_index style_index proc~colorize->proc~style_index proc~color_index color_index proc~colorize->proc~color_index proc~upper upper proc~colorize->proc~upper proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code errored Source Code subroutine errored ( self , error , pref , switch , val_str , log_value ) !< Trig error occurence and print meaningful message. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: val_str !< Value string. character ( * ), optional , intent ( in ) :: log_value !< Logical value to be casted. character ( len = :), allocatable :: prefd !< Prefixing string. self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref prefd = prefd // self % progname // ': ' // colorize ( 'error' , color_fg = self % error_color , style = self % error_style ) select case ( self % error ) case ( ERROR_OPTIONAL_NO_DEF ) if ( self % is_positional ) then self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // '-th\" positional option has not a default value!' else self % error_message = prefd // ': named option \"' // self % switch // '\" has not a default value!' endif case ( ERROR_REQUIRED_M_EXCLUDE ) self % error_message = prefd // ': named option \"' // self % switch // '\" cannot exclude others' // & ', it being required, only optional ones can!' case ( ERROR_POSITIONAL_M_EXCLUDE ) self % error_message = prefd // ': \"' // trim ( str ( n = self % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( ERROR_NAMED_NO_NAME ) self % error_message = prefd // ': a non positional optiona must have a switch name!' case ( ERROR_POSITIONAL_NO_POSITION ) self % error_message = prefd // ': a positional option must have a position number different from 0!' case ( ERROR_POSITIONAL_NO_STORE ) self % error_message = prefd // ': a positional option must have action set to \"' // action_store // '\"!' case ( ERROR_M_EXCLUDE ) self % error_message = prefd // ': the options \"' // self % switch // '\" and \"' // self % m_exclude // & '\" are mutually exclusive, but both have been passed!' case ( ERROR_NOT_IN_CHOICES ) if ( self % is_positional ) then self % error_message = prefd // ': value of \"' // trim ( str ( n = self % position )) // & '-th\" positional option must be chosen in:' else self % error_message = prefd // ': value of named option \"' // self % switch // '\" must be chosen in: ' endif self % error_message = self % error_message // '(' // self % choices // ')' self % error_message = self % error_message // ' but \"' // trim ( val_str ) // '\" has been passed!' case ( ERROR_MISSING_REQUIRED ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" is required!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option is required!' endif case ( ERROR_CASTING_LOGICAL ) self % error_message = prefd // ': cannot convert \"' // log_value // '\" of option \"' // self % switch // '\" to logical type!' case ( ERROR_CHOICES_LOGICAL ) self % error_message = prefd // ': cannot use \"choices\" value check for option \"' // self % switch // & '\" it being of logical type! The choices are limited to \".true.\" or \".false.\" by definition!' case ( ERROR_NO_LIST ) if (. not . self % is_positional ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has not \"nargs\" value but an array has been passed to \"get\" method!' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( ERROR_NARGS_INSUFFICIENT ) if (. not . self % is_positional ) then if ( self % nargs == '+' ) then self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" requires at least 1 argument but no one remains!' else self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif else if ( self % nargs == '+' ) then self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires at least 1 argument but no one remains' else self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif endif case ( ERROR_VALUE_MISSING ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" needs a value that is not passed!' case ( ERROR_UNKNOWN ) self % error_message = prefd // ': switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( ERROR_ENVVAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( ERROR_ENVVAR_NOT_STORE ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( ERROR_ENVVAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( ERROR_STORE_STAR_POSITIONAL ) self % error_message = prefd // ': \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( ERROR_STORE_STAR_NARGS ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( ERROR_STORE_STAR_ENVVAR ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( ERROR_ACTION_UNKNOWN ) self % error_message = prefd // ': named option \"' // trim ( adjustl ( self % switch )) // '\" has unknown \"' // self % act // '\" action!' endselect call self % print_error_message endif endsubroutine errored","tags":"","loc":"proc/errored~3.html","title":"errored – FORESEER"},{"text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. Source Code finalize Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – FORESEER"},{"text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. Source Code free Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_argument members if ( allocated ( self % switch )) deallocate ( self % switch ) if ( allocated ( self % switch_ab )) deallocate ( self % switch_ab ) if ( allocated ( self % act )) deallocate ( self % act ) if ( allocated ( self % def )) deallocate ( self % def ) if ( allocated ( self % nargs )) deallocate ( self % nargs ) if ( allocated ( self % choices )) deallocate ( self % choices ) if ( allocated ( self % val )) deallocate ( self % val ) if ( allocated ( self % envvar )) deallocate ( self % envvar ) self % is_required = . false . self % is_positional = . false . self % position = 0_I4P self % is_passed = . false . self % is_hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~3.html","title":"free – FORESEER"},{"text":"private subroutine get_cla(self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Source Code get_cla Source Code subroutine get_cla ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if ( self % act == action_store . or . self % act == action_store_star ) then if ( self % is_passed . and . allocated ( self % val )) then call self % get_cla_from_buffer ( buffer = self % val , val = val , pref = pref ) elseif ( allocated ( self % def )) then ! using default value call self % get_cla_from_buffer ( buffer = self % def , val = val , pref = pref ) endif if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val , pref = pref ) elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla","tags":"","loc":"proc/get_cla~2.html","title":"get_cla – FORESEER"},{"text":"private subroutine get_cla_from_buffer(self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_from_buffer~~CallsGraph proc~get_cla_from_buffer get_cla_from_buffer interface~cton cton proc~get_cla_from_buffer->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_from_buffer Source Code subroutine get_cla_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from parsed value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I1P ) type is ( logical ) read ( buffer , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = buffer ) type is ( character ( * )) val = buffer endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_from_buffer","tags":"","loc":"proc/get_cla_from_buffer.html","title":"get_cla_from_buffer – FORESEER"},{"text":"private subroutine get_cla_list(self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Calls proc~~get_cla_list~2~~CallsGraph proc~get_cla_list~2 get_cla_list proc~tokenize tokenize proc~get_cla_list~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list Source Code subroutine get_cla_list ( self , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call self % get_cla_list_from_buffer ( buffer = self % val , val = val , pref = pref ) else ! using default value call self % get_cla_list_from_buffer ( buffer = self % def , val = val , pref = pref ) endif elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list~2.html","title":"get_cla_list – FORESEER"},{"text":"private subroutine get_cla_list_from_buffer(self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_from_buffer~~CallsGraph proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~tokenize tokenize proc~get_cla_list_from_buffer->proc~tokenize interface~cton cton proc~get_cla_list_from_buffer->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_from_buffer Source Code subroutine get_cla_list_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from a buffer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val ( 1 :) !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( buffer )), allocatable :: vals (:) !< String array of values based on buffer value. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = buffer , delimiter = args_sep , toks = vals , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R16P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I2P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I1P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( vals ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = vals ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = vals ( v ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_from_buffer","tags":"","loc":"proc/get_cla_list_from_buffer.html","title":"get_cla_list_from_buffer – FORESEER"},{"text":"private subroutine get_cla_list_varying_I1P(self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i1p~2~~CallsGraph proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~tokenize tokenize proc~get_cla_list_varying_i1p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_i1p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I1P Source Code subroutine get_cla_list_varying_I1P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p~2.html","title":"get_cla_list_varying_I1P – FORESEER"},{"text":"private subroutine get_cla_list_varying_I2P(self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i2p~2~~CallsGraph proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~tokenize tokenize proc~get_cla_list_varying_i2p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_i2p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I2P Source Code subroutine get_cla_list_varying_I2P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p~2.html","title":"get_cla_list_varying_I2P – FORESEER"},{"text":"private subroutine get_cla_list_varying_I4P(self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i4p~2~~CallsGraph proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~tokenize tokenize proc~get_cla_list_varying_i4p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_i4p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I4P Source Code subroutine get_cla_list_varying_I4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( INOUT ) :: self !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p~2.html","title":"get_cla_list_varying_I4P – FORESEER"},{"text":"private subroutine get_cla_list_varying_I8P(self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i8p~2~~CallsGraph proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~tokenize tokenize proc~get_cla_list_varying_i8p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_i8p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I8P Source Code subroutine get_cla_list_varying_I8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p~2.html","title":"get_cla_list_varying_I8P – FORESEER"},{"text":"private subroutine get_cla_list_varying_R16P(self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r16p~2~~CallsGraph proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~tokenize tokenize proc~get_cla_list_varying_r16p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_r16p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_R16P Source Code subroutine get_cla_list_varying_R16P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p~2.html","title":"get_cla_list_varying_R16P – FORESEER"},{"text":"private subroutine get_cla_list_varying_R4P(self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r4p~2~~CallsGraph proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~tokenize tokenize proc~get_cla_list_varying_r4p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_r4p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_R4P Source Code subroutine get_cla_list_varying_R4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p~2.html","title":"get_cla_list_varying_R4P – FORESEER"},{"text":"private subroutine get_cla_list_varying_R8P(self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r8p~2~~CallsGraph proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~tokenize tokenize proc~get_cla_list_varying_r8p~2->proc~tokenize interface~cton cton proc~get_cla_list_varying_r8p~2->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_R8P Source Code subroutine get_cla_list_varying_R8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p~2.html","title":"get_cla_list_varying_R8P – FORESEER"},{"text":"private subroutine get_cla_list_varying_char(self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_char~2~~CallsGraph proc~get_cla_list_varying_char~2 get_cla_list_varying_char proc~tokenize tokenize proc~get_cla_list_varying_char~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_char Source Code subroutine get_cla_list_varying_char ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char~2.html","title":"get_cla_list_varying_char – FORESEER"},{"text":"private subroutine get_cla_list_varying_logical(self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_logical~2~~CallsGraph proc~get_cla_list_varying_logical~2 get_cla_list_varying_logical proc~tokenize tokenize proc~get_cla_list_varying_logical~2->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_logical Source Code subroutine get_cla_list_varying_logical ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical~2.html","title":"get_cla_list_varying_logical – FORESEER"},{"text":"private subroutine raise_error_m_exclude(self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_m_exclude Source Code subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude","tags":"","loc":"proc/raise_error_m_exclude~2.html","title":"raise_error_m_exclude – FORESEER"},{"text":"private subroutine raise_error_nargs_insufficient(self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_nargs_insufficient Source Code subroutine raise_error_nargs_insufficient ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error insufficient number of argument values passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_nargs_insufficient","tags":"","loc":"proc/raise_error_nargs_insufficient.html","title":"raise_error_nargs_insufficient – FORESEER"},{"text":"private subroutine raise_error_switch_unknown(self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_switch_unknown Source Code subroutine raise_error_switch_unknown ( self , switch , pref ) !< Raise error switch_unknown. class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. call self % errored ( pref = pref , error = ERROR_UNKNOWN , switch = switch ) endsubroutine raise_error_switch_unknown","tags":"","loc":"proc/raise_error_switch_unknown.html","title":"raise_error_switch_unknown – FORESEER"},{"text":"private subroutine raise_error_value_missing(self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_value_missing Source Code subroutine raise_error_value_missing ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error missing value. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_VALUE_MISSING ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_value_missing","tags":"","loc":"proc/raise_error_value_missing.html","title":"raise_error_value_missing – FORESEER"},{"text":"private subroutine sanitize_defaults(self) Sanitize defaults values. It is necessary to sanitize the default values of non-passed, optional CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. Calls proc~~sanitize_defaults~2~~CallsGraph proc~sanitize_defaults~2 sanitize_defaults proc~wstrip wstrip proc~sanitize_defaults~2->proc~wstrip proc~unique unique proc~sanitize_defaults~2->proc~unique proc~replace_all replace_all proc~sanitize_defaults~2->proc~replace_all proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sanitize_defaults Source Code subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_passed ) then if ( allocated ( self % def )) then ! strip leading and trailing white spaces self % def = wstrip ( self % def ) if ( allocated ( self % nargs )) then ! replace white space separator with FLAP ARGS_SEP self % def = unique ( string = self % def , substring = ' ' ) self % def = replace_all ( string = self % def , substring = ' ' , restring = ARGS_SEP ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults","tags":"","loc":"proc/sanitize_defaults~2.html","title":"sanitize_defaults – FORESEER"},{"text":"private elemental subroutine assign_object(lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. Source Code assign_object Source Code elemental subroutine assign_object ( lhs , rhs ) !< Assign two abstract objects. class ( object ), intent ( inout ) :: lhs !< Left hand side. class ( object ), intent ( in ) :: rhs !< Rigth hand side. if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % help_color )) lhs % help_color = rhs % help_color if ( allocated ( rhs % help_style )) lhs % help_style = rhs % help_style if ( allocated ( rhs % help_markdown )) lhs % help_markdown = rhs % help_markdown if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude if ( allocated ( rhs % error_message )) lhs % error_message = rhs % error_message if ( allocated ( rhs % error_color )) lhs % error_color = rhs % error_color if ( allocated ( rhs % error_style )) lhs % error_style = rhs % error_style lhs % error = rhs % error lhs % usage_lun = rhs % usage_lun lhs % version_lun = rhs % version_lun lhs % error_lun = rhs % error_lun endsubroutine assign_object","tags":"","loc":"proc/assign_object.html","title":"assign_object – FORESEER"},{"text":"private elemental subroutine free_object(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. Source Code free_object Source Code elemental subroutine free_object ( self ) !< Free dynamic memory. class ( object ), intent ( inout ) :: self !< Object data. if ( allocated ( self % progname )) deallocate ( self % progname ) if ( allocated ( self % version )) deallocate ( self % version ) if ( allocated ( self % help )) deallocate ( self % help ) if ( allocated ( self % help_color )) deallocate ( self % help_color ) if ( allocated ( self % help_style )) deallocate ( self % help_style ) if ( allocated ( self % help_markdown )) deallocate ( self % help_markdown ) if ( allocated ( self % description )) deallocate ( self % description ) if ( allocated ( self % license )) deallocate ( self % license ) if ( allocated ( self % authors )) deallocate ( self % authors ) if ( allocated ( self % epilog )) deallocate ( self % epilog ) if ( allocated ( self % m_exclude )) deallocate ( self % m_exclude ) if ( allocated ( self % error_message )) deallocate ( self % error_message ) if ( allocated ( self % error_color )) deallocate ( self % error_color ) if ( allocated ( self % error_style )) deallocate ( self % error_style ) self % error = 0_I4P self % usage_lun = stderr self % version_lun = stdout self % error_lun = stderr endsubroutine free_object","tags":"","loc":"proc/free_object.html","title":"free_object – FORESEER"},{"text":"private subroutine print_error_message(self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. Source Code print_error_message Source Code subroutine print_error_message ( self ) !< Print meaningful error message to standard-error. class ( object ), intent ( in ) :: self !< Object data. write ( self % error_lun , '(A)' ) self % error_message write ( self % error_lun , '(A)' ) endsubroutine print_error_message","tags":"","loc":"proc/print_error_message.html","title":"print_error_message – FORESEER"},{"text":"private subroutine print_version(self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code print_version Source Code subroutine print_version ( self , pref ) !< Print version. class ( object ), intent ( in ) :: self !< Object data. character ( * ), intent ( in ), optional :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. prefd = '' ; if ( present ( pref )) prefd = pref write ( self % version_lun , '(A)' ) prefd // self % progname // ' version ' // self % version if ( self % license /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % license endif if ( self % authors /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % authors endif endsubroutine print_version","tags":"","loc":"proc/print_version.html","title":"print_version – FORESEER"},{"text":"private elemental function is_supported(steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Calls proc~~is_supported~~CallsGraph proc~is_supported is_supported proc~is_admissible is_admissible proc~is_supported->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported.html","title":"is_supported – FORESEER"},{"text":"private pure function max_steps() Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Source Code max_steps Source Code pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps.html","title":"max_steps – FORESEER"},{"text":"private pure function min_steps() Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code min_steps Source Code pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps.html","title":"min_steps – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 1 if ( allocated ( self % a )) deallocate ( self % a ) self % b = 0.0_R_P self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, steps) Create the actual BDF integrator: initialize the alpha and beta coefficients. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Source Code init Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual BDF integrator: initialize the *alpha* and *beta* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( INOUT ) :: self !< BDF integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % a )) deallocate ( self % a ) ; allocate ( self % a ( 1 : steps )) ; self % a = 0.0_R_P select case ( steps ) case ( 1 ) self % a ( 1 ) = - 1.0_R_P self % b = 1.0_R_P case ( 2 ) self % a ( 1 ) = 1.0_R_P / 3.0_R_P self % a ( 2 ) = - 4.0_R_P / 3.0_R_P self % b = 2.0_R_P / 3.0_R_P case ( 3 ) self % a ( 1 ) = - 2.0_R_P / 1 1.0_R_P self % a ( 2 ) = 9.0_R_P / 1 1.0_R_P self % a ( 3 ) = - 1 8.0_R_P / 1 1.0_R_P self % b = 6.0_R_P / 1 1.0_R_P case ( 4 ) self % a ( 1 ) = 3.0_R_P / 2 5.0_R_P self % a ( 2 ) = - 1 6.0_R_P / 2 5.0_R_P self % a ( 3 ) = 3 6.0_R_P / 2 5.0_R_P self % a ( 4 ) = - 4 8.0_R_P / 2 5.0_R_P self % b = 1 2.0_R_P / 2 5.0_R_P case ( 5 ) self % a ( 1 ) = - 1 2.0_R_P / 13 7.0_R_P self % a ( 2 ) = 7 5.0_R_P / 13 7.0_R_P self % a ( 3 ) = - 20 0.0_R_P / 13 7.0_R_P self % a ( 4 ) = 30 0.0_R_P / 13 7.0_R_P self % a ( 5 ) = - 30 0.0_R_P / 13 7.0_R_P self % b = 6 0.0_R_P / 13 7.0_R_P case ( 6 ) self % a ( 1 ) = 1 0.0_R_P / 14 7.0_R_P self % a ( 2 ) = - 7 2.0_R_P / 14 7.0_R_P self % a ( 3 ) = 22 5.0_R_P / 14 7.0_R_P self % a ( 4 ) = - 40 0.0_R_P / 14 7.0_R_P self % a ( 5 ) = 45 0.0_R_P / 14 7.0_R_P self % a ( 6 ) = - 36 0.0_R_P / 14 7.0_R_P self % b = 6 0.0_R_P / 14 7.0_R_P case default ! bad (unsupported) number of required time steps self % error = 1 endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations, autoupdate) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Source Code integrate Source Code subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with BDF class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. integer ( I_P ) :: iterations_ !< Fixed point iterations. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate iterations_ = 1 ; if ( present ( iterations )) iterations_ = iterations allocate ( delta , source = previous ( self % steps ) * ( - self % a ( self % steps ))) do s = 1 , self % steps - 1 delta = delta + previous ( s ) * ( - self % a ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FORESEER"},{"text":"private subroutine update_previous(self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Source Code update_previous Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( back_df_integrator ), intent ( IN ) :: self !< Actual BDF integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous.html","title":"update_previous – FORESEER"},{"text":"private elemental function is_supported(stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Calls proc~~is_supported~2~~CallsGraph proc~is_supported~2 is_supported proc~is_admissible is_admissible proc~is_supported~2->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~2.html","title":"is_supported – FORESEER"},{"text":"private pure function max_stages() Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Source Code max_stages Source Code pure function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages","tags":"","loc":"proc/max_stages.html","title":"max_stages – FORESEER"},{"text":"private pure function min_stages() Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Source Code min_stages Source Code pure function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages","tags":"","loc":"proc/min_stages.html","title":"min_stages – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Source Code init Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – FORESEER"},{"text":"private elemental function is_supported(stages_steps) Check if the queried number of stages/steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. Return Value logical Is true is the stages number is in supported_stages_steps . Calls proc~~is_supported~3~~CallsGraph proc~is_supported~3 is_supported proc~is_admissible is_admissible proc~is_supported~3->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( stages_steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages/steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages_steps !< Number of stages/steps used. logical :: is_supported !< Is true is the stages number is in *supported_stages_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages_steps , adm_range = trim ( supported_stages_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~3.html","title":"is_supported – FORESEER"},{"text":"private pure function max_stages_steps() Return the maximum number of stages/steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages/steps supported. Source Code max_stages_steps Source Code pure function max_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages_steps !< Maximum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages_steps","tags":"","loc":"proc/max_stages_steps.html","title":"max_stages_steps – FORESEER"},{"text":"private pure function min_stages_steps() Return the minimum number of stages/steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages/steps supported. Source Code min_stages_steps Source Code pure function min_stages_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages_steps !< Minimum number of stages/steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages_steps","tags":"","loc":"proc/min_stages_steps.html","title":"min_stages_steps – FORESEER"},{"text":"private subroutine integrate(U, Dt, t) Integrate field with explicit Euler scheme, 1st order. Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. Source Code integrate Source Code subroutine integrate ( U , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), optional , intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = U + U % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – FORESEER"},{"text":"private elemental function is_supported(steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Calls proc~~is_supported~4~~CallsGraph proc~is_supported~4 is_supported proc~is_admissible is_admissible proc~is_supported~4->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~4.html","title":"is_supported – FORESEER"},{"text":"private pure function max_steps() Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Source Code max_steps Source Code pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~2.html","title":"max_steps – FORESEER"},{"text":"private pure function min_steps() Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code min_steps Source Code pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~2.html","title":"min_steps – FORESEER"},{"text":"private elemental subroutine init(self, nu, alpha) Create the actual leapfrog integrator: initialize the filter coefficient. Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Source Code init Source Code elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.53_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, previous, Dt, t, filter) Integrate field with leapfrog class scheme. Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement. Source Code integrate Source Code subroutine integrate ( self , U , previous , Dt , t , filter ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 : 2 ) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- U = previous ( 1 ) + previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( previous ( 1 ) - previous ( 2 ) * 2._R_P + U ) * self % nu * 0.5_R_P previous ( 2 ) = previous ( 2 ) + filter * self % alpha U = U + filter * ( self % alpha - 1._R_P ) endif previous ( 1 ) = previous ( 2 ) previous ( 2 ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – FORESEER"},{"text":"private elemental function is_supported(steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Calls proc~~is_supported~5~~CallsGraph proc~is_supported~5 is_supported proc~is_admissible is_admissible proc~is_supported~5->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~5.html","title":"is_supported – FORESEER"},{"text":"private pure function max_steps() Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Source Code max_steps Source Code pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~3.html","title":"max_steps – FORESEER"},{"text":"private pure function min_steps() Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code min_steps Source Code pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~3.html","title":"min_steps – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~6.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, steps) Create the actual Adams-Bashforth integrator: initialize the b coefficients. Note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and\n the integrator error status is updated consistently for external-provided errors handling. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Source Code init Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1.0_R_P case ( 2 ) self % b ( 1 ) = - 1.0_R_P / 2.0_R_P self % b ( 2 ) = 3.0_R_P / 2.0_R_P case ( 3 ) self % b ( 1 ) = 5.0_R_P / 1 2.0_R_P self % b ( 2 ) = - 1 6.0_R_P / 1 2.0_R_P self % b ( 3 ) = 2 3.0_R_P / 1 2.0_R_P case ( 4 ) self % b ( 1 ) = - 9.0_R_P / 2 4.0_R_P self % b ( 2 ) = 3 7.0_R_P / 2 4.0_R_P self % b ( 3 ) = - 5 9.0_R_P / 2 4.0_R_P self % b ( 4 ) = 5 5.0_R_P / 2 4.0_R_P case ( 5 ) self % b ( 1 ) = 25 1.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 127 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 261 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = - 277 4.0_R_P / 72 0.0_R_P self % b ( 5 ) = 190 1.0_R_P / 72 0.0_R_P case ( 6 ) self % b ( 1 ) = - 47 5.0_R_P / 144 0.0_R_P self % b ( 2 ) = 287 7.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 729 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 998 2.0_R_P / 144 0.0_R_P self % b ( 5 ) = - 792 3.0_R_P / 144 0.0_R_P self % b ( 6 ) = 427 7.0_R_P / 144 0.0_R_P case ( 7 ) self % b ( 1 ) = 1908 7.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 13447 2.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 40713 9.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 68825 6.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 70554 9.0_R_P / 6048 0.0_R_P self % b ( 6 ) = - 44728 8.0_R_P / 6048 0.0_R_P self % b ( 7 ) = 19872 1.0_R_P / 6048 0.0_R_P case ( 8 ) self % b ( 1 ) = - 3679 9.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 29576 7.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 104172 3.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 210224 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 266447 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 218387 7.0_R_P / 12096 0.0_R_P self % b ( 7 ) = - 115216 9.0_R_P / 12096 0.0_R_P self % b ( 8 ) = 43424 1.0_R_P / 12096 0.0_R_P case ( 9 ) self % b ( 1 ) = 107001 7.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 966410 6.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 3883348 6.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 9117264 2.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 13796848 0.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 13985526 2.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 9547678 6.0_R_P / 362880 0.0_R_P self % b ( 8 ) = - 4312520 6.0_R_P / 362880 0.0_R_P self % b ( 9 ) = 1409724 7.0_R_P / 362880 0.0_R_P case ( 10 ) self % b ( 1 ) = - 208275 3.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 2088481 1.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 9430732 0.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 25261822 4.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 44477216 2.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 53836383 8.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 45466177 6.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 26593268 0.0_R_P / 725760 0.0_R_P self % b ( 9 ) = - 10499518 9.0_R_P / 725760 0.0_R_P self % b ( 10 ) = 3027724 7.0_R_P / 725760 0.0_R_P case ( 11 ) self % b ( 1 ) = 13421126 5.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 147957434 8.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 741790445 1.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 2232963492 0.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 4485716843 4.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 6317620147 2.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 6371637895 8.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 4611302901 6.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 2359106380 5.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = - 827179512 4.0_R_P / 47900160 0.0_R_P self % b ( 11 ) = 213250956 7.0_R_P / 47900160 0.0_R_P case ( 12 ) self % b ( 1 ) = - 26274726 5.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 315864244 5.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 1741024827 1.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 5818910762 7.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 13136586729 0.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 21110357329 8.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 24774163937 4.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 21413935536 6.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 13557935675 7.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 6163322718 5.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = - 1943381016 3.0_R_P / 95800320 0.0_R_P self % b ( 12 ) = 452776639 9.0_R_P / 95800320 0.0_R_P case ( 13 ) self % b ( 1 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 916055108573 4.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 5506097466241 2.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 20232291373837 0.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 50714036972842 5.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 91588338715244 4.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 122644308612940 8.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 123358924494176 4.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 93288454605589 5.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 52492457990515 0.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 21469659100261 2.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = - 6149755279727 4.0_R_P / 261534873600 0.0_R_P self % b ( 13 ) = 1306440652362 7.0_R_P / 261534873600 0.0_R_P case ( 14 ) self % b ( 1 ) = - 138274192962 1.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 1938285359378 7.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 12617497268190 6.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 50558614119643 0.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 139330630715575 5.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 279386960287907 7.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 420455192553452 4.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 482567132348845 2.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 424676735330575 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 285442957179080 5.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 144531335168190 6.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 53724705251566 2.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = - 14097075067962 1.0_R_P / 523069747200 0.0_R_P self % b ( 14 ) = 2751155497687 5.0_R_P / 523069747200 0.0_R_P case ( 15 ) self % b ( 1 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 12259481390411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 85923647668423 1.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 372880725657747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 1120584975351517 9.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 2470450365560772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 4128021633628425 9.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 5324673866064691 2.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 5347102665994050 9.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 4182526993250772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 2529891033708142 9.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 1164363753057747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 396642167021548 1.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = - 96012286640411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 15 ) = 17323349859884 9.0_R_P / 3138418483200 0.0_R_P case ( 16 ) self % b ( 1 ) = - 1608812922937 5.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 25765027591582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 193444319689259 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 903857175273408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 2941791091125181 9.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 7072435158284348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 12993009410423733 1.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 18608754426359664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 21002058891232194 9.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 18746314011290289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 13196319194082858 1.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 7255811707225973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 3060737386052056 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 962209690951533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = - 216156767124884 9.0_R_P / 6276836966400 0.0_R_P self % b ( 16 ) = 36255512642707 3.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, previous, Dt, t, autoupdate) Integrate field with Adams-Bashforth class scheme. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Source Code integrate Source Code subroutine integrate ( self , U , previous , Dt , t , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate do s = 1 , self % steps U = U + previous ( s )% t ( t = t ( s )) * ( Dt * self % b ( s )) enddo if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~5.html","title":"integrate – FORESEER"},{"text":"private subroutine update_previous(self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Source Code update_previous Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps - 1 previous ( s ) = previous ( s + 1 ) enddo previous ( self % steps ) = U return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous~2.html","title":"update_previous – FORESEER"},{"text":"public elemental function is_admissible(n, adm_range) Check if the queried number n is admitted by the admissible range list adm_range . The admissible range list must be formatted as string containing admissible numbers; valid list are:\n+ adm_range = '1-5' => 1, 2, 3, 4, 5 are admissible numbers;\n+ adm_range = '1,3,5,10-12' => 1, 3, 5, 10, 11, 12 are admissible numbers;\n+ adm_range = '1-4,8,21-22' => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; You can mix any number of range ( min-max format) and/or single number ( , comma separated) entries. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: n Number queried. character(len=*), intent(in) :: adm_range Admissible range string. Return Value logical Is true is the number is in adm_range . Calls proc~~is_admissible~~CallsGraph proc~is_admissible is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~is_admissible~~CalledByGraph proc~is_admissible is_admissible proc~is_supported~5 is_supported proc~is_supported~5->proc~is_admissible proc~is_supported~9 is_supported proc~is_supported~9->proc~is_admissible proc~is_supported~2 is_supported proc~is_supported~2->proc~is_admissible proc~is_supported is_supported proc~is_supported->proc~is_admissible proc~is_supported~8 is_supported proc~is_supported~8->proc~is_admissible proc~is_supported~7 is_supported proc~is_supported~7->proc~is_admissible proc~is_supported~3 is_supported proc~is_supported~3->proc~is_admissible proc~is_supported~6 is_supported proc~is_supported~6->proc~is_admissible proc~is_supported~4 is_supported proc~is_supported~4->proc~is_admissible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_admissible Source Code elemental function is_admissible ( n , adm_range ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number *n* is admitted by the *admissible* range list *adm_range*. !< !< The admissible range list must be formatted as string containing admissible numbers; valid list are: !<+ `adm_range = '1-5'` => 1, 2, 3, 4, 5 are admissible numbers; !<+ `adm_range = '1,3,5,10-12'` => 1, 3, 5, 10, 11, 12 are admissible numbers; !<+ `adm_range = '1-4,8,21-22'` => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; !< !< You can mix any number of range (`min-max` format) and/or single number (`,` comma separated) entries. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: n !< Number queried. character ( * ), intent ( IN ) :: adm_range !< Admissible range string. logical :: is_admissible !< Is true is the number is in *adm_range*. character ( len ( adm_range )), allocatable :: tokens (:) !< Tokens for parsing *adm_range* string. character ( len ( adm_range )), allocatable :: subtokens (:) !< Tokens for parsing *adm_range* string. integer ( I_P ) :: t !< Counter. integer ( I_P ) :: n_parsed ( 1 : 2 ) !< Values parsed from *adm_range*.. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_admissible = . false . call tokenize ( string = adm_range , delimiter = ',' , toks = tokens ) search_me : do t = 1 , size ( tokens ) if ( index ( tokens ( t ), '-' ) > 0 ) then call tokenize ( string = tokens ( t ), delimiter = '-' , toks = subtokens ) read ( subtokens ( 1 ), * ) n_parsed ( 1 ) read ( subtokens ( 2 ), * ) n_parsed ( 2 ) is_admissible = ( n_parsed ( 1 ) <= n . and . n <= n_parsed ( 2 )) else read ( tokens ( t ), * ) n_parsed ( 1 ) is_admissible = ( n_parsed ( 1 ) == n ) endif if ( is_admissible ) exit search_me enddo search_me return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_admissible","tags":"","loc":"proc/is_admissible.html","title":"is_admissible – FORESEER"},{"text":"private pure subroutine tokenize(string, delimiter, toks, Nt) Tokenize a string in order to parse it. Note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to char(0). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(string)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I_P), intent(out), optional :: Nt Number of tokens. Called By proc~~tokenize~2~~CalledByGraph proc~tokenize~2 tokenize proc~is_admissible is_admissible proc~is_admissible->proc~tokenize~2 proc~is_supported~5 is_supported proc~is_supported~5->proc~is_admissible proc~is_supported~9 is_supported proc~is_supported~9->proc~is_admissible proc~is_supported~2 is_supported proc~is_supported~2->proc~is_admissible proc~is_supported is_supported proc~is_supported->proc~is_admissible proc~is_supported~8 is_supported proc~is_supported~8->proc~is_admissible proc~is_supported~7 is_supported proc~is_supported~7->proc~is_admissible proc~is_supported~3 is_supported proc~is_supported~3->proc~is_admissible proc~is_supported~6 is_supported proc~is_supported~6->proc~is_admissible proc~is_supported~4 is_supported proc~is_supported~4->proc~is_admissible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tokenize Source Code pure subroutine tokenize ( string , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: string !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( string )), allocatable , intent ( OUT ) :: toks (:) !< Tokens. integer ( I_P ), optional , intent ( OUT ) :: Nt !< Number of tokens. character ( len = len ( string )) :: strsub !< Temporary string. integer ( I_P ) :: dlen !< Delimiter length. integer ( I_P ) :: c !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize if ( allocated ( toks )) deallocate ( toks ) strsub = string dlen = len ( delimiter ) if ( dlen > len ( string )) then allocate ( toks ( 1 : 1 )) toks ( 1 ) = char ( 0 ) if ( present ( Nt )) Nt = 1 return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenize do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize~2.html","title":"tokenize – FORESEER"},{"text":"private elemental function is_supported(steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Calls proc~~is_supported~6~~CallsGraph proc~is_supported~6 is_supported proc~is_admissible is_admissible proc~is_supported~6->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~6.html","title":"is_supported – FORESEER"},{"text":"private pure function max_steps() Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Source Code max_steps Source Code pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~4.html","title":"max_steps – FORESEER"},{"text":"private pure function min_steps() Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code min_steps Source Code pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~4.html","title":"min_steps – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~7.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, steps) Create the actual Adams-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Source Code init Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 0 : steps )) ; self % b = 0.0_R_P select case ( steps ) case ( 0 ) ! AM(0) Bacward-Euler self % b ( 0 ) = 1.0_R_P case ( 1 ) self % b ( 0 ) = 1.0_R_P / 2.0_R_P self % b ( 1 ) = 1.0_R_P / 2.0_R_P case ( 2 ) self % b ( 0 ) = - 1.0_R_P / 1 2.0_R_P self % b ( 1 ) = 8.0_R_P / 1 2.0_R_P self % b ( 2 ) = 5.0_R_P / 1 2.0_R_P case ( 3 ) self % b ( 0 ) = 1.0_R_P / 2 4.0_R_P self % b ( 1 ) = - 5.0_R_P / 2 4.0_R_P self % b ( 2 ) = 1 9.0_R_P / 2 4.0_R_P self % b ( 3 ) = 9.0_R_P / 2 4.0_R_P case ( 4 ) self % b ( 0 ) = - 1 9.0_R_P / 72 0.0_R_P self % b ( 1 ) = 10 6.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 26 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 64 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = 25 1.0_R_P / 72 0.0_R_P case ( 5 ) self % b ( 0 ) = 2 7.0_R_P / 144 0.0_R_P self % b ( 1 ) = - 17 3.0_R_P / 144 0.0_R_P self % b ( 2 ) = 48 2.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 79 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 142 7.0_R_P / 144 0.0_R_P self % b ( 5 ) = 47 5.0_R_P / 144 0.0_R_P case ( 6 ) self % b ( 0 ) = - 86 3.0_R_P / 6048 0.0_R_P self % b ( 1 ) = 631 2.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 2021 1.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 3750 4.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 4646 1.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 6511 2.0_R_P / 6048 0.0_R_P self % b ( 6 ) = 1908 7.0_R_P / 6048 0.0_R_P case ( 7 ) self % b ( 0 ) = 137 5.0_R_P / 12096 0.0_R_P self % b ( 1 ) = - 1135 1.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 4149 9.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 8854 7.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 12313 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 12179 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 13984 9.0_R_P / 12096 0.0_R_P self % b ( 7 ) = 3679 9.0_R_P / 12096 0.0_R_P case ( 8 ) self % b ( 0 ) = - 3395 3.0_R_P / 362880 0.0_R_P self % b ( 1 ) = 31287 4.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 129121 4.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 314633 8.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 503312 0.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 559535 8.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 460459 4.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 446709 4.0_R_P / 362880 0.0_R_P self % b ( 8 ) = 107001 7.0_R_P / 362880 0.0_R_P case ( 9 ) self % b ( 0 ) = 5728 1.0_R_P / 725760 0.0_R_P self % b ( 1 ) = - 58343 5.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 268786 4.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 739403 2.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 1351008 2.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 1728364 6.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 1600232 0.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 1127130 4.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 944971 7.0_R_P / 725760 0.0_R_P self % b ( 9 ) = 208275 3.0_R_P / 725760 0.0_R_P case ( 10 ) self % b ( 0 ) = - 325043 3.0_R_P / 47900160 0.0_R_P self % b ( 1 ) = 3628487 6.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 18477619 5.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 56745098 4.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 117059704 2.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 171077452 8.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 182331156 6.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 144620508 0.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 89017554 9.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 65618565 2.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = 13421126 5.0_R_P / 47900160 0.0_R_P case ( 11 ) self % b ( 0 ) = 567526 5.0_R_P / 95800320 0.0_R_P self % b ( 1 ) = - 6892878 1.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 38470932 7.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 130597111 5.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 300773941 8.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 496316651 4.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 604352148 6.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 551946058 2.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 382882888 5.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 209249067 3.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 137479921 9.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = 26274726 5.0_R_P / 95800320 0.0_R_P case ( 12 ) self % b ( 0 ) = - 1369577909 3.0_R_P / 261534873600 0.0_R_P self % b ( 1 ) = 17984282256 6.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 109209699226 8.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 406332786317 0.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 1034471179498 5.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 1905818565279 6.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 2620434446515 2.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 2734587069843 6.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 2184753803989 5.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 1346577425651 0.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 661642095742 8.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 391755121698 6.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P case ( 13 ) self % b ( 0 ) = 2446657909 3.0_R_P / 523069747200 0.0_R_P self % b ( 1 ) = - 34545708639 5.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 226807881438 6.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 918163560513 4.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 2562025977783 5.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 5217791088266 1.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 8010102102918 0.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 9439333865389 2.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 8618022868956 3.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 6118868013128 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 3392899013361 8.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 1514123508411 0.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 815316796218 1.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = 138274192962 1.0_R_P / 523069747200 0.0_R_P case ( 14 ) self % b ( 0 ) = - 13228284012 7.0_R_P / 3138418483200 0.0_R_P self % b ( 1 ) = 199875923633 6.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 1411048096992 7.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 6175942669254 4.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 18750493659793 1.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 41855180460126 4.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 71031283419734 7.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 93460083349094 4.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 96360540082473 3.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 78191161807163 2.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 49954720375483 7.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 25172489460793 6.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 10288514895621 7.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 5077096753486 4.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P case ( 15 ) self % b ( 0 ) = 24020824582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 1 ) = - 386768936759 9.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 2921938428408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 13751571378931 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 45140310893348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 109635523540233 1.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 203934587954664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 296636573026569 9.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 341494172885289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 312945307199358 1.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 228516859834973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 132697866305806 9.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 61274454106533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 23099216372384 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 10514505875707 3.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = 1608812922937 5.0_R_P / 6276836966400 0.0_R_P endselect self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations, autoupdate) Integrate field with Adams-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. Source Code integrate Source Code subroutine integrate ( self , U , previous , Dt , t , iterations , autoupdate ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations. logical , optional , intent ( IN ) :: autoupdate !< Perform cyclic autoupdate of previous time steps. logical :: autoupdate_ !< Perform cyclic autoupdate of previous time steps, dummy var. class ( integrand ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- autoupdate_ = . true . ; if ( present ( autoupdate )) autoupdate_ = autoupdate if ( self % steps > 0 ) then if ( present ( iterations )) then ! perform fixed point iterations allocate ( delta , source = previous ( self % steps )) do s = 0 , self % steps - 1 delta = delta + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo do s = 1 , iterations U = delta + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) enddo else U = previous ( self % steps ) + U % t ( t = t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps )) do s = 0 , self % steps - 1 U = U + previous ( s + 1 )% t ( t = t ( s + 1 )) * ( Dt * self % b ( s )) enddo endif if ( autoupdate_ ) call self % update_previous ( U = U , previous = previous ) else U = U + U % t ( t = t ( 1 )) * ( Dt * self % b ( 0 )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~6.html","title":"integrate – FORESEER"},{"text":"private subroutine update_previous(self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. Source Code update_previous Source Code subroutine update_previous ( self , U , previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cyclic update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_moulton_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( IN ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 0 , self % steps - 2 previous ( s + 1 ) = previous ( s + 2 ) enddo previous ( self % steps ) = U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous","tags":"","loc":"proc/update_previous~3.html","title":"update_previous – FORESEER"},{"text":"private elemental function is_supported(stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Calls proc~~is_supported~7~~CallsGraph proc~is_supported~7 is_supported proc~is_admissible is_admissible proc~is_supported~7->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~7.html","title":"is_supported – FORESEER"},{"text":"private pure function max_stages() Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Source Code max_stages Source Code pure function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages","tags":"","loc":"proc/max_stages~2.html","title":"max_stages – FORESEER"},{"text":"private pure function min_stages() Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Source Code min_stages Source Code pure function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages","tags":"","loc":"proc/min_stages~2.html","title":"min_stages – FORESEER"},{"text":"private pure function used_registers() Return the number of registers used. Arguments None Return Value integer(kind=I_P) Number of registers used. Source Code used_registers Source Code pure function used_registers () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: used_registers !< Number of registers used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- used_registers = registers return !--------------------------------------------------------------------------------------------------------------------------------- endfunction used_registers","tags":"","loc":"proc/used_registers.html","title":"used_registers – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~8.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, stages) Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Source Code init Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 6 ) ! LSRK(6,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 7 ) ! LSRK(7,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 12 ) ! LSRK(12,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 13 ) ! LSRK(13,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 14 ) ! LSRK(14,4) self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Integrate field with explicit low storage Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:registers) Runge-Kutta registers. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : registers ) !< Runge-Kutta registers. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = U stage ( 2 ) = U * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo U = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~7.html","title":"integrate – FORESEER"},{"text":"private elemental function is_supported(stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . Calls proc~~is_supported~8~~CallsGraph proc~is_supported~8 is_supported proc~is_admissible is_admissible proc~is_supported~8->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of stages is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. logical :: is_supported !< Is true is the stages number is in *supported_stages*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = stages , adm_range = trim ( supported_stages )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~8.html","title":"is_supported – FORESEER"},{"text":"private pure function max_stages() Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. Source Code max_stages Source Code pure function max_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_stages !< Maximum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_stages = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_stages","tags":"","loc":"proc/max_stages~3.html","title":"max_stages – FORESEER"},{"text":"private pure function min_stages() Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Source Code min_stages Source Code pure function min_stages () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_stages !< Minimum number of stages supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_stages = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_stages","tags":"","loc":"proc/min_stages~3.html","title":"min_stages – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % tolerance = 0._R_P self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~9.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, stages, tolerance) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). Source Code init Source Code elemental subroutine init ( self , stages , tolerance ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. real ( R_P ), optional , intent ( IN ) :: tolerance !< Tolerance on the local truncation error (default 0.01). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( stages )) then if ( present ( tolerance )) then self % tolerance = tolerance else self % tolerance = 0.01_R_P endif self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages , 1 : 2 )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 2 ) ! do not use, seems to not work! ! HERK(2,2) self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 6 ) ! CKRK(6,5) self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 7 ) ! DPRK(7,4) self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 9 ) ! CMRK(9,6) self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 17 ) ! FRK(17,10) self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect self % error = 0 else ! bad (unsupported) number of required stages self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, stage, Dt, t) Integrate field with explicit embedded Runge-Kutta scheme. The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: U1 !< First U evaluation. class ( integrand ), allocatable :: U2 !< Second U evaluation. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( U1 , source = U ) allocate ( U2 , source = U ) error = 1 e6 do while ( error > self % tolerance ) ! compute stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! compute new time step U1 = U U2 = U do s = 1 , self % stages U1 = U1 + stage ( s ) * ( Dt * self % beta ( s , 1 )) U2 = U2 + stage ( s ) * ( Dt * self % beta ( s , 2 )) enddo error = U2 . lterror . U1 call self % new_Dt ( error = error , Dt = Dt ) enddo U = U1 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~8.html","title":"integrate – FORESEER"},{"text":"private elemental subroutine new_Dt(self, error, Dt) Compute new estimation of the time step Dt. The formula employed is:  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  Note 0.9 is a safety factor. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Source Code new_Dt Source Code elemental subroutine new_Dt ( self , error , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. !--------------------------------------------------------------------------------------------------------------------------------- class ( emd_runge_kutta_integrator ), intent ( IN ) :: self !< Integrator. real ( R_P ), intent ( IN ) :: error !< Local truncation error estimation. real ( R_P ), intent ( INOUT ) :: Dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine new_Dt","tags":"","loc":"proc/new_dt.html","title":"new_Dt – FORESEER"},{"text":"private elemental function is_supported(steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . Calls proc~~is_supported~9~~CallsGraph proc~is_supported~9 is_supported proc~is_admissible is_admissible proc~is_supported~9->proc~is_admissible proc~tokenize~2 tokenize proc~is_admissible->proc~tokenize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_supported Source Code elemental function is_supported ( steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if the queried number of steps is supported or not. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. logical :: is_supported !< Is true is the steps number is in *supported_steps*. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_supported = is_admissible ( n = steps , adm_range = trim ( supported_steps )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_supported","tags":"","loc":"proc/is_supported~9.html","title":"is_supported – FORESEER"},{"text":"private pure function max_steps() Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. Source Code max_steps Source Code pure function max_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: max_steps !< Maximum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- max_steps = max_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction max_steps","tags":"","loc":"proc/max_steps~5.html","title":"max_steps – FORESEER"},{"text":"private pure function min_steps() Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Source Code min_steps Source Code pure function min_steps () !--------------------------------------------------------------------------------------------------------------------------------- !< Return the minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: min_steps !< Minimum number of steps supported. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- min_steps = min_ss return !--------------------------------------------------------------------------------------------------------------------------------- endfunction min_steps","tags":"","loc":"proc/min_steps~5.html","title":"min_steps – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = - 1 call self % predictor % destroy call self % corrector % destroy self % error = 0 return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~10.html","title":"destroy – FORESEER"},{"text":"private elemental subroutine init(self, steps) Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Source Code init Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( INOUT ) :: self !< ABM integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_supported ( steps )) then self % steps = steps call self % predictor % init ( steps = steps ) call self % corrector % init ( steps = steps - 1 ) self % error = 0 else ! bad (unsupported) number of required time steps self % error = 1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~9.html","title":"init – FORESEER"},{"text":"private subroutine integrate(self, U, previous, Dt, t, iterations) Integrate field with Adams-Bashforth-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme. Source Code integrate Source Code subroutine integrate ( self , U , previous , Dt , t , iterations ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth-Moulton class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_moulton_integrator ), intent ( IN ) :: self !< Actual ABM integrator. class ( integrand ), intent ( INOUT ) :: U !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: previous ( 1 :) !< Previous time steps solutions of integrand field. real ( R_P ), intent ( IN ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ), optional , intent ( IN ) :: iterations !< Fixed point iterations of AM scheme. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % predictor % integrate ( U = U , previous = previous , Dt = Dt , t = t , autoupdate = . false .) call self % corrector % integrate ( U = U , previous = previous ( 2 :), Dt = Dt , t = t , iterations = iterations , autoupdate = . false .) call self % predictor % update_previous ( U = U , previous = previous ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~9.html","title":"integrate – FORESEER"},{"text":"private elemental function bit_size_R16P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Source Code bit_size_R16P Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – FORESEER"},{"text":"private elemental function bit_size_R4P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size bit_size interface~bit_size->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R4P Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – FORESEER"},{"text":"private elemental function bit_size_R8P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size bit_size interface~bit_size->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R8P Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – FORESEER"},{"text":"private elemental function bit_size_chr(i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size bit_size interface~bit_size->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_chr Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – FORESEER"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I1P Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – FORESEER"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I2P Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – FORESEER"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I4P Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – FORESEER"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I8P Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – FORESEER"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Source Code byte_size_R16P Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – FORESEER"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R4P Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – FORESEER"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R8P Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – FORESEER"},{"text":"private elemental function byte_size_chr(i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_chr Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – FORESEER"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~~CallsGraph interface~bit_size bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size->proc~bit_size_r8p proc~bit_size_chr bit_size_chr interface~bit_size->proc~bit_size_chr proc~bit_size_r4p bit_size_R4P interface~bit_size->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bit_size_R8P bit_size_R4P bit_size_chr Module Procedures private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c.","tags":"","loc":"interface/bit_size.html","title":"bit_size – FORESEER"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R8P byte_size_R4P byte_size_chr Module Procedures private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"interface/byte_size.html","title":"byte_size – FORESEER"},{"text":"private elemental function digit_I1(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I1 Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – FORESEER"},{"text":"private elemental function digit_I2(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I2 Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – FORESEER"},{"text":"private elemental function digit_I4(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I4 Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – FORESEER"},{"text":"private elemental function digit_I8(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I8 Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – FORESEER"},{"text":"public subroutine check_endian() Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Arguments None Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_endian Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – FORESEER"},{"text":"public subroutine penf_init() Initialize PENF's variables that are not initialized into the definition specification. Arguments None Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_init Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – FORESEER"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code penf_print Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – FORESEER"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – FORESEER"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 Module Procedures private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits.","tags":"","loc":"interface/digit.html","title":"digit – FORESEER"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I1P Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – FORESEER"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I2P Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – FORESEER"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I4P Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – FORESEER"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I8P Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – FORESEER"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R16P Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – FORESEER"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R4P Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – FORESEER"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R8P Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – FORESEER"},{"text":"private elemental function bstr_I1P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I1P Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – FORESEER"},{"text":"private elemental function bstr_I2P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I2P Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – FORESEER"},{"text":"private elemental function bstr_I4P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I4P Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – FORESEER"},{"text":"private elemental function bstr_I8P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I8P Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – FORESEER"},{"text":"private elemental function bstr_R16P(n) result(bstr) Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Source Code bstr_R16P Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – FORESEER"},{"text":"private elemental function bstr_R4P(n) result(bstr) Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R4P Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – FORESEER"},{"text":"private elemental function bstr_R8P(n) result(bstr) Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R8P Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – FORESEER"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I1P Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – FORESEER"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I2P Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – FORESEER"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I4P Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – FORESEER"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I8P Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – FORESEER"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Source Code ctor_R16P Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – FORESEER"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R4P Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – FORESEER"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R8P Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – FORESEER"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p var panprocstr_i1pCalledByGraph = svgPanZoom('#procstr_i1pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I1P Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – FORESEER"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p var panprocstr_i2pCalledByGraph = svgPanZoom('#procstr_i2pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I2P Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – FORESEER"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p var panprocstr_i4pCalledByGraph = svgPanZoom('#procstr_i4pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I4P Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – FORESEER"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p var panprocstr_i8pCalledByGraph = svgPanZoom('#procstr_i8pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I8P Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – FORESEER"},{"text":"private elemental function str_R16P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. Calls proc~~str_r16p~~CallsGraph proc~str_r16p str_R16P proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R16P Source Code elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – FORESEER"},{"text":"private elemental function str_R4P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. Calls proc~~str_r4p~~CallsGraph proc~str_r4p str_R4P proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p var panprocstr_r4pCalledByGraph = svgPanZoom('#procstr_r4pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R4P Source Code elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – FORESEER"},{"text":"private elemental function str_R8P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. Calls proc~~str_r8p~~CallsGraph proc~str_r8p str_R8P proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p var panprocstr_r8pCalledByGraph = svgPanZoom('#procstr_r8pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R8P Source Code elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – FORESEER"},{"text":"private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I1P Source Code pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – FORESEER"},{"text":"private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I2P Source Code pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – FORESEER"},{"text":"private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I4P Source Code pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – FORESEER"},{"text":"private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I8P Source Code pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – FORESEER"},{"text":"private pure function str_a_R16P(n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R16P Source Code pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – FORESEER"},{"text":"private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R4P Source Code pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – FORESEER"},{"text":"private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R8P Source Code pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – FORESEER"},{"text":"private elemental function str_bol(n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_bol Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – FORESEER"},{"text":"private elemental function strf_I1P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I1P Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – FORESEER"},{"text":"private elemental function strf_I2P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I2P Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – FORESEER"},{"text":"private elemental function strf_I4P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I4P Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – FORESEER"},{"text":"private elemental function strf_I8P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I8P Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – FORESEER"},{"text":"private elemental function strf_R16P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Source Code strf_R16P Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – FORESEER"},{"text":"private elemental function strf_R4P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R4P Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – FORESEER"},{"text":"private elemental function strf_R8P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R8P Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – FORESEER"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p proc~save_man_page save_man_page proc~save_man_page->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I1P Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – FORESEER"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p proc~save_man_page save_man_page proc~save_man_page->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I2P Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – FORESEER"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p proc~save_man_page save_man_page proc~save_man_page->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I4P Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – FORESEER"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p proc~save_man_page save_man_page proc~save_man_page->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I8P Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – FORESEER"},{"text":"private pure subroutine compact_real_string(string) Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number. Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~str_r4p str_R4P proc~str_r4p->proc~compact_real_string proc~str_r8p str_R8P proc~str_r8p->proc~compact_real_string proc~str_r16p str_R16P proc~str_r16p->proc~compact_real_string proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_r8p interface~str->proc~str_a_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p var panproccompact_real_stringCalledByGraph = svgPanZoom('#proccompact_real_stringCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compact_real_string Source Code pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string – FORESEER"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p interface~str str proc~bctoi_i8p->interface~str proc~bctoi_i4p->interface~str proc~bctor_r4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i1p->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/bcton.html","title":"bcton – FORESEER"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P Module Procedures private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number.","tags":"","loc":"interface/bstr.html","title":"bstr – FORESEER"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~cton~~CalledByGraph interface~cton cton proc~get_cla_list_varying_r16p~2 get_cla_list_varying_R16P proc~get_cla_list_varying_r16p~2->interface~cton proc~get_cla_list_varying_r4p~2 get_cla_list_varying_R4P proc~get_cla_list_varying_r4p~2->interface~cton proc~get_cla_list_varying_i4p~2 get_cla_list_varying_I4P proc~get_cla_list_varying_i4p~2->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i2p~2 get_cla_list_varying_I2P proc~get_cla_list_varying_i2p~2->interface~cton proc~parse~2 parse proc~parse~2->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_r8p~2 get_cla_list_varying_R8P proc~get_cla_list_varying_r8p~2->interface~cton proc~signature~3 signature proc~signature~3->interface~cton proc~parse_command_line_interface parse_command_line_interface proc~parse_command_line_interface->interface~cton proc~usage~3 usage proc~usage~3->interface~cton proc~get_cla_list_varying_i1p~2 get_cla_list_varying_I1P proc~get_cla_list_varying_i1p~2->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_list_varying_i8p~2 get_cla_list_varying_I8P proc~get_cla_list_varying_i8p~2->interface~cton proc~initialize~6 initialize proc~initialize~6->proc~parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/cton.html","title":"cton – FORESEER"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~check_choices check_choices proc~check_choices->interface~str proc~description~3 description proc~description~3->interface~str proc~description~10 description proc~description~10->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description~5 description proc~description~5->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~save_time_serie save_time_serie proc~save_time_serie->interface~str program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~description~8 description proc~description~8->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~usage~3 usage proc~usage~3->interface~str proc~errored~3 errored proc~errored~3->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~description description proc~description->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->interface~str program~foreseer_test_shock_tube->proc~save_time_serie proc~description~6 description proc~description~6->interface~str proc~signature~3 signature proc~signature~3->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~description~12 description proc~description~12->interface~str proc~description~2 description proc~description~2->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P Module Procedures private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number.","tags":"","loc":"interface/str.html","title":"str – FORESEER"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~strz~~CalledByGraph interface~strz strz proc~save_man_page save_man_page proc~save_man_page->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros.","tags":"","loc":"interface/strz.html","title":"strz – FORESEER"},{"text":"public subroutine wenoof_create(interpolator_type, S, interpolator, face_left, face_right, eps) WenOOF creator, create a concrete WENO interpolator object. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencil dimension. class( interpolator_object ), intent(out), allocatable :: interpolator The concrete WENO interpolator. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero-div. Called By proc~~wenoof_create~~CalledByGraph proc~wenoof_create wenoof_create proc~reconstruct_interfaces_conservative reconstruct_interfaces_conservative proc~reconstruct_interfaces_conservative->proc~wenoof_create proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~reconstruct_interfaces_primitive->proc~wenoof_create proc~initialize~5 initialize proc~initialize~5->proc~wenoof_create proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~reconstruct_interfaces_characteristic->proc~wenoof_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code wenoof_create Source Code subroutine wenoof_create ( interpolator_type , S , interpolator , face_left , face_right , eps ) !< WenOOF creator, create a concrete WENO interpolator object. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencil dimension. class ( interpolator_object ), allocatable , intent ( out ) :: interpolator !< The concrete WENO interpolator. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero-div. type ( objects_factory ) :: factory !< The factory. call factory % create ( interpolator_type = interpolator_type , & S = S , & interpolator = interpolator , & face_left = face_left , & face_right = face_right , & eps = eps ) endsubroutine wenoof_create","tags":"","loc":"proc/wenoof_create.html","title":"wenoof_create – FORESEER"},{"text":"private subroutine create_(self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. Source Code create_ Source Code subroutine create_ ( self , constructor ) !< Create object. class ( base_object ), intent ( inout ) :: self !< Object. class ( base_object_constructor ), intent ( in ) :: constructor !< Object constructor. call self % destroy_ select type ( constructor ) class is ( base_object_constructor ) self % S = constructor % S if ( constructor % face_left . and . constructor % face_right ) then self % f1 = 1_I_P ; self % f2 = 2_I_P ; self % ff = 0_I_P elseif ( constructor % face_left ) then self % f1 = 1_I_P ; self % f2 = 1_I_P ; self % ff = 0_I_P elseif ( constructor % face_right ) then self % f1 = 2_I_P ; self % f2 = 2_I_P ; self % ff = - 1_I_P endif self % eps = constructor % eps endselect endsubroutine create_","tags":"","loc":"proc/create_.html","title":"create_ – FORESEER"},{"text":"private subroutine create_base_object_constructor(self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. Source Code create_base_object_constructor Source Code subroutine create_base_object_constructor ( self , S , face_left , face_right , eps ) !< Create alpha constructor. class ( base_object_constructor ), intent ( inout ) :: self !< Constructor. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid division by zero. self % S = S if ( present ( face_left )) self % face_left = face_left if ( present ( face_right )) self % face_right = face_right if ( present ( eps )) self % eps = eps endsubroutine create_base_object_constructor","tags":"","loc":"proc/create_base_object_constructor.html","title":"create_base_object_constructor – FORESEER"},{"text":"private elemental subroutine destroy_(self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Source Code destroy_ Source Code elemental subroutine destroy_ ( self ) !< Destroy object. class ( base_object ), intent ( inout ) :: self !< Object. self % S = 0_I_P self % f1 = 1_I_P self % f2 = 2_I_P self % ff = 0_I_P self % eps = EPS_DEF endsubroutine destroy_","tags":"","loc":"proc/destroy_.html","title":"destroy_ – FORESEER"},{"text":"private pure function description(self) result(string) Return beta string-description. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(in) :: self Beta. Return Value character(len=:),\n  allocatable String-description. Source Code description Source Code pure function description ( self ) result ( string ) !< Return beta string-description. class ( beta_rec_js ), intent ( in ) :: self !< Beta. character ( len = :), allocatable :: string !< String-description. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'beta_rec_js%description to be implemented, do not use!' #endif endfunction description","tags":"","loc":"proc/description~4.html","title":"description – FORESEER"},{"text":"private pure subroutine compute(self, stencil) Compute beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Source Code compute Source Code pure subroutine compute ( self , stencil ) !< Compute beta. class ( beta_rec_js ), intent ( inout ) :: self !< Beta. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. integer ( I_P ) :: s1 , s2 , s3 , f !< Counters. do s1 = 0 , self % S - 1 ! stencils loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = 0._RPP do s2 = 0 , self % S - 1 do s3 = 0 , self % S - 1 self % values ( f , s1 ) = self % values ( f , s1 ) + & self % coef ( s3 , s2 , s1 ) * stencil ( f + self % ff , s1 - s3 ) * stencil ( f + self % ff , s1 - s2 ) enddo enddo enddo enddo endsubroutine compute","tags":"","loc":"proc/compute.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. class( base_object_constructor ), intent(in) :: constructor Beta constructor. Calls proc~~create~~CallsGraph proc~create create c c proc~create->c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code create Source Code subroutine create ( self , constructor ) !< Create beta. class ( beta_rec_js ), intent ( inout ) :: self !< Beta. class ( base_object_constructor ), intent ( in ) :: constructor !< Beta constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP allocate ( self % coef ( 0 : self % S - 1 , 0 : self % S - 1 , 0 : self % S - 1 )) associate ( c => self % coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! stencil 0 !       i*i      ;     (i-1)*i c ( 0 , 0 , 0 ) = 1._RPP ; c ( 1 , 0 , 0 ) = - 2._RPP !      /         ;     (i-1)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 1._RPP ! stencil 1 !  (i+1)*(i+1)   ;     (i+1)*i c ( 0 , 0 , 1 ) = 1._RPP ; c ( 1 , 0 , 1 ) = - 2._RPP !      /         ;      i*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 1._RPP case ( 3 ) ! 5th order ! stencil 0 !      i*i                ;       (i-1)*i             ;       (i-2)*i c ( 0 , 0 , 0 ) = 1 0._RPP / 3._RPP ; c ( 1 , 0 , 0 ) = - 3 1._RPP / 3._RPP ; c ( 2 , 0 , 0 ) = 1 1._RPP / 3._RPP !      /                  ;       (i-1)*(i-1)         ;       (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 2 5._RPP / 3._RPP ; c ( 2 , 1 , 0 ) = - 1 9._RPP / 3._RPP !      /                  ;        /                  ;       (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 4._RPP / 3._RPP ! stencil 1 !     (i+1)*(i+1)         ;        i*(i+1)            ;       (i-1)*(i+1) c ( 0 , 0 , 1 ) = 4._RPP / 3._RPP ; c ( 1 , 0 , 1 ) = - 1 3._RPP / 3._RPP ; c ( 2 , 0 , 1 ) = 5._RPP / 3._RPP !      /                  ;        i*i                ;       (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 1 3._RPP / 3._RPP ; c ( 2 , 1 , 1 ) = - 1 3._RPP / 3._RPP !      /                  ;        /                  ;       (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 4._RPP / 3._RPP ! stencil 2 !     (i+2)*(i+2)         ;       (i+1)*(i+2)         ;        i*(i+2) c ( 0 , 0 , 2 ) = 4._RPP / 3._RPP ; c ( 1 , 0 , 2 ) = - 1 9._RPP / 3._RPP ; c ( 2 , 0 , 2 ) = 1 1._RPP / 3._RPP !      /                  ;       (i+1)*(i+1)         ;        i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 2 5._RPP / 3._RPP ; c ( 2 , 1 , 2 ) = - 3 1._RPP / 3._RPP !      /                  ;        /                  ;        i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 1 0._RPP / 3._RPP case ( 4 ) ! 7th order ! stencil 0 !              i*i              ;            (i-1)*i              ;            (i-2)*i c ( 0 , 0 , 0 ) = 210 7._RPP / 24 0._RPP ; c ( 1 , 0 , 0 ) = - 156 7._RPP / 4 0._RPP ; c ( 2 , 0 , 0 ) = 352 1._RPP / 12 0._RPP !          (i-3)*i c ( 3 , 0 , 0 ) = - 30 9._RPP / 4 0._RPP !               /               ;            (i-1)*(i-1)          ;            (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 1100 3._RPP / 24 0._RPP ; c ( 2 , 1 , 0 ) = - 862 3._RPP / 12 0._RPP !          (i-3)*(i-1) c ( 3 , 1 , 0 ) = 232 1._RPP / 12 0._RPP !               /               ;                 /               ;            (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 704 3._RPP / 24 0._RPP !          (i-3)*(i-2) c ( 3 , 2 , 0 ) = - 64 7._RPP / 4 0._RPP !               /               ;                 /               ;                 / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP ; c ( 2 , 3 , 0 ) = 0._RPP !          (i-3)*(i-3) c ( 3 , 3 , 0 ) = 54 7._RPP / 24 0._RPP ! stencil 1 !          (i+1)*(i+1)          ;                i*(i+1)          ;            (i-1)*(i+1) c ( 0 , 0 , 1 ) = 54 7._RPP / 24 0._RPP ; c ( 1 , 0 , 1 ) = - 126 1._RPP / 12 0._RPP ; c ( 2 , 0 , 1 ) = 96 1._RPP / 12 0._RPP !          (i-2)*(i+1) c ( 3 , 0 , 1 ) = - 24 7._RPP / 12 0._RPP !               /               ;                i*i              ;            (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 344 3._RPP / 24 0._RPP ; c ( 2 , 1 , 1 ) = - 298 3._RPP / 12 0._RPP !          (i-2)*i c ( 3 , 1 , 1 ) = 26 7._RPP / 4 0._RPP !               /               ;                 /               ;            (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 284 3._RPP / 24 0._RPP !          (i-2)*(i-1) c ( 3 , 2 , 1 ) = - 82 1._RPP / 12 0._RPP !               /               ;                 /               ;                 / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP ; c ( 2 , 3 , 1 ) = 0._RPP !          (i-2)*(i-2) c ( 3 , 3 , 1 ) = 8 9._RPP / 8 0._RPP ! stencil 2 !          (i+2)*(i+2)          ;            (i+1)*(i+2)          ;                i*(i+2) c ( 0 , 0 , 2 ) = 8 9._RPP / 8 0._RPP ; c ( 1 , 0 , 2 ) = - 82 1._RPP / 12 0._RPP ; c ( 2 , 0 , 2 ) = 26 7._RPP / 4 0._RPP !          (i-1)*(i+2) c ( 3 , 0 , 2 ) = - 24 7._RPP / 12 0._RPP !               /               ;            (i+1)*(i+1)          ;                i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 284 3._RPP / 24 0._RPP ; c ( 2 , 1 , 2 ) = - 298 3._RPP / 12 0._RPP !          (i-1)*(i+1) c ( 3 , 1 , 2 ) = 96 1._RPP / 12 0._RPP !               /               ;                 /               ;                i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 344 3._RPP / 24 0._RPP !          (i-1)*i c ( 3 , 2 , 2 ) = - 126 1._RPP / 12 0._RPP !               /               ;                 /               ;                 / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP ; c ( 2 , 3 , 2 ) = 0._RPP !          (i-1)*(i-1) c ( 3 , 3 , 2 ) = 54 7._RPP / 24 0._RPP ! stencil 3 !          (i+3)*(i+3)          ;            (i+2)*(i+3)          ;            (i+1)*(i+3) c ( 0 , 0 , 3 ) = 54 7._RPP / 24 0._RPP ; c ( 1 , 0 , 3 ) = - 64 7._RPP / 4 0._RPP ; c ( 2 , 0 , 3 ) = 232 1._RPP / 12 0._RPP !              i*(i+3) c ( 3 , 0 , 3 ) = - 30 9._RPP / 4 0._RPP !               /               ;            (i+2)*(i+2)          ;      (i+1)*(i+2) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 704 3._RPP / 24 0._RPP ; c ( 2 , 1 , 3 ) = - 862 3._RPP / 12 0._RPP !              i*(i+2) c ( 3 , 1 , 3 ) = 352 1._RPP / 12 0._RPP !               /               ;                 /               ;      (i+1)*(i+1) c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP ; c ( 2 , 2 , 3 ) = 1100 3._RPP / 24 0._RPP !              i*(i+1) c ( 3 , 2 , 3 ) = - 156 7._RPP / 4 0._RPP !               /               ;                 /               ;           / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP ; c ( 2 , 3 , 3 ) = 0._RPP !              i*i c ( 3 , 3 , 3 ) = 210 7._RPP / 24 0._RPP case ( 5 ) ! 9th order ! stencil 0 !              i*i                 ;             (i-1)*i                ;             (i-2)*i c ( 0 , 0 , 0 ) = 5395 9._RPP / 252 0._RPP ; c ( 1 , 0 , 0 ) = - 64950 1._RPP / 504 0._RPP ; c ( 2 , 0 , 0 ) = 25294 1._RPP / 168 0._RPP !          (i-3)*i                 ;             (i-4)*i c ( 3 , 0 , 0 ) = - 41148 7._RPP / 504 0._RPP ; c ( 4 , 0 , 0 ) = 8632 9._RPP / 504 0._RPP !               /                  ;             (i-1)*(i-1)            ;             (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 102056 3._RPP / 504 0._RPP ; c ( 2 , 1 , 0 ) = - 6839 1._RPP / 14 0._RPP !          (i-3)*(i-1)             ;             (i-4)*(i-1) c ( 3 , 1 , 0 ) = 67922 9._RPP / 252 0._RPP ; c ( 4 , 1 , 0 ) = - 28800 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 50713 1._RPP / 168 0._RPP !          (i-3)*(i-2)             ;             (i-4)*(i-2) c ( 3 , 2 , 0 ) = - 14203 3._RPP / 42 0._RPP ; c ( 4 , 2 , 0 ) = 12162 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP ; c ( 2 , 3 , 0 ) = 0._RPP !          (i-3)*(i-3)             ;             (i-4)*(i-3) c ( 3 , 3 , 0 ) = 48296 3._RPP / 504 0._RPP ; c ( 4 , 3 , 0 ) = - 20850 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP ; c ( 2 , 4 , 0 ) = 0._RPP !               /                  ;             (i-4)*(i-4) c ( 3 , 4 , 0 ) = 0._RPP ; c ( 4 , 4 , 0 ) = 1132 9._RPP / 252 0._RPP ! stencil 1 !          (i+1)*(i+1)             ;                 i*(i+1)            ;             (i-1)*(i+1) c ( 0 , 0 , 1 ) = 1132 9._RPP / 252 0._RPP ; c ( 1 , 0 , 1 ) = - 14025 1._RPP / 504 0._RPP ; c ( 2 , 0 , 1 ) = 5505 1._RPP / 168 0._RPP !          (i-2)*(i+1)             ;             (i-3)*(i+1) c ( 3 , 0 , 1 ) = - 8829 7._RPP / 504 0._RPP ; c ( 4 , 0 , 1 ) = 1807 9._RPP / 504 0._RPP !               /                  ;                 i*i                ;             (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 24272 3._RPP / 504 0._RPP ; c ( 2 , 1 , 1 ) = - 2549 9._RPP / 21 0._RPP !          (i-2)*i                 ;             (i-3)*i c ( 3 , 1 , 1 ) = 16850 9._RPP / 252 0._RPP ; c ( 4 , 1 , 1 ) = - 7023 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 13543 1._RPP / 168 0._RPP !          (i-2)*(i-1)             ;             (i-3)*(i-1) c ( 3 , 2 , 1 ) = - 322 9._RPP / 3 5._RPP ; c ( 4 , 2 , 1 ) = 3307 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP ; c ( 2 , 3 , 1 ) = 0._RPP !          (i-2)*(i-2)             ;             (i-3)*(i-2) c ( 3 , 3 , 1 ) = 13856 3._RPP / 504 0._RPP ; c ( 4 , 3 , 1 ) = - 6087 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP ; c ( 2 , 4 , 1 ) = 0._RPP !               /                  ;             (i-3)*(i-3) c ( 3 , 4 , 1 ) = 0._RPP ; c ( 4 , 4 , 1 ) = 172 7._RPP / 126 0._RPP ! stencil 2 !          (i+2)*(i+2)             ;             (i+1)*(i+2)            ;                 i*(i+2) c ( 0 , 0 , 2 ) = 172 7._RPP / 126 0._RPP ; c ( 1 , 0 , 2 ) = - 5100 1._RPP / 504 0._RPP ; c ( 2 , 0 , 2 ) = 754 7._RPP / 56 0._RPP !          (i-1)*(i+2)             ;             (i-2)*(i+2) c ( 3 , 0 , 2 ) = - 3894 7._RPP / 504 0._RPP ; c ( 4 , 0 , 2 ) = 820 9._RPP / 504 0._RPP !               /                  ;             (i+1)*(i+1)            ;                 i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 10496 3._RPP / 504 0._RPP ; c ( 2 , 1 , 2 ) = - 2492 3._RPP / 42 0._RPP !          (i-1)*(i+1)             ;             (i-2)*(i+1) c ( 3 , 1 , 2 ) = 8954 9._RPP / 252 0._RPP ; c ( 4 , 1 , 2 ) = - 3894 7._RPP / 504 0._RPP !               /                  ;                  /                 ;                 i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 7705 1._RPP / 168 0._RPP !          (i-1)*i                 ;             (i-2)*i c ( 3 , 2 , 2 ) = - 2492 3._RPP / 42 0._RPP ; c ( 4 , 2 , 2 ) = 754 7._RPP / 56 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP ; c ( 2 , 3 , 2 ) = 0._RPP !          (i-1)*(i-1)             ;             (i-2)*(i-1) c ( 3 , 3 , 2 ) = 10496 3._RPP / 504 0._RPP ; c ( 4 , 3 , 2 ) = - 5100 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP ; c ( 2 , 4 , 2 ) = 0._RPP !               /                  ;             (i-2)*(i-2) c ( 3 , 4 , 2 ) = 0._RPP ; c ( 4 , 4 , 2 ) = 172 7._RPP / 126 0._RPP ! stencil 3 !          (i+3)*(i+3)             ;             (i+2)*(i+3)            ;             (i+1)*(i+3) c ( 0 , 0 , 3 ) = 172 7._RPP / 126 0._RPP ; c ( 1 , 0 , 3 ) = - 6087 1._RPP / 504 0._RPP ; c ( 2 , 0 , 3 ) = 3307 1._RPP / 168 0._RPP !              i*(i+3)             ;             (i-1)*(i+3) c ( 3 , 0 , 3 ) = - 7023 7._RPP / 504 0._RPP ; c ( 4 , 0 , 3 ) = 1807 9._RPP / 504 0._RPP !               /                  ;             (i+2)*(i+2)            ;             (i+1)*(i+2) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 13856 3._RPP / 504 0._RPP ; c ( 2 , 1 , 3 ) = - 322 9._RPP / 3 5._RPP !              i*(i+2)             ;             (i-1)*(i+2) c ( 3 , 1 , 3 ) = 16850 9._RPP / 252 0._RPP ; c ( 4 , 1 , 3 ) = - 8829 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i+1)*(i+1) c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP ; c ( 2 , 2 , 3 ) = 13543 1._RPP / 168 0._RPP !              i*(i+1)             ;             (i-1)*(i+1) c ( 3 , 2 , 3 ) = - 2549 9._RPP / 21 0._RPP ; c ( 4 , 2 , 3 ) = 5505 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP ; c ( 2 , 3 , 3 ) = 0._RPP !              i*i                 ;             (i-1)*i c ( 3 , 3 , 3 ) = 24272 3._RPP / 504 0._RPP ; c ( 4 , 3 , 3 ) = - 14025 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP ; c ( 2 , 4 , 3 ) = 0._RPP !               /                  ;             (i-1)*(i-1) c ( 3 , 4 , 3 ) = 0._RPP ; c ( 4 , 4 , 3 ) = 1132 9._RPP / 252 0._RPP ! stencil 4 !          (i+4)*(i+4)             ;             (i+3)*(i+4)            ;             (i+2)*(i+4) c ( 0 , 0 , 4 ) = 1132 9._RPP / 252 0._RPP ; c ( 1 , 0 , 4 ) = - 20850 1._RPP / 504 0._RPP ; c ( 2 , 0 , 4 ) = 12162 1._RPP / 168 0._RPP !          (i+1)*(i+4)             ;                 i*(i+4) c ( 3 , 0 , 4 ) = - 28800 7._RPP / 504 0._RPP ; c ( 4 , 0 , 4 ) = 8632 9._RPP / 504 0._RPP !               /                  ;             (i+3)*(i+3)            ;             (i+2)*(i+3) c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 48296 3._RPP / 504 0._RPP ; c ( 2 , 1 , 4 ) = - 14203 3._RPP / 42 0._RPP !          (i+1)*(i+3)             ;                 i*(i+3) c ( 3 , 1 , 4 ) = 67922 9._RPP / 252 0._RPP ; c ( 4 , 1 , 4 ) = - 41148 7._RPP / 504 0._RPP !               /                  ;                  /                 ;             (i+1)*(i+2) c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP ; c ( 2 , 2 , 4 ) = 50713 1._RPP / 168 0._RPP !          (i+1)*(i+2)             ;                 i*(i+2) c ( 3 , 2 , 4 ) = - 6839 1._RPP / 14 0._RPP ; c ( 4 , 2 , 4 ) = 25294 1._RPP / 168 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP ; c ( 2 , 3 , 4 ) = 0._RPP !          (i+1)*(i+1)             ;                 i*(i+1) c ( 3 , 3 , 4 ) = 102056 3._RPP / 504 0._RPP ; c ( 4 , 3 , 4 ) = - 64950 1._RPP / 504 0._RPP !               /                  ;                  /                 ;                  / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP ; c ( 2 , 4 , 4 ) = 0._RPP !               /                  ;                 i*i c ( 3 , 4 , 4 ) = 0._RPP ; c ( 4 , 4 , 4 ) = 5395 9._RPP / 252 0._RPP case ( 6 ) ! 11th order ! stencil 0 !                 i*i                  ;                (i-1)*i                 ;                 (i-2)*i c ( 0 , 0 , 0 ) = 615021 1._RPP / 12096 0._RPP ; c ( 1 , 0 , 0 ) = - 296627 9._RPP / 756 0._RPP ; c ( 2 , 0 , 0 ) = 476292 1._RPP / 756 0._RPP !             (i-3)*i                  ;                (i-4)*i                 ;                 (i-5)*i c ( 3 , 0 , 0 ) = - 1584853 1._RPP / 3024 0._RPP ; c ( 4 , 0 , 0 ) = 270601 7._RPP / 1209 6._RPP ; c ( 5 , 0 , 0 ) = - 23563 7._RPP / 604 8._RPP !                  /                   ;                (i-1)*(i-1)             ;                 (i-2)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 3161707 9._RPP / 4032 0._RPP ; c ( 2 , 1 , 0 ) = - 2598093 7._RPP / 1008 0._RPP !             (i-3)*(i-1)              ;                (i-4)*(i-1)             ;                 (i-5)*(i-1) c ( 3 , 1 , 0 ) = 3286270 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 0 ) = - 104821 1._RPP / 112 0._RPP ; c ( 5 , 1 , 0 ) = 66114 5._RPP / 403 2._RPP !                  /                   ;                     /                  ;                 (i-2)*(i-2) c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP ; c ( 2 , 2 , 0 ) = 2170378 1._RPP / 1008 0._RPP !              (i-3)*(i-2)             ;                (i-4)*(i-2)             ;                 (i-5)*(i-2) c ( 3 , 2 , 0 ) = - 693756 1._RPP / 189 0._RPP ; c ( 4 , 2 , 0 ) = 267495 1._RPP / 168 0._RPP ; c ( 5 , 2 , 0 ) = - 31406 3._RPP / 112 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP ; c ( 2 , 3 , 0 ) = 0._RPP !             (i-3)*(i-3)              ;                (i-4)*(i-3)             ;                 (i-5)*(i-3) c ( 3 , 3 , 0 ) = 4768939 3._RPP / 3024 0._RPP ; c ( 4 , 3 , 0 ) = - 4161526 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 0 ) = 184014 1._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP ; c ( 2 , 4 , 0 ) = 0._RPP !                  /                   ;                (i-4)*(i-4)             ;                 (i-5)*(i-4) c ( 3 , 4 , 0 ) = 0._RPP ; c ( 4 , 4 , 0 ) = 1216022 9._RPP / 4032 0._RPP ; c ( 5 , 4 , 0 ) = - 53959 1._RPP / 504 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP ; c ( 2 , 5 , 0 ) = 0._RPP !                  /                   ;                     /                  ;                 (i-5)*(i-5) c ( 3 , 5 , 0 ) = 0._RPP ; c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 38418 7._RPP / 4032 0._RPP ! stencil 1 !             (i+1)*(i+1)              ;                    i*(i+1)             ;                 (i-1)*(i+1) c ( 0 , 0 , 1 ) = 38418 7._RPP / 4032 0._RPP ; c ( 1 , 0 , 1 ) = - 113974 9._RPP / 1512 0._RPP ; c ( 2 , 0 , 1 ) = 6142 7._RPP / 50 4._RPP ; !             (i-2)*(i+1)              ;                (i-3)*(i+1)             ;                 (i-4)*(i+1) c ( 3 , 0 , 1 ) = - 101530 3._RPP / 1008 0._RPP ; c ( 4 , 0 , 1 ) = 256728 7._RPP / 6048 0._RPP ; c ( 5 , 0 , 1 ) = - 7337 9._RPP / 1008 0._RPP ; !                  /                   ;                    i*i                 ;                 (i-1)*i c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 1936596 7._RPP / 12096 0._RPP ; c ( 2 , 1 , 1 ) = - 1630606 1._RPP / 3024 0._RPP !             (i-2)*i                  ;                (i-3)*i                 ;                 (i-4)*i c ( 3 , 1 , 1 ) = 688171 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 1 ) = - 587761 7._RPP / 3024 0._RPP ; c ( 5 , 1 , 1 ) = 203350 9._RPP / 6048 0._RPP !                  /                   ;                     /                  ;                 (i-1)*(i-1) c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP ; c ( 2 , 2 , 1 ) = 472185 1._RPP / 1008 0._RPP !             (i-2)*(i-1)              ;                (i-3)*(i-1)             ;                 (i-4)*(i-1) c ( 3 , 2 , 1 ) = - 16985 9._RPP / 21 0._RPP ; c ( 4 , 2 , 1 ) = 530062 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 1 ) = - 6860 1._RPP / 112 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP ; c ( 2 , 3 , 1 ) = 0._RPP !             (i-2)*(i-2)              ;                (i-3)*(i-2)             ;                 (i-4)*(i-2) c ( 3 , 3 , 1 ) = 119704 7._RPP / 336 0._RPP ; c ( 4 , 3 , 1 ) = - 947833 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 1 ) = 13947 1._RPP / 252 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP ; c ( 2 , 4 , 1 ) = 0._RPP !                  /                   ;                (i-3)*(i-3)             ;                 (i-4)*(i-3) c ( 3 , 4 , 1 ) = 0._RPP ; c ( 4 , 4 , 1 ) = 844995 7._RPP / 12096 0._RPP ; c ( 5 , 4 , 1 ) = - 18848 3._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP ; c ( 2 , 5 , 1 ) = 0._RPP !                  /                   ;                     /                  ;                 (i-4)*(i-4) c ( 3 , 5 , 1 ) = 0._RPP ; c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 9059 3._RPP / 4032 0._RPP ! stencil 2 !             (i+2)*(i+2)              ;                (i+1)*(i+2)             ;                     i*(i+2) c ( 0 , 0 , 2 ) = 9059 3._RPP / 4032 0._RPP ; c ( 1 , 0 , 2 ) = - 124 0._RPP / 6 3._RPP ; c ( 2 , 0 , 2 ) = 25539 7._RPP / 756 0._RPP !             (i-1)*(i+2)              ;                (i-2)*(i+2)             ;                 (i-3)*(i+2) c ( 3 , 0 , 2 ) = - 28852 1._RPP / 1008 0._RPP ; c ( 4 , 0 , 2 ) = 24312 7._RPP / 2016 0._RPP ; c ( 5 , 0 , 2 ) = - 1228 1._RPP / 604 8._RPP !                  /                   ;                (i+1)*(i+1)             ;                     i*(i+1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 188443 9._RPP / 4032 0._RPP ; c ( 2 , 1 , 2 ) = - 510697 1._RPP / 3024 0._RPP !             (i-1)*(i+1)              ;                (i-2)*(i+1)             ;                (i-3)*(i+1) c ( 3 , 1 , 2 ) = 24868 1._RPP / 168 0._RPP ; c ( 4 , 1 , 2 ) = - 64399 9._RPP / 1008 0._RPP ; c ( 5 , 1 , 2 ) = 66250 3._RPP / 6048 0._RPP !                  /                   ;                     /                  ;                    i*i c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP ; c ( 2 , 2 , 2 ) = 487774 3._RPP / 3024 0._RPP !             (i-1)*i                  ;                (i-2)*i                 ;                (i-3)*i c ( 3 , 2 , 2 ) = - 55965 1._RPP / 189 0._RPP ; c ( 4 , 2 , 2 ) = 199123 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 2 ) = - 13963 3._RPP / 604 8._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP ; c ( 2 , 3 , 2 ) = 0._RPP !             (i-1)*(i-1)              ;                (i-2)*(i-1)             ;                (i-3)*(i-1) c ( 3 , 3 , 2 ) = 15921 9._RPP / 112 0._RPP ; c ( 4 , 3 , 2 ) = - 132336 7._RPP / 1008 0._RPP ; c ( 5 , 3 , 2 ) = 17899 9._RPP / 756 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP ; c ( 2 , 4 , 2 ) = 0._RPP !                  /                   ;                (i-2)*(i-2)             ;                (i-3)*(i-2) c ( 3 , 4 , 2 ) = 0._RPP ; c ( 4 , 4 , 2 ) = 14166 1._RPP / 448 0._RPP ; c ( 5 , 4 , 2 ) = - 17874 7._RPP / 1512 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP ; c ( 2 , 5 , 2 ) = 0._RPP !                  /                   ;                     /                  ;                (i-3)*(i-3) c ( 3 , 5 , 2 ) = 0._RPP ; c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 13963 3._RPP / 12096 0._RPP ! stencil 3 !             (i+3)*(i+3)              ;                (i+2)*(i+3)             ;                 (i+1)*(i+3) c ( 0 , 0 , 3 ) = 13963 3._RPP / 12096 0._RPP ; c ( 1 , 0 , 3 ) = - 17874 7._RPP / 1512 0._RPP ; c ( 2 , 0 , 3 ) = 17899 9._RPP / 756 0._RPP !                 i*(i+3)              ;                (i-1)*(i+3)             ;                 (i-2)*(i+3) c ( 3 , 0 , 3 ) = - 13963 3._RPP / 604 8._RPP ; c ( 4 , 0 , 3 ) = 66250 3._RPP / 6048 0._RPP ; c ( 5 , 0 , 3 ) = - 1228 1._RPP / 604 8._RPP !                  /                   ;                (i+2)*(i+2)             ;                 (i+1)*(i+2) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 14166 1._RPP / 448 0._RPP ; c ( 2 , 1 , 3 ) = - 132336 7._RPP / 1008 0._RPP !                 i*(i+2)              ;                (i-1)*(i+2)             ;                 (i-2)*(i+2) c ( 3 , 1 , 3 ) = 199123 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 3 ) = - 64399 9._RPP / 1008 0._RPP ; c ( 5 , 1 , 3 ) = 24312 7._RPP / 2016 0._RPP !                  /                   ;                     /                  ;                    i*(i+1) c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP ; c ( 2 , 2 , 3 ) = 15921 9._RPP / 112 0._RPP !                 i*(i+1)              ;                (i-1)*(i+1)             ;                (i-2)*(i+1) c ( 3 , 2 , 3 ) = - 55965 1._RPP / 189 0._RPP ; c ( 4 , 2 , 3 ) = 24868 1._RPP / 168 0._RPP ; c ( 5 , 2 , 3 ) = - 28852 1._RPP / 1008 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP ; c ( 2 , 3 , 3 ) = 0._RPP !                 i*i                  ;                (i-1)*i                 ;                (i-2)*i c ( 3 , 3 , 3 ) = 487774 3._RPP / 3024 0._RPP ; c ( 4 , 3 , 3 ) = - 510697 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 3 ) = 25539 7._RPP / 756 0._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP ; c ( 2 , 4 , 3 ) = 0._RPP !                  /                   ;                (i-1)*(i-1)             ;                (i-2)*(i-1) c ( 3 , 4 , 3 ) = 0._RPP ; c ( 4 , 4 , 3 ) = 188443 9._RPP / 4032 0._RPP ; c ( 5 , 4 , 3 ) = - 124 0._RPP / 6 3._RPP !                  /                   ;                     /                  ;                     / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP ; c ( 2 , 5 , 3 ) = 0._RPP !                  /                   ;                     /                  ;                (i-2)*(i-2) c ( 3 , 5 , 3 ) = 0._RPP ; c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 9059 3._RPP / 4032 0._RPP ! stencil 4 !             (i+4)*(i+4)              ;                (i+3)*(i+4)             ;                 (i+2)*(i+4) c ( 0 , 0 , 4 ) = 9059 3._RPP / 4032 0._RPP ; c ( 1 , 0 , 4 ) = - 18848 3._RPP / 756 0._RPP ; c ( 2 , 0 , 4 ) = 13947 1._RPP / 252 0._RPP !             (i+1)*(i+4)              ;                    i*(i+4)             ;                 (i-1)*(i+4) c ( 3 , 0 , 4 ) = - 6860 1._RPP / 112 0._RPP ; c ( 4 , 0 , 4 ) = 203350 9._RPP / 6048 0._RPP ; c ( 5 , 0 , 4 ) = - 7337 9._RPP / 1008 0._RPP !                  /                   ;                (i+3)*(i+3)             ;                 (i+2)*(i+3) c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 844995 7._RPP / 12096 0._RPP ; c ( 2 , 1 , 4 ) = - 947833 1._RPP / 3024 0._RPP !             (i+1)*(i+3)              ;                    i*(i+3)             ;                 (i-1)*(i+3) c ( 3 , 1 , 4 ) = 530062 9._RPP / 1512 0._RPP ; c ( 4 , 1 , 4 ) = - 587761 7._RPP / 3024 0._RPP ; c ( 5 , 1 , 4 ) = 256728 7._RPP / 6048 0._RPP !                  /                   ;                     /                  ;                 (i+2)*(i+2) c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP ; c ( 2 , 2 , 4 ) = 119704 7._RPP / 336 0._RPP !             (i+1)*(i+2)              ;                    i*(i+2)             ;                 (i-1)*(i+2) c ( 3 , 2 , 4 ) = - 16985 9._RPP / 21 0._RPP ; c ( 4 , 2 , 4 ) = 688171 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 4 ) = - 101530 3._RPP / 1008 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP ; c ( 2 , 3 , 4 ) = 0._RPP !             (i+1)*(i+1)              ;                    i*(i+1)             ;                 (i-1)*(i+1) c ( 3 , 3 , 4 ) = 472185 1._RPP / 1008 0._RPP ; c ( 4 , 3 , 4 ) = - 1630606 1._RPP / 3024 0._RPP ; c ( 5 , 3 , 4 ) = 6142 7._RPP / 50 4._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP ; c ( 2 , 4 , 4 ) = 0._RPP !                  /                   ;                    i*i                 ;                 (i-1)*i c ( 3 , 4 , 4 ) = 0._RPP ; c ( 4 , 4 , 4 ) = 1936596 7._RPP / 12096 0._RPP ; c ( 5 , 4 , 4 ) = - 113974 9._RPP / 1512 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP ; c ( 2 , 5 , 4 ) = 0._RPP !                  /                   ;                     /                  ;                 (i-1)*(i-1) c ( 3 , 5 , 4 ) = 0._RPP ; c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 38418 7._RPP / 4032 0._RPP ! stencil 5 !             (i+5)*(i+5)              ;                (i+4)*(i+5)             ;                 (i+3)*(i+5) c ( 0 , 0 , 5 ) = 38418 7._RPP / 4032 0._RPP ; c ( 1 , 0 , 5 ) = - 53959 1._RPP / 504 0._RPP ; c ( 2 , 0 , 5 ) = 184014 1._RPP / 756 0._RPP !             (i+2)*(i+5)              ;                (i+1)*(i+5)             ;                     i*(i+5) c ( 3 , 0 , 5 ) = - 31406 3._RPP / 112 0._RPP ; c ( 4 , 0 , 5 ) = 66114 5._RPP / 403 2._RPP ; c ( 5 , 0 , 5 ) = - 23563 7._RPP / 604 8._RPP !                  /                   ;                (i+4)*(i+3)             ;                 (i+3)*(i+3) c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 1216022 9._RPP / 4032 0._RPP ; c ( 2 , 1 , 5 ) = - 4161526 1._RPP / 3024 0._RPP !             (i+2)*(i+3)              ;                (i+1)*(i+3)             ;                     i*(i+3) c ( 3 , 1 , 5 ) = 267495 1._RPP / 168 0._RPP ; c ( 4 , 1 , 5 ) = - 104821 1._RPP / 112 0._RPP ; c ( 5 , 1 , 5 ) = 270601 7._RPP / 1209 6._RPP !                  /                   ;                     /                  ;                 (i+3)*(i+2) c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP ; c ( 2 , 2 , 5 ) = 4768939 3._RPP / 3024 0._RPP !             (i+2)*(i+2)              ;                (i+1)*(i+2)             ;                     i*(i+2) c ( 3 , 2 , 5 ) = - 693756 1._RPP / 189 0._RPP ; c ( 4 , 2 , 5 ) = 3286270 9._RPP / 1512 0._RPP ; c ( 5 , 2 , 5 ) = - 1584853 1._RPP / 3024 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP ; c ( 2 , 3 , 5 ) = 0._RPP !             (i+2)*(i+1)              ;                (i+1)*(i+1)             ;                     i*(i+1) c ( 3 , 3 , 5 ) = 2170378 1._RPP / 1008 0._RPP ; c ( 4 , 3 , 5 ) = - 2598093 7._RPP / 1008 0._RPP ; c ( 5 , 3 , 5 ) = 476292 1._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP ; c ( 2 , 4 , 5 ) = 0._RPP !                  /                   ;                (i+1)*i                 ;                     i*i c ( 3 , 4 , 5 ) = 0._RPP ; c ( 4 , 4 , 5 ) = 3161707 9._RPP / 4032 0._RPP ; c ( 5 , 4 , 5 ) = - 296627 9._RPP / 756 0._RPP !                  /                   ;                     /                  ;                      / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP ; c ( 2 , 5 , 5 ) = 0._RPP !                  /                   ;                     /                  ;                     i*(i-1) c ( 3 , 5 , 5 ) = 0._RPP ; c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 615021 1._RPP / 12096 0._RPP case ( 7 ) ! 13th order ! stencil 0 !                   i*i                   ;                   (i-1)*i c ( 0 , 0 , 0 ) = 89720716 3._RPP / 748440 0._RPP ; c ( 1 , 0 , 0 ) = - 2276309235 7._RPP / 1995840 0._RPP !                  (i-2)*i                ;                   (i-3)*i c ( 2 , 0 , 0 ) = 4680858363 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 0 ) = - 3964543964 3._RPP / 1496880 0._RPP !                  (i-4)*i                ;                   (i-5)*i c ( 4 , 0 , 0 ) = 857930974 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 0 ) = - 241688504 3._RPP / 399168 0._RPP !                  (i-6)*i c ( 6 , 0 , 0 ) = 539152879 9._RPP / 5987520 0._RPP !                    /                    ;                   (i-1)*(i-1) c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 618261273 1._RPP / 221760 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 2 , 1 , 0 ) = - 862343162 3._RPP / 73920 0._RPP ; c ( 3 , 1 , 0 ) = 6644004937 1._RPP / 498960 0._RPP !                  (i-4)*(i-1)            ;                   (i-5)*(i-1) c ( 4 , 1 , 0 ) = - 1930850567 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 0 ) = 341705736 7._RPP / 110880 0._RPP !                  (i-6)*(i-1) c ( 6 , 1 , 0 ) = - 918196195 9._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 2 , 2 , 0 ) = 136940474 9._RPP / 11088 0._RPP ; c ( 3 , 2 , 0 ) = - 2836489260 7._RPP / 99792 0._RPP !                  (i-4)*(i-2)            ;                   (i-5)*(i-2) c ( 4 , 2 , 0 ) = 829077191 3._RPP / 44352 0._RPP ; c ( 5 , 2 , 0 ) = - 1473417899 9._RPP / 221760 0._RPP !                  (i-6)*(i-2) c ( 6 , 2 , 0 ) = 496477189 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP !                    /                    ;                   (i-3)*(i-3) c ( 2 , 3 , 0 ) = 0._RPP ; c ( 3 , 3 , 0 ) = 4925685991 9._RPP / 299376 0._RPP !                  (i-4)*(i-3)            ;                   (i-5)*(i-3) c ( 4 , 3 , 0 ) = - 2169300276 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 0 ) = 3868338505 1._RPP / 498960 0._RPP !                  (i-6)*(i-3) c ( 6 , 3 , 0 ) = - 1742503220 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 0 ) = 0._RPP ; c ( 3 , 4 , 0 ) = 0._RPP !                  (i-4)*(i-4)            ;                   (i-5)*(i-4) c ( 4 , 4 , 0 ) = 19973092 1._RPP / 2772 0._RPP ; c ( 5 , 4 , 0 ) = - 380943782 3._RPP / 73920 0._RPP !                  (i-6)*(i-4) c ( 6 , 4 , 0 ) = 1547692635 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 0 ) = 0._RPP ; c ( 3 , 5 , 0 ) = 0._RPP !                    /                    ;                   (i-5)*(i-5) c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 204794188 3._RPP / 221760 0._RPP !                  (i-6)*(i-5) c ( 6 , 5 , 0 ) = - 555666927 7._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 0 ) = 0._RPP ; c ( 1 , 6 , 0 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 0 ) = 0._RPP ; c ( 3 , 6 , 0 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 0 ) = 0._RPP ; c ( 5 , 6 , 0 ) = 0._RPP !                  (i-6)*(i-6) c ( 6 , 6 , 0 ) = 6291129 7._RPP / 299376 0._RPP ! stencil 1 !                  (i+1)*(i+1)            ;                    i*(i+1) c ( 0 , 0 , 1 ) = 6291129 7._RPP / 299376 0._RPP ; c ( 1 , 0 , 1 ) = - 407454478 7._RPP / 1995840 0._RPP !                  (i-1)*(i+1)            ;                   (i-2)*(i+1) c ( 2 , 0 , 1 ) = 281106706 7._RPP / 665280 0._RPP ; c ( 3 , 0 , 1 ) = - 712463825 3._RPP / 1496880 0._RPP !                  (i-3)*(i+1)            ;                   (i-4)*(i+1) c ( 4 , 0 , 1 ) = 153130724 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 1 ) = - 71274560 3._RPP / 665280 0._RPP !                  (i-5)*(i+1) c ( 6 , 0 , 1 ) = 94515532 9._RPP / 5987520 0._RPP !                    /                    ;                       i*(i-1) c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 12794249 7._RPP / 24640 0._RPP !                  (i-1)*(i-1)            ;                   (i-2)*(i-1) c ( 2 , 1 , 1 ) = - 1468493305 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 1 ) = 1260100950 1._RPP / 498960 0._RPP !                  (i-3)*(i-1)            ;                   (i-4)*(i-1) c ( 4 , 1 , 1 ) = - 40538296 1._RPP / 24640 0._RPP ; c ( 5 , 1 , 1 ) = 192403251 1._RPP / 332640 0._RPP !                  (i-5)*(i-1) c ( 6 , 1 , 1 ) = - 34191075 7._RPP / 399168 0._RPP !                    /                    ;                    / c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP !                  (i-1)*(i-2)            ;                   (i-3)*(i-2) c ( 2 , 2 , 1 ) = 79635877 7._RPP / 33264 0._RPP ; c ( 3 , 2 , 1 ) = - 61641031 3._RPP / 11088 0._RPP !                  (i-4)*(i-2)            ;                   (i-5)*(i-2) c ( 4 , 2 , 1 ) = 486808918 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 1 ) = - 861944098 7._RPP / 665280 0._RPP !                  (i-6)*(i-2) c ( 6 , 2 , 1 ) = 32078218 3._RPP / 166320 0._RPP !                    /                    ;                     / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP !                    /                    ;                   (i-2)*(i-3) c ( 2 , 3 , 1 ) = 0._RPP ; c ( 3 , 3 , 1 ) = 978005716 9._RPP / 299376 0._RPP !                  (i-3)*(i-3)            ;                   (i-4)*(i-3) c ( 4 , 3 , 1 ) = - 433064005 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 1 ) = 85783846 9._RPP / 55440 0._RPP !                  (i-5)*(i-3) c ( 6 , 3 , 1 ) = - 346560749 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 1 ) = 0._RPP ; c ( 3 , 4 , 1 ) = 0._RPP !                  (i-3)*(i-4)            ;                   (i-4)*(i-4) c ( 4 , 4 , 1 ) = 5367868 3._RPP / 3696 0._RPP ; c ( 5 , 4 , 1 ) = - 693248065 7._RPP / 665280 0._RPP !                  (i-5)*(i-4) c ( 6 , 4 , 1 ) = 312671848 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 1 ) = 0._RPP ; c ( 3 , 5 , 1 ) = 0._RPP !                    /                    ;                   (i-5)*(i-5) c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 125000764 3._RPP / 665280 0._RPP !                  (i-6)*(i-5) c ( 6 , 5 , 1 ) = - 37747468 9._RPP / 665280 0._RPP !                    /                    ;                     / c ( 0 , 6 , 1 ) = 0._RPP ; c ( 1 , 6 , 1 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 1 ) = 0._RPP ; c ( 3 , 6 , 1 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 1 ) = 0._RPP ; c ( 5 , 6 , 1 ) = 0._RPP !                  (i-6)*(i-5) c ( 6 , 6 , 1 ) = 6436177 1._RPP / 1496880 0._RPP ! stencil 2 !                  (i+2)*i                ;                   (i+1)*i c ( 0 , 0 , 2 ) = 6436177 1._RPP / 1496880 0._RPP ; c ( 1 , 0 , 2 ) = - 29545598 3._RPP / 665280 0._RPP !                      i*i                ;                   (i-1)*i c ( 2 , 0 , 2 ) = 189470539 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 2 ) = - 161828432 3._RPP / 1496880 0._RPP !                  (i-2)*i                ;                   (i-3)*i c ( 4 , 0 , 2 ) = 11552405 3._RPP / 166320 0._RPP ; c ( 5 , 0 , 2 ) = - 9550813 9._RPP / 399168 0._RPP !                  (i-4)*i c ( 6 , 0 , 2 ) = 827947 9._RPP / 239500 8._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 80633841 7._RPP / 665280 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 2 ) = - 357379840 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 2 ) = 104253133 7._RPP / 166320 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 2 ) = - 272557531 7._RPP / 665280 0._RPP ; c ( 5 , 1 , 2 ) = 47532109 3._RPP / 332640 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 2 ) = - 1540162 9._RPP / 73920 0._RPP !                    /                    ;                    / c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 2 ) = 3418731 7._RPP / 5544 0._RPP ; c ( 3 , 2 , 2 ) = - 147661888 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 2 ) = 131211445 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 2 ) = - 77374943 9._RPP / 221760 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 2 ) = 25655684 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 2 ) = 0._RPP ; c ( 3 , 3 , 2 ) = 272658535 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 2 ) = - 41242402 9._RPP / 33264 0._RPP ; c ( 5 , 3 , 2 ) = 222453801 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 2 ) = - 99560072 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 2 ) = 0._RPP ; c ( 3 , 4 , 2 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 2 ) = 14327095 7._RPP / 33264 0._RPP ; c ( 5 , 4 , 2 ) = - 209657188 7._RPP / 665280 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 2 ) = 10570699 9._RPP / 221760 0._RPP !                    /                    ;                     / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 2 ) = 0._RPP ; c ( 3 , 5 , 2 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 13001356 3._RPP / 221760 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 2 ) = - 35932142 9._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 2 ) = 0._RPP ; c ( 1 , 6 , 2 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 2 ) = 0._RPP ; c ( 3 , 6 , 2 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 2 ) = 0._RPP ; c ( 5 , 6 , 2 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 2 ) = 262720 3._RPP / 187110 0._RPP ! stencil 3 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 3 ) = 262720 3._RPP / 187110 0._RPP ; c ( 1 , 0 , 3 ) = - 32333332 3._RPP / 1995840 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 3 ) = 76114296 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 3 ) = - 70156313 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 3 ) = 15854431 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 3 ) = - 22562395 3._RPP / 1995840 0._RPP !                  (i-3)*i c ( 6 , 0 , 3 ) = 9902265 7._RPP / 5987520 0._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 10844416 9._RPP / 221760 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 3 ) = - 17649851 3._RPP / 73920 0._RPP ; c ( 3 , 1 , 3 ) = 150694498 1._RPP / 498960 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 3 ) = - 46467836 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 3 ) = 8426374 9._RPP / 110880 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 3 ) = - 22562395 3._RPP / 1995840 0._RPP !                    /                    ;                    / c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 3 ) = 1679070 7._RPP / 5544 0._RPP ; c ( 3 , 2 , 3 ) = - 79053117 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 3 ) = 25052354 3._RPP / 44352 0._RPP ; c ( 5 , 2 , 3 ) = - 46467836 9._RPP / 221760 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 3 ) = 15854431 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 3 ) = 0._RPP ; c ( 3 , 3 , 3 ) = 160773916 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 3 ) = - 79053117 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 3 ) = 150694498 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 3 ) = - 70156313 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 3 ) = 0._RPP ; c ( 3 , 4 , 3 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 3 ) = 1679070 7._RPP / 5544 0._RPP ; c ( 5 , 4 , 3 ) = - 17649851 3._RPP / 73920 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 3 ) = 76114296 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 3 ) = 0._RPP ; c ( 3 , 5 , 3 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 10844416 9._RPP / 221760 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 3 ) = - 32333332 3._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 3 ) = 0._RPP ; c ( 1 , 6 , 3 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 3 ) = 0._RPP ; c ( 3 , 6 , 3 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 3 ) = 0._RPP ; c ( 5 , 6 , 3 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 3 ) = 262720 3._RPP / 187110 0._RPP ! stencil 4 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 4 ) = 262720 3._RPP / 187110 0._RPP ; c ( 1 , 0 , 4 ) = - 35932142 9._RPP / 1995840 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 4 ) = 10570699 9._RPP / 221760 0._RPP ; c ( 3 , 0 , 4 ) = - 99560072 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 4 ) = 25655684 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 4 ) = - 1540162 9._RPP / 73920 0._RPP !                  (i-3)*i c ( 6 , 0 , 4 ) = 827947 9._RPP / 239500 8._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 13001356 3._RPP / 221760 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 4 ) = - 209657188 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 4 ) = 222453801 1._RPP / 498960 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 4 ) = - 77374943 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 4 ) = 47532109 3._RPP / 332640 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 4 ) = - 9550813 9._RPP / 399168 0._RPP !                    /                    ;                    / c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 4 ) = 14327095 7._RPP / 33264 0._RPP ; c ( 3 , 2 , 4 ) = - 41242402 9._RPP / 33264 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 4 ) = 131211445 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 4 ) = - 272557531 7._RPP / 665280 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 4 ) = 11552405 3._RPP / 166320 0._RPP !                    /                    ;                     / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 4 ) = 0._RPP ; c ( 3 , 3 , 4 ) = 272658535 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 4 ) = - 147661888 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 4 ) = 104253133 7._RPP / 166320 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 4 ) = - 161828432 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 4 ) = 0._RPP ; c ( 3 , 4 , 4 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 4 ) = 3418731 7._RPP / 5544 0._RPP ; c ( 5 , 4 , 4 ) = - 357379840 7._RPP / 665280 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 4 ) = 189470539 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 4 ) = 0._RPP ; c ( 3 , 5 , 4 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 80633841 7._RPP / 665280 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 4 ) = - 29545598 3._RPP / 665280 0._RPP !                    /                    ;                     / c ( 0 , 6 , 4 ) = 0._RPP ; c ( 1 , 6 , 4 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 4 ) = 0._RPP ; c ( 3 , 6 , 4 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 4 ) = 0._RPP ; c ( 5 , 6 , 4 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 4 ) = 6436177 1._RPP / 1496880 0._RPP ! stencil 5 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 5 ) = 6436177 1._RPP / 1496880 0._RPP ; c ( 1 , 0 , 5 ) = - 37747468 9._RPP / 665280 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 5 ) = 312671848 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 5 ) = - 346560749 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 5 ) = 32078218 3._RPP / 166320 0._RPP ; c ( 5 , 0 , 5 ) = - 34191075 7._RPP / 399168 0._RPP !                  (i-3)*i c ( 6 , 0 , 5 ) = 94515532 9._RPP / 5987520 0._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 125000764 3._RPP / 665280 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 5 ) = - 693248065 7._RPP / 665280 0._RPP ; c ( 3 , 1 , 5 ) = 85783846 9._RPP / 55440 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 5 ) = - 861944098 7._RPP / 665280 0._RPP ; c ( 5 , 1 , 5 ) = 192403251 1._RPP / 332640 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 5 ) = - 71274560 3._RPP / 665280 0._RPP !                    /                    ;                    / c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 5 ) = 5367868 3._RPP / 3696 0._RPP ; c ( 3 , 2 , 5 ) = - 433064005 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 5 ) = 486808918 9._RPP / 133056 0._RPP ; c ( 5 , 2 , 5 ) = - 40538296 1._RPP / 24640 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 5 ) = 153130724 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 5 ) = 0._RPP ; c ( 3 , 3 , 5 ) = 978005716 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 5 ) = - 61641031 3._RPP / 11088 0._RPP ; c ( 5 , 3 , 5 ) = 1260100950 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 5 ) = - 712463825 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 5 ) = 0._RPP ; c ( 3 , 4 , 5 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 5 ) = 79635877 7._RPP / 33264 0._RPP ; c ( 5 , 4 , 5 ) = - 1468493305 7._RPP / 665280 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 5 ) = 281106706 7._RPP / 665280 0._RPP !                    /                    ;                     / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 5 ) = 0._RPP ; c ( 3 , 5 , 5 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 12794249 7._RPP / 24640 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 5 ) = - 407454478 7._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 5 ) = 0._RPP ; c ( 1 , 6 , 5 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 5 ) = 0._RPP ; c ( 3 , 6 , 5 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 5 ) = 0._RPP ; c ( 5 , 6 , 5 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 5 ) = 6291129 7._RPP / 299376 0._RPP ! stencil 6 !                  (i+3)*i                ;                   (i+2)*i c ( 0 , 0 , 6 ) = 6291129 7._RPP / 299376 0._RPP ; c ( 1 , 0 , 6 ) = - 555666927 7._RPP / 1995840 0._RPP !                  (i+1)*i                ;                       i*i c ( 2 , 0 , 6 ) = 1547692635 1._RPP / 1995840 0._RPP ; c ( 3 , 0 , 6 ) = - 1742503220 3._RPP / 1496880 0._RPP !                  (i-1)*i                ;                   (i-2)*i c ( 4 , 0 , 6 ) = 496477189 9._RPP / 498960 0._RPP ; c ( 5 , 0 , 6 ) = - 918196195 9._RPP / 1995840 0._RPP !                  (i-3)*i c ( 6 , 0 , 6 ) = 539152879 9._RPP / 5987520 0._RPP !                    /                    ;                   (i+1)*(i-1) c ( 0 , 1 , 6 ) = 0._RPP ; c ( 1 , 1 , 6 ) = 204794188 3._RPP / 221760 0._RPP !                      i*(i-1)            ;                   (i-1)*(i-1) c ( 2 , 1 , 6 ) = - 380943782 3._RPP / 73920 0._RPP ; c ( 3 , 1 , 6 ) = 3868338505 1._RPP / 498960 0._RPP !                  (i-2)*(i-1)            ;                   (i-3)*(i-1) c ( 4 , 1 , 6 ) = - 1473417899 9._RPP / 221760 0._RPP ; c ( 5 , 1 , 6 ) = 341705736 7._RPP / 110880 0._RPP !                  (i-4)*(i-1) c ( 6 , 1 , 6 ) = - 241688504 3._RPP / 399168 0._RPP !                    /                    ;                    / c ( 0 , 2 , 6 ) = 0._RPP ; c ( 1 , 2 , 6 ) = 0._RPP !                  i*(i-1)            ;                   (i-1)*(i-2) c ( 2 , 2 , 6 ) = 19973092 1._RPP / 2772 0._RPP ; c ( 3 , 2 , 6 ) = - 2169300276 7._RPP / 99792 0._RPP !                  (i-2)*(i-2)            ;                   (i-3)*(i-2) c ( 4 , 2 , 6 ) = 829077191 3._RPP / 44352 0._RPP ; c ( 5 , 2 , 6 ) = - 1930850567 9._RPP / 221760 0._RPP !                  (i-4)*(i-2) c ( 6 , 2 , 6 ) = 857930974 9._RPP / 498960 0._RPP !                    /                    ;                     / c ( 0 , 3 , 6 ) = 0._RPP ; c ( 1 , 3 , 6 ) = 0._RPP !                    /                    ;                   (i-1)*(i-3) c ( 2 , 3 , 6 ) = 0._RPP ; c ( 3 , 3 , 6 ) = 4925685991 9._RPP / 299376 0._RPP !                  (i-2)*(i-3)            ;                   (i-3)*(i-3) c ( 4 , 3 , 6 ) = - 2836489260 7._RPP / 99792 0._RPP ; c ( 5 , 3 , 6 ) = 6644004937 1._RPP / 498960 0._RPP !                  (i-4)*(i-3) c ( 6 , 3 , 6 ) = - 3964543964 3._RPP / 1496880 0._RPP !                    /                    ;                     / c ( 0 , 4 , 6 ) = 0._RPP ; c ( 1 , 4 , 6 ) = 0._RPP !                    /                    ;                     / c ( 2 , 4 , 6 ) = 0._RPP ; c ( 3 , 4 , 6 ) = 0._RPP !                  (i-2)*(i-4)            ;                   (i-3)*(i-4) c ( 4 , 4 , 6 ) = 136940474 9._RPP / 11088 0._RPP ; c ( 5 , 4 , 6 ) = - 862343162 3._RPP / 73920 0._RPP !                  (i-4)*(i-4) c ( 6 , 4 , 6 ) = 4680858363 1._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 5 , 6 ) = 0._RPP ; c ( 1 , 5 , 6 ) = 0._RPP !                    /                    ;                     / c ( 2 , 5 , 6 ) = 0._RPP ; c ( 3 , 5 , 6 ) = 0._RPP !                    /                    ;                   (i-3)*(i-5) c ( 4 , 5 , 6 ) = 0._RPP ; c ( 5 , 5 , 6 ) = 618261273 1._RPP / 221760 0._RPP !                  (i-4)*(i-5) c ( 6 , 5 , 6 ) = - 2276309235 7._RPP / 1995840 0._RPP !                    /                    ;                     / c ( 0 , 6 , 6 ) = 0._RPP ; c ( 1 , 6 , 6 ) = 0._RPP !                    /                    ;                     / c ( 2 , 6 , 6 ) = 0._RPP ; c ( 3 , 6 , 6 ) = 0._RPP !                    /                    ;                     / c ( 4 , 6 , 6 ) = 0._RPP ; c ( 5 , 6 , 6 ) = 0._RPP !                  (i-4)*(i-5) c ( 6 , 6 , 6 ) = 89720716 3._RPP / 748440 0._RPP case ( 8 ) ! 15th order ! stencil 0 !                    /                              ;                      / c ( 0 , 0 , 0 ) = 587078540679 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 0 ) = - 313071895443 1._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 2 , 0 , 0 ) = 3601963023845 3._RPP / 444787200 0._RPP ; c ( 3 , 0 , 0 ) = - 903077174440 9._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 0 ) = 702898716544 9._RPP / 69189120 0._RPP ; c ( 5 , 0 , 0 ) = - 526926040795 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 6 , 0 , 0 ) = 5052882299457 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 0 ) = - 81910049458 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 58179188140736 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 0 ) = - 18543240054934 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 0 ) = 42866891772828 1._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 0 ) = - 39330381673 9._RPP / 648648 0._RPP ; c ( 5 , 1 , 0 ) = 101073149489938 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 0 ) = - 1266152064402 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 0 ) = 3950906179212 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 0 ) = 127228075011819 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 0 ) = - 630647758453 9._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 4 , 2 , 0 ) = 98215049469830 9._RPP / 622702080 0._RPP ; c ( 5 , 2 , 0 ) = - 10992804980258 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 0 ) = 79532599772251 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 0 ) = - 647659119916 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 0 ) = 0._RPP ; c ( 3 , 3 , 0 ) = 589638297742 3._RPP / 4528742 4._RPP !                    /                              ;                      / c ( 4 , 3 , 0 ) = - 3599923347105 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 0 ) = 77576024915482 7._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 0 ) = - 488268892477 7._RPP / 12972960 0._RPP ; c ( 7 , 3 , 0 ) = 1019671679701 3._RPP / 207567360 0._RPP !                    /                              ;                      / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 0 ) = 0._RPP ; c ( 3 , 4 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 0 ) = 2331542417837 3._RPP / 22643712 0._RPP ; c ( 5 , 4 , 0 ) = - 98349292735 9._RPP / 884520 0._RPP !                    /                              ;                      / c ( 6 , 4 , 0 ) = 4191014000477 9._RPP / 124540416 0._RPP ; c ( 7 , 4 , 0 ) = - 342379815619 3._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 0 ) = 0._RPP ; c ( 3 , 5 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 62417743633026 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 0 ) = - 7094431059310 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 0 ) = 1061058110012 3._RPP / 444787200 0._RPP !                    /                              ;                      / c ( 0 , 6 , 0 ) = 0._RPP ; c ( 1 , 6 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 0 ) = 0._RPP ; c ( 3 , 6 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 0 ) = 0._RPP ; c ( 5 , 6 , 0 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 0 ) = 17222970865763 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 0 ) = - 141010670914 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 7 , 0 ) = 0._RPP ; c ( 1 , 7 , 0 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 0 ) = 0._RPP ; c ( 3 , 7 , 0 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 0 ) = 0._RPP ; c ( 5 , 7 , 0 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 0 ) = 0._RPP ; c ( 7 , 7 , 0 ) = 98600509638 7._RPP / 2075673600 0._RPP ! stencil 1 !                    /                              ;                      / c ( 0 , 0 , 1 ) = 98600509638 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 1 ) = - 106945739728 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 2 , 0 , 1 ) = 4331536630438 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 1 ) = - 155058492516 1._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 1 ) = 72147091048 1._RPP / 41513472 0._RPP ; c ( 5 , 0 , 1 ) = - 179355812158 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 6 , 0 , 1 ) = 122148005652 1._RPP / 444787200 0._RPP ; c ( 7 , 0 , 1 ) = - 13780187086 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 10208047141955 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 1 ) = - 3290342827366 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 1 ) = 7627351322914 3._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 1 ) = - 139757141290 1._RPP / 12972960 0._RPP ; c ( 5 , 1 , 1 ) = 17892284043259 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 1 ) = - 223086272634 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 1 ) = 692571107649 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 1 ) = 22945613591682 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 1 ) = - 1145007795 7._RPP / 35380 8._RPP !                    /                              ;                      / c ( 4 , 2 , 1 ) = 17855983504052 3._RPP / 622702080 0._RPP ; c ( 5 , 2 , 1 ) = - 1995270410234 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 1 ) = 14388785579794 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 1 ) = - 58348813105 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 1 ) = 0._RPP ; c ( 3 , 3 , 1 ) = 540773370278 9._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 1 ) = - 663047977677 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 1 ) = 14295096719597 3._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 1 ) = - 22456304186 9._RPP / 3243240 0._RPP ; c ( 7 , 3 , 1 ) = 4156675907 9._RPP / 4612608 0._RPP !                    /                              ;                      / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 1 ) = 0._RPP ; c ( 3 , 4 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 1 ) = 432253177133 9._RPP / 22643712 0._RPP ; c ( 5 , 4 , 1 ) = - 2924498549 5._RPP / 141523 2._RPP !                    /                              ;                      / c ( 6 , 4 , 1 ) = 3894108374479 3._RPP / 622702080 0._RPP ; c ( 7 , 4 , 1 ) = - 9074419282 3._RPP / 11119680 0._RPP !                    /                              ;                      / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 1 ) = 0._RPP ; c ( 3 , 5 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 11648728537227 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 1 ) = - 1325766894046 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 1 ) = 1387332828613 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 1 ) = 0._RPP ; c ( 1 , 6 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 1 ) = 0._RPP ; c ( 3 , 6 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 1 ) = 0._RPP ; c ( 5 , 6 , 1 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 1 ) = 3226850444480 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 1 ) = - 13217381913 1._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 0 , 7 , 1 ) = 0._RPP ; c ( 1 , 7 , 1 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 1 ) = 0._RPP ; c ( 3 , 7 , 1 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 1 ) = 0._RPP ; c ( 5 , 7 , 1 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 1 ) = 0._RPP ; c ( 7 , 7 , 1 ) = 2644617249 1._RPP / 296524800 0._RPP ! stencil 2 !                    /                              ;                      / c ( 0 , 0 , 2 ) = 2644617249 1._RPP / 296524800 0._RPP ; c ( 1 , 0 , 2 ) = - 10439193786 1._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 2 , 0 , 2 ) = 862463834821 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 2 ) = - 31072696639 3._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 2 ) = 72122074556 3._RPP / 207567360 0._RPP ; c ( 5 , 0 , 2 ) = - 2541216454 9._RPP / 13899600 0._RPP !                    /                              ;                      / c ( 6 , 0 , 2 ) = 167702113857 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 2 ) = - 2667434578 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 2086303164608 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 2 ) = - 690510075850 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 2 ) = 324051029606 9._RPP / 124540416 0._RPP !                    /                              ;                      / c ( 4 , 1 , 2 ) = - 3718793686 9._RPP / 1621620 0._RPP ; c ( 5 , 1 , 2 ) = 3791367900946 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 2 ) = - 46856166582 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 2 ) = 143819879052 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 2 ) = 4988347834251 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 2 ) = - 25386569121 1._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 4 , 2 , 2 ) = 3989610078547 7._RPP / 622702080 0._RPP ; c ( 5 , 2 , 2 ) = - 445676728598 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 2 ) = 3195952217083 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 2 ) = - 25687939228 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 2 ) = 0._RPP ; c ( 3 , 3 , 2 ) = 123194938772 3._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 2 ) = - 153209436465 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 2 ) = 3319172729165 9._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 2 ) = - 4164393066 1._RPP / 2594592 0._RPP ; c ( 7 , 3 , 2 ) = 43100007739 7._RPP / 207567360 0._RPP !                    /                              ;                      / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 2 ) = 0._RPP ; c ( 3 , 4 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 2 ) = 20391213427 3._RPP / 4528742 4._RPP ; c ( 5 , 4 , 2 ) = - 544514212 7._RPP / 110565 0._RPP !                    /                              ;                      / c ( 6 , 4 , 2 ) = 930691381743 1._RPP / 622702080 0._RPP ; c ( 7 , 4 , 2 ) = - 15144137020 9._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 2 ) = 0._RPP ; c ( 3 , 5 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 2819916191874 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 2 ) = - 323354911474 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 2 ) = 338853371302 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 2 ) = 0._RPP ; c ( 1 , 6 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 2 ) = 0._RPP ; c ( 3 , 6 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 2 ) = 0._RPP ; c ( 5 , 6 , 2 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 2 ) = 796525598531 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 2 ) = - 6561116818 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 7 , 2 ) = 0._RPP ; c ( 1 , 7 , 2 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 2 ) = 0._RPP ; c ( 3 , 7 , 2 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 2 ) = 0._RPP ; c ( 5 , 7 , 2 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 2 ) = 0._RPP ; c ( 7 , 7 , 2 ) = 4638829254 7._RPP / 2075673600 0._RPP ! stencil 3 !                    /                              ;                      / c ( 0 , 0 , 3 ) = 4638829254 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 3 ) = - 5624526592 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 2 , 0 , 3 ) = 245841778342 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 3 ) = - 1841581435 7._RPP / 15567552 0._RPP !                    /                              ;                      / c ( 4 , 0 , 3 ) = 7281200608 7._RPP / 69189120 0._RPP ; c ( 5 , 0 , 3 ) = - 10847364622 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 6 , 0 , 3 ) = 50808286092 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 3 ) = - 794254126 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 604760553059 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 3 ) = - 212910385282 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 3 ) = 522796688136 7._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 3 ) = - 9876569669 3._RPP / 12972960 0._RPP ; c ( 5 , 1 , 3 ) = 1275283098715 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 3 ) = - 15758059542 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 3 ) = 47818564929 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 3 ) = 1647638781570 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 3 ) = - 552771549 7._RPP / 221130 0._RPP !                    /                              ;                      / c ( 4 , 2 , 3 ) = 1441639394689 1._RPP / 622702080 0._RPP ; c ( 5 , 2 , 3 ) = - 164407916774 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 3 ) = 1187043298066 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 3 ) = - 4746934060 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 3 ) = 0._RPP ; c ( 3 , 3 , 3 ) = 45724952851 7._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 3 ) = - 59591572125 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 3 ) = 53207164366 1._RPP / 24908083 2._RPP !                    /                              ;                      / c ( 6 , 3 , 3 ) = - 1059014965 3._RPP / 1621620 0._RPP ; c ( 7 , 3 , 3 ) = 2511636615 7._RPP / 29652480 0._RPP !                    /                              ;                      / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 3 ) = 0._RPP ; c ( 3 , 4 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 3 ) = 42034116193 1._RPP / 22643712 0._RPP ; c ( 5 , 4 , 3 ) = - 7485146782 3._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 6 , 4 , 3 ) = 410088084328 9._RPP / 622702080 0._RPP ; c ( 7 , 4 , 3 ) = - 6751326537 7._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 3 ) = 0._RPP ; c ( 3 , 5 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 1278096745707 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 3 ) = - 152168848426 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 3 ) = 163158910789 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 3 ) = 0._RPP ; c ( 1 , 6 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 3 ) = 0._RPP ; c ( 3 , 6 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 3 ) = 0._RPP ; c ( 5 , 6 , 3 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 3 ) = 394486189760 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 3 ) = - 240737704 3._RPP / 13899600 0._RPP !                    /                              ;                      / c ( 0 , 7 , 3 ) = 0._RPP ; c ( 1 , 7 , 3 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 3 ) = 0._RPP ; c ( 3 , 7 , 3 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 3 ) = 0._RPP ; c ( 5 , 7 , 3 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 3 ) = 0._RPP ; c ( 7 , 7 , 3 ) = 2511636615 7._RPP / 2075673600 0._RPP ! stencil 4 !                    /                              ;                      / c ( 0 , 0 , 4 ) = 2511636615 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 4 ) = - 240737704 3._RPP / 13899600 0._RPP !                    /                              ;                      / c ( 2 , 0 , 4 ) = 163158910789 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 4 ) = - 6751326537 7._RPP / 77837760 0._RPP !                    /                              ;                      / c ( 4 , 0 , 4 ) = 2511636615 7._RPP / 29652480 0._RPP ; c ( 5 , 0 , 4 ) = - 4746934060 3._RPP / 97297200 0._RPP !                    /                              ;                      / c ( 6 , 0 , 4 ) = 47818564929 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 4 ) = - 794254126 7._RPP / 389188800 0._RPP !                    /                              ;                      / c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 394486189760 9._RPP / 6227020800 0._RPP !                    /                              ;                      / c ( 2 , 1 , 4 ) = - 152168848426 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 4 ) = 410088084328 9._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 4 , 1 , 4 ) = - 1059014965 3._RPP / 1621620 0._RPP ; c ( 5 , 1 , 4 ) = 1187043298066 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 6 , 1 , 4 ) = - 15758059542 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 4 ) = 50808286092 7._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 2 , 4 ) = 1278096745707 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 4 ) = - 7485146782 3._RPP / 3538080 0._RPP !                    /                              ;                      / c ( 4 , 2 , 4 ) = 53207164366 1._RPP / 24908083 2._RPP ; c ( 5 , 2 , 4 ) = - 164407916774 9._RPP / 129729600 0._RPP !                    /                              ;                      / c ( 6 , 2 , 4 ) = 1275283098715 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 4 ) = - 10847364622 1._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 3 , 4 ) = 0._RPP ; c ( 3 , 3 , 4 ) = 42034116193 1._RPP / 22643712 0._RPP !                    /                              ;                      / c ( 4 , 3 , 4 ) = - 59591572125 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 4 ) = 1441639394689 1._RPP / 622702080 0._RPP !                    /                              ;                      / c ( 6 , 3 , 4 ) = - 9876569669 3._RPP / 12972960 0._RPP ; c ( 7 , 3 , 4 ) = 7281200608 7._RPP / 69189120 0._RPP !                    /                              ;                      / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 4 , 4 ) = 0._RPP ; c ( 3 , 4 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 4 , 4 ) = 45724952851 7._RPP / 22643712 0._RPP ; c ( 5 , 4 , 4 ) = - 552771549 7._RPP / 221130 0._RPP !                    /                              ;                      / c ( 6 , 4 , 4 ) = 522796688136 7._RPP / 622702080 0._RPP ; c ( 7 , 4 , 4 ) = - 1841581435 7._RPP / 15567552 0._RPP !                    /                              ;                      / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 5 , 4 ) = 0._RPP ; c ( 3 , 5 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 1647638781570 7._RPP / 2075673600 0._RPP !                    /                              ;                      / c ( 6 , 5 , 4 ) = - 212910385282 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 4 ) = 245841778342 1._RPP / 3113510400 0._RPP !                    /                              ;                      / c ( 0 , 6 , 4 ) = 0._RPP ; c ( 1 , 6 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 6 , 4 ) = 0._RPP ; c ( 3 , 6 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 6 , 4 ) = 0._RPP ; c ( 5 , 6 , 4 ) = 0._RPP !                    /                              ;                      / c ( 6 , 6 , 4 ) = 604760553059 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 4 ) = - 5624526592 7._RPP / 194594400 0._RPP !                    /                              ;                      / c ( 0 , 7 , 4 ) = 0._RPP ; c ( 1 , 7 , 4 ) = 0._RPP !                    /                              ;                      / c ( 2 , 7 , 4 ) = 0._RPP ; c ( 3 , 7 , 4 ) = 0._RPP !                    /                              ;                      / c ( 4 , 7 , 4 ) = 0._RPP ; c ( 5 , 7 , 4 ) = 0._RPP !                    /                              ;                      / c ( 6 , 7 , 4 ) = 0._RPP ; c ( 7 , 7 , 4 ) = 4638829254 7._RPP / 2075673600 0._RPP ! stencil 5 !                    /                              ;                     / c ( 0 , 0 , 5 ) = 4638829254 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 5 ) = - 6561116818 7._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 2 , 0 , 5 ) = 338853371302 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 5 ) = - 15144137020 9._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 4 , 0 , 5 ) = 43100007739 7._RPP / 207567360 0._RPP ; c ( 5 , 0 , 5 ) = - 25687939228 1._RPP / 194594400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 0 , 5 ) = 143819879052 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 5 ) = - 2667434578 7._RPP / 389188800 0._RPP !                    /                              ;                     / c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 796525598531 9._RPP / 6227020800 0._RPP !                    /                              ;                     / c ( 2 , 1 , 5 ) = - 323354911474 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 5 ) = 930691381743 1._RPP / 622702080 0._RPP !                    /                              ;                     / c ( 4 , 1 , 5 ) = - 4164393066 1._RPP / 2594592 0._RPP ; c ( 5 , 1 , 5 ) = 3195952217083 7._RPP / 3113510400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 1 , 5 ) = - 46856166582 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 5 ) = 167702113857 7._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 2 , 5 ) = 2819916191874 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 5 ) = - 544514212 7._RPP / 110565 0._RPP !                    /                              ;                     / c ( 4 , 2 , 5 ) = 3319172729165 9._RPP / 622702080 0._RPP ; c ( 5 , 2 , 5 ) = - 445676728598 9._RPP / 129729600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 2 , 5 ) = 3791367900946 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 5 ) = - 2541216454 9._RPP / 13899600 0._RPP !                    /                              ;                     / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 3 , 5 ) = 0._RPP ; c ( 3 , 3 , 5 ) = 20391213427 3._RPP / 4528742 4._RPP !                    /                              ;                     / c ( 4 , 3 , 5 ) = - 153209436465 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 5 ) = 3989610078547 7._RPP / 622702080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 3 , 5 ) = - 3718793686 9._RPP / 1621620 0._RPP ; c ( 7 , 3 , 5 ) = 72122074556 3._RPP / 207567360 0._RPP !                    /                              ;                     / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 4 , 5 ) = 0._RPP ; c ( 3 , 4 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 4 , 5 ) = 123194938772 3._RPP / 22643712 0._RPP ; c ( 5 , 4 , 5 ) = - 25386569121 1._RPP / 3538080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 4 , 5 ) = 324051029606 9._RPP / 124540416 0._RPP ; c ( 7 , 4 , 5 ) = - 31072696639 3._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 5 , 5 ) = 0._RPP ; c ( 3 , 5 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 4988347834251 7._RPP / 2075673600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 5 , 5 ) = - 690510075850 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 5 ) = 862463834821 1._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 6 , 5 ) = 0._RPP ; c ( 1 , 6 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 6 , 5 ) = 0._RPP ; c ( 3 , 6 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 6 , 5 ) = 0._RPP ; c ( 5 , 6 , 5 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 6 , 5 ) = 2086303164608 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 5 ) = - 10439193786 1._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 0 , 7 , 5 ) = 0._RPP ; c ( 1 , 7 , 5 ) = 0._RPP !                    /                              ;                     / c ( 2 , 7 , 5 ) = 0._RPP ; c ( 3 , 7 , 5 ) = 0._RPP !                    /                              ;                     / c ( 4 , 7 , 5 ) = 0._RPP ; c ( 5 , 7 , 5 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 7 , 5 ) = 0._RPP ; c ( 7 , 7 , 5 ) = 2644617249 1._RPP / 296524800 0._RPP ! stencil 6 !                    /                              ;                     / c ( 0 , 0 , 6 ) = 2644617249 1._RPP / 296524800 0._RPP ; c ( 1 , 0 , 6 ) = - 13217381913 1._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 2 , 0 , 6 ) = 1387332828613 1._RPP / 3113510400 0._RPP ; c ( 3 , 0 , 6 ) = - 9074419282 3._RPP / 11119680 0._RPP !                    /                              ;                     / c ( 4 , 0 , 6 ) = 4156675907 9._RPP / 4612608 0._RPP ; c ( 5 , 0 , 6 ) = - 58348813105 3._RPP / 97297200 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 0 , 6 ) = 692571107649 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 6 ) = - 13780187086 7._RPP / 389188800 0._RPP !                    /                              ;                     / c ( 0 , 1 , 6 ) = 0._RPP ; c ( 1 , 1 , 6 ) = 3226850444480 9._RPP / 6227020800 0._RPP !                    /                              ;                     / c ( 2 , 1 , 6 ) = - 1325766894046 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 6 ) = 3894108374479 3._RPP / 622702080 0._RPP !                    /                              ;                     / c ( 4 , 1 , 6 ) = - 22456304186 9._RPP / 3243240 0._RPP ; c ( 5 , 1 , 6 ) = 14388785579794 7._RPP / 3113510400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 1 , 6 ) = - 223086272634 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 6 ) = 122148005652 1._RPP / 444787200 0._RPP !                    /                              ;                     / c ( 0 , 2 , 6 ) = 0._RPP ; c ( 1 , 2 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 2 , 6 ) = 11648728537227 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 6 ) = - 2924498549 5._RPP / 141523 2._RPP !                    /                              ;                     / c ( 4 , 2 , 6 ) = 14295096719597 3._RPP / 622702080 0._RPP ; c ( 5 , 2 , 6 ) = - 1995270410234 9._RPP / 129729600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 2 , 6 ) = 17892284043259 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 6 ) = - 179355812158 1._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 0 , 3 , 6 ) = 0._RPP ; c ( 1 , 3 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 3 , 6 ) = 0._RPP ; c ( 3 , 3 , 6 ) = 432253177133 9._RPP / 22643712 0._RPP !                    /                              ;                     / c ( 4 , 3 , 6 ) = - 663047977677 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 6 ) = 17855983504052 3._RPP / 622702080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 3 , 6 ) = - 139757141290 1._RPP / 12972960 0._RPP ; c ( 7 , 3 , 6 ) = 72147091048 1._RPP / 41513472 0._RPP !                    /                              ;                     / c ( 0 , 4 , 6 ) = 0._RPP ; c ( 1 , 4 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 4 , 6 ) = 0._RPP ; c ( 3 , 4 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 4 , 6 ) = 540773370278 9._RPP / 22643712 0._RPP ; c ( 5 , 4 , 6 ) = - 1145007795 7._RPP / 35380 8._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 4 , 6 ) = 7627351322914 3._RPP / 622702080 0._RPP ; c ( 7 , 4 , 6 ) = - 155058492516 1._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 0 , 5 , 6 ) = 0._RPP ; c ( 1 , 5 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 5 , 6 ) = 0._RPP ; c ( 3 , 5 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 5 , 6 ) = 0._RPP ; c ( 5 , 5 , 6 ) = 22945613591682 7._RPP / 2075673600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 5 , 6 ) = - 3290342827366 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 6 ) = 4331536630438 1._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 6 , 6 ) = 0._RPP ; c ( 1 , 6 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 6 , 6 ) = 0._RPP ; c ( 3 , 6 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 6 , 6 ) = 0._RPP ; c ( 5 , 6 , 6 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 6 , 6 ) = 10208047141955 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 6 ) = - 106945739728 7._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 0 , 7 , 6 ) = 0._RPP ; c ( 1 , 7 , 6 ) = 0._RPP !                    /                              ;                     / c ( 2 , 7 , 6 ) = 0._RPP ; c ( 3 , 7 , 6 ) = 0._RPP !                    /                              ;                     / c ( 4 , 7 , 6 ) = 0._RPP ; c ( 5 , 7 , 6 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 7 , 6 ) = 0._RPP ; c ( 7 , 7 , 6 ) = 98600509638 7._RPP / 2075673600 0._RPP ! stencil 7 !                    /                              ;                     / c ( 0 , 0 , 7 ) = 98600509638 7._RPP / 2075673600 0._RPP ; c ( 1 , 0 , 7 ) = - 141010670914 7._RPP / 194594400 0._RPP !                    /                              ;                     / c ( 2 , 0 , 7 ) = 1061058110012 3._RPP / 444787200 0._RPP ; c ( 3 , 0 , 7 ) = - 342379815619 3._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 4 , 0 , 7 ) = 1019671679701 3._RPP / 207567360 0._RPP ; c ( 5 , 0 , 7 ) = - 647659119916 1._RPP / 194594400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 0 , 7 ) = 3950906179212 7._RPP / 3113510400 0._RPP ; c ( 7 , 0 , 7 ) = - 81910049458 7._RPP / 389188800 0._RPP !                    /                              ;                     / c ( 0 , 1 , 7 ) = 0._RPP ; c ( 1 , 1 , 7 ) = 17222970865763 9._RPP / 6227020800 0._RPP !                    /                              ;                     / c ( 2 , 1 , 7 ) = - 7094431059310 9._RPP / 389188800 0._RPP ; c ( 3 , 1 , 7 ) = 4191014000477 9._RPP / 124540416 0._RPP !                    /                              ;                     / c ( 4 , 1 , 7 ) = - 488268892477 7._RPP / 12972960 0._RPP ; c ( 5 , 1 , 7 ) = 79532599772251 7._RPP / 3113510400 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 1 , 7 ) = - 1266152064402 1._RPP / 129729600 0._RPP ; c ( 7 , 1 , 7 ) = 5052882299457 7._RPP / 3113510400 0._RPP !                    /                              ;                     / c ( 0 , 2 , 7 ) = 0._RPP ; c ( 1 , 2 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 2 , 7 ) = 62417743633026 7._RPP / 2075673600 0._RPP ; c ( 3 , 2 , 7 ) = - 98349292735 9._RPP / 884520 0._RPP !                    /                              ;                     / c ( 4 , 2 , 7 ) = 77576024915482 7._RPP / 622702080 0._RPP ; c ( 5 , 2 , 7 ) = - 10992804980258 9._RPP / 129729600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 2 , 7 ) = 101073149489938 7._RPP / 3113510400 0._RPP ; c ( 7 , 2 , 7 ) = - 526926040795 3._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 0 , 3 , 7 ) = 0._RPP ; c ( 1 , 3 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 3 , 7 ) = 0._RPP ; c ( 3 , 3 , 7 ) = 2331542417837 3._RPP / 22643712 0._RPP !                    /                              ;                     / c ( 4 , 3 , 7 ) = - 3599923347105 1._RPP / 15567552 0._RPP ; c ( 5 , 3 , 7 ) = 98215049469830 9._RPP / 622702080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 3 , 7 ) = - 39330381673 9._RPP / 648648 0._RPP ; c ( 7 , 3 , 7 ) = 702898716544 9._RPP / 69189120 0._RPP !                    /                              ;                     / c ( 0 , 4 , 7 ) = 0._RPP ; c ( 1 , 4 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 4 , 7 ) = 0._RPP ; c ( 3 , 4 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 4 , 7 ) = 589638297742 3._RPP / 4528742 4._RPP ; c ( 5 , 4 , 7 ) = - 630647758453 9._RPP / 3538080 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 4 , 7 ) = 42866891772828 1._RPP / 622702080 0._RPP ; c ( 7 , 4 , 7 ) = - 903077174440 9._RPP / 77837760 0._RPP !                    /                              ;                     / c ( 0 , 5 , 7 ) = 0._RPP ; c ( 1 , 5 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 5 , 7 ) = 0._RPP ; c ( 3 , 5 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 5 , 7 ) = 0._RPP ; c ( 5 , 5 , 7 ) = 127228075011819 7._RPP / 2075673600 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 5 , 7 ) = - 18543240054934 9._RPP / 389188800 0._RPP ; c ( 7 , 5 , 7 ) = 3601963023845 3._RPP / 444787200 0._RPP !                    /                              ;                     / c ( 0 , 6 , 7 ) = 0._RPP ; c ( 1 , 6 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 6 , 7 ) = 0._RPP ; c ( 3 , 6 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 6 , 7 ) = 0._RPP ; c ( 5 , 6 , 7 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 6 , 7 ) = 58179188140736 9._RPP / 6227020800 0._RPP ; c ( 7 , 6 , 7 ) = - 313071895443 1._RPP / 97297200 0._RPP !                    /                              ;                     / c ( 0 , 7 , 7 ) = 0._RPP ; c ( 1 , 7 , 7 ) = 0._RPP !                    /                              ;                     / c ( 2 , 7 , 7 ) = 0._RPP ; c ( 3 , 7 , 7 ) = 0._RPP !                    /                              ;                     / c ( 4 , 7 , 7 ) = 0._RPP ; c ( 5 , 7 , 7 ) = 0._RPP !                  (i-4)*(i-5)                      ; c ( 6 , 7 , 7 ) = 0._RPP ; c ( 7 , 7 , 7 ) = 587078540679 7._RPP / 2075673600 0._RPP case ( 9 ) ! 17th order ! stencil 0 !                    /                               ;                     / c ( 0 , 0 , 0 ) = 10947113933269 9._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 0 ) = - 89462836442080 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 0 ) = 3470956782876598 9._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 0 ) = - 1208363205553750 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 4 , 0 , 0 ) = 53423709511790 3._RPP / 1046139494 4._RPP ; c ( 5 , 0 , 0 ) = - 4784134214198129 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 0 ) = 2164462807751548 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 0 ) = - 564439940024630 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 0 ) = 12973990640860 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 0 ) = 0._RPP ; c ( 1 , 1 , 0 ) = 560275323330565 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 2 , 1 , 0 ) = - 5911141295073430 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 0 ) = 20717808425886056 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 0 ) = - 4602038409035702 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 0 ) = 16544517891672647 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 0 ) = - 3753103645304716 1._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 0 ) = 13718972102530 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 0 ) = - 451752457452509 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 0 ) = 0._RPP ; c ( 1 , 2 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 0 ) = 466071217217893 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 0 ) = - 4514872822425481 7._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 0 ) = 22878692017843 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 0 ) = - 3629458001216861 3._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 0 ) = 3300852708223699 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 0 ) = - 3025005282549752 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 0 ) = 1395244392999561 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 0 ) = 0._RPP ; c ( 1 , 3 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 0 ) = 0._RPP ; c ( 3 , 3 , 0 ) = 15964677371155834 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 0 ) = - 714007473389985 1._RPP / 373621248 0._RPP ; c ( 5 , 3 , 0 ) = 2580251345869183 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 0 ) = - 2938718777174794 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 0 ) = 10788739048624814 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 0 ) = - 2491175852975000 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 0 ) = 0._RPP ; c ( 1 , 4 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 0 ) = 0._RPP ; c ( 3 , 4 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 0 ) = 800187970376734 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 0 ) = - 579411902443348 3._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 0 ) = 15020534732683 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 0 ) = - 2429347143458870 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 0 ) = 112305878501505 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 5 , 0 ) = 0._RPP ; c ( 1 , 5 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 0 ) = 0._RPP ; c ( 3 , 5 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 0 ) = 0._RPP ; c ( 5 , 5 , 0 ) = 10504573010955745 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 0 ) = - 2399374389255760 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 0 ) = 8828714974335541 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 0 ) = - 81699003745448 3._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 6 , 0 ) = 0._RPP ; c ( 1 , 6 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 0 ) = 0._RPP ; c ( 3 , 6 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 0 ) = 0._RPP ; c ( 5 , 6 , 0 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 0 ) = 199495274192793 1._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 0 ) = - 2020412537734006 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 0 ) = 935506490307805 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 0 ) = 0._RPP ; c ( 1 , 7 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 0 ) = 0._RPP ; c ( 3 , 7 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 0 ) = 0._RPP ; c ( 5 , 7 , 0 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 0 ) = 0._RPP ; c ( 7 , 7 , 0 ) = 1063735481545661 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 0 ) = - 18955567275961 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 0 ) = 0._RPP ; c ( 1 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 0 ) = 0._RPP ; c ( 3 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 0 ) = 0._RPP ; c ( 5 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 0 ) = 0._RPP ; c ( 7 , 8 , 0 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 0 ) = 1784873725120 3._RPP / 16345929600 0._RPP ! stencil 1 !                    /                               ;                     / c ( 0 , 0 , 1 ) = 1784873725120 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 1 ) = - 14780912554847 9._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 1 ) = 115266961643356 7._RPP / 26153487360 0._RPP ; c ( 3 , 0 , 1 ) = - 1003625893562122 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 1 ) = 221425915373504 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 1 ) = - 790658467304897 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 1 ) = 356395192925475 7._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 1 ) = - 740646202891 9._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 8 , 0 , 1 ) = 10599441829821 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 1 ) = 0._RPP ; c ( 1 , 1 , 1 ) = 660345506505409 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 1 ) = - 1003677958085818 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 1 ) = 3527256877887227 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 1 ) = - 783236811583460 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 1 ) = 2810137895488000 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 1 ) = - 635653720341542 3._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 1 ) = 2315984163112 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 1 ) = - 76005337654316 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 1 ) = 0._RPP ; c ( 1 , 2 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 1 ) = 80057267234686 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 1 ) = - 779567532947119 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 1 ) = 3956407788958 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 1 ) = - 125451994816551 1._RPP / 934053120 0._RPP !                    /                               ;                     / c ( 6 , 2 , 1 ) = 569432593046545 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 1 ) = - 520558506485519 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 1 ) = 239433810124813 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 1 ) = 0._RPP ; c ( 1 , 3 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 1 ) = 0._RPP ; c ( 3 , 3 , 1 ) = 2777072392772198 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 1 ) = - 623064713812012 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 1 ) = 2253375754684385 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 1 ) = - 512910400994605 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 1 ) = 1879962448756268 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 1 ) = - 433174706907934 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 1 ) = 0._RPP ; c ( 1 , 4 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 1 ) = 0._RPP ; c ( 3 , 4 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 1 ) = 140330435447542 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 1 ) = - 509106072743740 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 1 ) = 2640359881420 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 1 ) = - 426697274934164 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 1 ) = 98485018206416 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 1 ) = 0._RPP ; c ( 1 , 5 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 1 ) = 0._RPP ; c ( 3 , 5 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 1 ) = 0._RPP ; c ( 5 , 5 , 1 ) = 1851802802323795 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 1 ) = - 423486261093611 9._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 1 ) = 311638099752196 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 5 , 1 ) = - 360178442307514 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 1 ) = 0._RPP ; c ( 1 , 6 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 1 ) = 0._RPP ; c ( 3 , 6 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 1 ) = 0._RPP ; c ( 5 , 6 , 1 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 1 ) = 35281236971941 3._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 1 ) = - 357541164655690 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 1 ) = 165507219650188 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 1 ) = 0._RPP ; c ( 1 , 7 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 1 ) = 0._RPP ; c ( 3 , 7 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 1 ) = 0._RPP ; c ( 5 , 7 , 1 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 1 ) = 0._RPP ; c ( 7 , 7 , 1 ) = 26924749115906 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 8 , 7 , 1 ) = - 3359357233795 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 1 ) = 0._RPP ; c ( 1 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 1 ) = 0._RPP ; c ( 3 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 1 ) = 0._RPP ; c ( 5 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 1 ) = 0._RPP ; c ( 7 , 8 , 1 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 1 ) = 316535517012 1._RPP / 16345929600 0._RPP ! stencil 2 !                    /                               ;                     / c ( 0 , 0 , 2 ) = 316535517012 1._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 2 ) = - 384413984834 3._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 2 , 0 , 2 ) = 106319120144653 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 2 ) = - 185989924739449 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 2 ) = 40992179077691 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 2 ) = - 145710511264309 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 2 ) = 65245292556748 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 2 ) = - 16817238148781 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 2 ) = 1909470410406 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 2 ) = 0._RPP ; c ( 1 , 1 , 2 ) = 123999028356413 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 2 ) = - 191861009660335 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 2 ) = 135989101716685 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 4 , 1 , 2 ) = - 151274428150079 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 2 ) = 541497253844423 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 2 ) = - 121878246652664 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 2 ) = 441155351017 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 2 ) = - 574841303470 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 2 , 2 ) = 0._RPP ; c ( 1 , 2 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 2 ) = 15662254432876 3._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 2 ) = - 154496455714316 9._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 2 ) = 788382052810 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 2 ) = - 125045499175210 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 2 ) = 113189854289740 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 2 ) = - 102960824791727 3._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 2 ) = 47064366535890 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 2 ) = 0._RPP ; c ( 1 , 3 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 2 ) = 0._RPP ; c ( 3 , 3 , 2 ) = 559966627269370 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 2 ) = - 126799229420335 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 2 ) = 460178203604450 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 2 ) = - 20938884275712 1._RPP / 934053120 0._RPP ; c ( 7 , 3 , 2 ) = 382543571327995 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 2 ) = - 87725249292872 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 2 ) = 0._RPP ; c ( 1 , 4 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 2 ) = 0._RPP ; c ( 3 , 4 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 2 ) = 28925923563877 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 2 ) = - 105629161653487 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 2 ) = 548943514198 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 2 ) = - 88617378590975 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 2 ) = 20389161410459 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 2 ) = 0._RPP ; c ( 1 , 5 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 2 ) = 0._RPP ; c ( 3 , 5 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 2 ) = 0._RPP ; c ( 5 , 5 , 2 ) = 387829668278573 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 2 ) = - 89093725268464 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 2 ) = 328142799572072 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 2 ) = - 75740201764057 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 2 ) = 0._RPP ; c ( 1 , 6 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 2 ) = 0._RPP ; c ( 3 , 6 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 2 ) = 0._RPP ; c ( 5 , 6 , 2 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 2 ) = 7473082165381 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 2 ) = - 75959848012063 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 2 ) = 7034106245689 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 7 , 2 ) = 0._RPP ; c ( 1 , 7 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 2 ) = 0._RPP ; c ( 3 , 7 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 2 ) = 0._RPP ; c ( 5 , 7 , 2 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 2 ) = 0._RPP ; c ( 7 , 7 , 2 ) = 40235579814154 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 2 ) = - 102644137864 7._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 0 , 8 , 2 ) = 0._RPP ; c ( 1 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 2 ) = 0._RPP ; c ( 3 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 2 ) = 0._RPP ; c ( 5 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 2 ) = 0._RPP ; c ( 7 , 8 , 2 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 2 ) = 67932810145 3._RPP / 16345929600 0._RPP ! stencil 3 !                    /                               ;                     / c ( 0 , 0 , 3 ) = 67932810145 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 3 ) = - 605604173116 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 3 ) = 24758266056940 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 3 ) = - 1769493211975 7._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 4 , 0 , 3 ) = 1969091838402 1._RPP / 5230697472 0._RPP ; c ( 5 , 0 , 3 ) = - 35006738200625 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 3 ) = 15561495071226 1._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 3 ) = - 3958767415244 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 3 ) = 88341623047 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 3 ) = 0._RPP ; c ( 1 , 1 , 3 ) = 29367511416596 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 3 ) = - 47266283089441 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 3 ) = 172029789182536 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 3 ) = - 38844231666875 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 3 ) = 139714133741459 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 3 ) = - 31342113107807 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 3 ) = 112354071745 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 3 ) = - 3607377492245 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 3 ) = 0._RPP ; c ( 1 , 2 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 3 ) = 4038561439218 1._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 3 ) = - 41172185433295 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 3 ) = 214500578863 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 3 ) = - 34365598242589 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 3 ) = 31145828068984 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 3 ) = - 28167860109091 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 3 ) = 12732629258653 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 3 ) = 0._RPP ; c ( 1 , 3 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 3 ) = 0._RPP ; c ( 3 , 3 , 3 ) = 155322581342650 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 3 ) = - 7231095534637 3._RPP / 373621248 0._RPP ; c ( 5 , 3 , 3 ) = 26669846723506 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 3 ) = - 30536884781216 3._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 3 ) = 111438613822412 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 3 ) = - 25367482023674 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 3 ) = 0._RPP ; c ( 1 , 4 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 3 ) = 0._RPP ; c ( 3 , 4 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 3 ) = 8539401890959 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 3 ) = - 6381181890858 1._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 3 ) = 167909462473 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 3 ) = - 27213951837707 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 3 ) = 249720972318 5._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 0 , 5 , 3 ) = 0._RPP ; c ( 1 , 5 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 3 ) = 0._RPP ; c ( 3 , 5 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 3 ) = 0._RPP ; c ( 5 , 5 , 3 ) = 120696469431859 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 3 ) = - 28262210797336 7._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 3 ) = 105123843951611 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 3 ) = - 4863348991747 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 6 , 3 ) = 0._RPP ; c ( 1 , 6 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 3 ) = 0._RPP ; c ( 3 , 6 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 3 ) = 0._RPP ; c ( 5 , 6 , 3 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 3 ) = 2432493465598 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 3 ) = - 25128376722865 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 3 ) = 11727264947413 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 3 ) = 0._RPP ; c ( 1 , 7 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 3 ) = 0._RPP ; c ( 3 , 7 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 3 ) = 0._RPP ; c ( 5 , 7 , 3 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 3 ) = 0._RPP ; c ( 7 , 7 , 3 ) = 13615578096730 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 3 ) = - 246623318515 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 3 ) = 0._RPP ; c ( 1 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 3 ) = 0._RPP ; c ( 3 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 3 ) = 0._RPP ; c ( 5 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 3 ) = 0._RPP ; c ( 7 , 8 , 3 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 3 ) = 23811484639 9._RPP / 16345929600 0._RPP ! stencil 4 !                    /                               ;                     / c ( 0 , 0 , 4 ) = 23811484639 9._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 4 ) = - 229780436377 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 4 ) = 2021607532067 3._RPP / 26153487360 0._RPP ; c ( 3 , 0 , 4 ) = - 19270006097372 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 4 ) = 4527294202072 7._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 4 ) = - 16788831494225 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 4 ) = 7685890397289 1._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 4 ) = - 397630041033 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 8 , 0 , 4 ) = 222750647449 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 4 ) = 0._RPP ; c ( 1 , 1 , 4 ) = 11997931490698 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 4 ) = - 20735925261266 9._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 4 ) = 16108483925350 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 4 , 1 , 4 ) = - 19231034687299 1._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 4 ) = 72335778444206 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 4 ) = - 16769067524111 3._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 4 ) = 61375366326 1._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 4 ) = - 397630041033 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 2 , 4 ) = 0._RPP ; c ( 1 , 2 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 4 ) = 1901031096652 3._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 4 ) = - 20705915804089 7._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 4 ) = 114357625116 1._RPP / 21228480 0._RPP ; c ( 5 , 2 , 4 ) = - 3845076331699 3._RPP / 934053120 0._RPP !                    /                               ;                     / c ( 6 , 2 , 4 ) = 18078615174047 9._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 4 ) = - 16769067524111 3._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 4 ) = 7685890397289 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 4 ) = 0._RPP ; c ( 1 , 3 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 4 ) = 0._RPP ; c ( 3 , 3 , 4 ) = 83648436863713 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 4 ) = - 20713906720178 3._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 4 ) = 80519580337327 7._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 4 ) = - 3845076331699 3._RPP / 934053120 0._RPP ; c ( 7 , 3 , 4 ) = 72335778444206 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 4 ) = - 16788831494225 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 4 ) = 0._RPP ; c ( 1 , 4 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 4 ) = 0._RPP ; c ( 3 , 4 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 4 ) = 5229739288913 9._RPP / 747242496 0._RPP ; c ( 5 , 4 , 4 ) = - 20713906720178 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 4 ) = 114357625116 1._RPP / 21228480 0._RPP ; c ( 7 , 4 , 4 ) = - 19231034687299 1._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 4 ) = 4527294202072 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 4 ) = 0._RPP ; c ( 1 , 5 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 4 ) = 0._RPP ; c ( 3 , 5 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 4 ) = 0._RPP ; c ( 5 , 5 , 4 ) = 83648436863713 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 4 ) = - 20705915804089 7._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 4 ) = 16108483925350 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 5 , 4 ) = - 19270006097372 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 4 ) = 0._RPP ; c ( 1 , 6 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 4 ) = 0._RPP ; c ( 3 , 6 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 4 ) = 0._RPP ; c ( 5 , 6 , 4 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 4 ) = 1901031096652 3._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 4 ) = - 20735925261266 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 4 ) = 2021607532067 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 7 , 4 ) = 0._RPP ; c ( 1 , 7 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 4 ) = 0._RPP ; c ( 3 , 7 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 4 ) = 0._RPP ; c ( 5 , 7 , 4 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 4 ) = 0._RPP ; c ( 7 , 7 , 4 ) = 11997931490698 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 4 ) = - 229780436377 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 4 ) = 0._RPP ; c ( 1 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 4 ) = 0._RPP ; c ( 3 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 4 ) = 0._RPP ; c ( 5 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 4 ) = 0._RPP ; c ( 7 , 8 , 4 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 4 ) = 23811484639 9._RPP / 16345929600 0._RPP ! stencil 5 !                    /                               ;                     / c ( 0 , 0 , 5 ) = 23811484639 9._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 5 ) = - 246623318515 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 5 ) = 11727264947413 9._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 5 ) = - 4863348991747 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 4 , 0 , 5 ) = 249720972318 5._RPP / 1046139494 4._RPP ; c ( 5 , 0 , 5 ) = - 25367482023674 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 5 ) = 12732629258653 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 5 ) = - 3607377492245 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 5 ) = 88341623047 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 5 ) = 0._RPP ; c ( 1 , 1 , 5 ) = 13615578096730 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 5 ) = - 25128376722865 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 5 ) = 105123843951611 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 5 ) = - 27213951837707 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 5 ) = 111438613822412 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 5 ) = - 28167860109091 1._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 5 ) = 112354071745 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 5 ) = - 3958767415244 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 5 ) = 0._RPP ; c ( 1 , 2 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 5 ) = 2432493465598 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 5 ) = - 28262210797336 7._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 5 ) = 167909462473 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 5 ) = - 30536884781216 3._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 5 ) = 31145828068984 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 5 ) = - 31342113107807 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 5 ) = 15561495071226 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 5 ) = 0._RPP ; c ( 1 , 3 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 5 ) = 0._RPP ; c ( 3 , 3 , 5 ) = 120696469431859 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 5 ) = - 6381181890858 1._RPP / 373621248 0._RPP ; c ( 5 , 3 , 5 ) = 26669846723506 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 5 ) = - 34365598242589 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 5 ) = 139714133741459 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 5 ) = - 35006738200625 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 5 ) = 0._RPP ; c ( 1 , 4 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 5 ) = 0._RPP ; c ( 3 , 4 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 5 ) = 8539401890959 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 5 ) = - 7231095534637 3._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 5 ) = 214500578863 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 5 ) = - 38844231666875 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 5 ) = 1969091838402 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 5 , 5 ) = 0._RPP ; c ( 1 , 5 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 5 ) = 0._RPP ; c ( 3 , 5 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 5 ) = 0._RPP ; c ( 5 , 5 , 5 ) = 155322581342650 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 5 ) = - 41172185433295 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 5 ) = 172029789182536 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 5 ) = - 1769493211975 7._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 0 , 6 , 5 ) = 0._RPP ; c ( 1 , 6 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 5 ) = 0._RPP ; c ( 3 , 6 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 5 ) = 0._RPP ; c ( 5 , 6 , 5 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 5 ) = 4038561439218 1._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 5 ) = - 47266283089441 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 5 ) = 24758266056940 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 5 ) = 0._RPP ; c ( 1 , 7 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 5 ) = 0._RPP ; c ( 3 , 7 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 5 ) = 0._RPP ; c ( 5 , 7 , 5 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 5 ) = 0._RPP ; c ( 7 , 7 , 5 ) = 29367511416596 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 5 ) = - 605604173116 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 5 ) = 0._RPP ; c ( 1 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 5 ) = 0._RPP ; c ( 3 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 5 ) = 0._RPP ; c ( 5 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 5 ) = 0._RPP ; c ( 7 , 8 , 5 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 5 ) = 67932810145 3._RPP / 16345929600 0._RPP ! stencil 6 !                    /                               ;                     / c ( 0 , 0 , 6 ) = 67932810145 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 6 ) = - 102644137864 7._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 2 , 0 , 6 ) = 7034106245689 7._RPP / 26153487360 0._RPP ; c ( 3 , 0 , 6 ) = - 75740201764057 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 6 ) = 20389161410459 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 6 ) = - 87725249292872 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 6 ) = 47064366535890 7._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 6 ) = - 574841303470 1._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 8 , 0 , 6 ) = 1909470410406 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 6 ) = 0._RPP ; c ( 1 , 1 , 6 ) = 40235579814154 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 6 ) = - 75959848012063 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 6 ) = 328142799572072 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 6 ) = - 88617378590975 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 6 ) = 382543571327995 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 6 ) = - 102960824791727 3._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 6 ) = 441155351017 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 6 ) = - 16817238148781 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 6 ) = 0._RPP ; c ( 1 , 2 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 6 ) = 7473082165381 9._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 6 ) = - 89093725268464 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 6 ) = 548943514198 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 6 ) = - 20938884275712 1._RPP / 934053120 0._RPP !                    /                               ;                     / c ( 6 , 2 , 6 ) = 113189854289740 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 6 ) = - 121878246652664 9._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 6 ) = 65245292556748 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 6 ) = 0._RPP ; c ( 1 , 3 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 6 ) = 0._RPP ; c ( 3 , 3 , 6 ) = 387829668278573 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 6 ) = - 105629161653487 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 6 ) = 460178203604450 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 6 ) = - 125045499175210 1._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 6 ) = 541497253844423 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 6 ) = - 145710511264309 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 6 ) = 0._RPP ; c ( 1 , 4 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 6 ) = 0._RPP ; c ( 3 , 4 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 6 ) = 28925923563877 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 6 ) = - 126799229420335 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 6 ) = 788382052810 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 6 ) = - 151274428150079 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 6 ) = 40992179077691 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 6 ) = 0._RPP ; c ( 1 , 5 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 6 ) = 0._RPP ; c ( 3 , 5 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 6 ) = 0._RPP ; c ( 5 , 5 , 6 ) = 559966627269370 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 6 ) = - 154496455714316 9._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 6 ) = 135989101716685 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 5 , 6 ) = - 185989924739449 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 6 ) = 0._RPP ; c ( 1 , 6 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 6 ) = 0._RPP ; c ( 3 , 6 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 6 ) = 0._RPP ; c ( 5 , 6 , 6 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 6 ) = 15662254432876 3._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 6 ) = - 191861009660335 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 6 ) = 106319120144653 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 6 ) = 0._RPP ; c ( 1 , 7 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 6 ) = 0._RPP ; c ( 3 , 7 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 6 ) = 0._RPP ; c ( 5 , 7 , 6 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 6 ) = 0._RPP ; c ( 7 , 7 , 6 ) = 123999028356413 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 6 ) = - 384413984834 3._RPP / 1437004800 0._RPP !                    /                               ;                     / c ( 0 , 8 , 6 ) = 0._RPP ; c ( 1 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 6 ) = 0._RPP ; c ( 3 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 6 ) = 0._RPP ; c ( 5 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 6 ) = 0._RPP ; c ( 7 , 8 , 6 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 6 ) = 316535517012 1._RPP / 16345929600 0._RPP ! stencil 7 !                    /                               ;                     / c ( 0 , 0 , 7 ) = 316535517012 1._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 7 ) = - 3359357233795 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 7 ) = 165507219650188 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 7 ) = - 360178442307514 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 4 , 0 , 7 ) = 98485018206416 9._RPP / 26153487360 0._RPP ; c ( 5 , 0 , 7 ) = - 433174706907934 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 7 ) = 239433810124813 3._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 7 ) = - 76005337654316 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 7 ) = 10599441829821 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 1 , 7 ) = 0._RPP ; c ( 1 , 1 , 7 ) = 26924749115906 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 2 , 1 , 7 ) = - 357541164655690 7._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 7 ) = 311638099752196 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 4 , 1 , 7 ) = - 426697274934164 9._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 7 ) = 1879962448756268 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 7 ) = - 520558506485519 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 7 ) = 2315984163112 3._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 7 ) = - 740646202891 9._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 0 , 2 , 7 ) = 0._RPP ; c ( 1 , 2 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 7 ) = 35281236971941 3._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 7 ) = - 423486261093611 9._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 7 ) = 2640359881420 9._RPP / 21228480 0._RPP ; c ( 5 , 2 , 7 ) = - 512910400994605 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 7 ) = 569432593046545 7._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 7 ) = - 635653720341542 3._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 7 ) = 356395192925475 7._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 7 ) = 0._RPP ; c ( 1 , 3 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 7 ) = 0._RPP ; c ( 3 , 3 , 7 ) = 1851802802323795 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 7 ) = - 509106072743740 1._RPP / 1868106240 0._RPP ; c ( 5 , 3 , 7 ) = 2253375754684385 9._RPP / 9340531200 0._RPP !                    /                               ;                     / c ( 6 , 3 , 7 ) = - 125451994816551 1._RPP / 934053120 0._RPP ; c ( 7 , 3 , 7 ) = 2810137895488000 1._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 7 ) = - 790658467304897 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 7 ) = 0._RPP ; c ( 1 , 4 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 7 ) = 0._RPP ; c ( 3 , 4 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 7 ) = 140330435447542 1._RPP / 747242496 0._RPP ; c ( 5 , 4 , 7 ) = - 623064713812012 1._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 4 , 7 ) = 3956407788958 9._RPP / 21228480 0._RPP ; c ( 7 , 4 , 7 ) = - 783236811583460 9._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 7 ) = 221425915373504 9._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 5 , 7 ) = 0._RPP ; c ( 1 , 5 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 7 ) = 0._RPP ; c ( 3 , 5 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 7 ) = 0._RPP ; c ( 5 , 5 , 7 ) = 2777072392772198 9._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 7 ) = - 779567532947119 1._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 7 ) = 3527256877887227 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 7 ) = - 1003625893562122 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 6 , 7 ) = 0._RPP ; c ( 1 , 6 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 7 ) = 0._RPP ; c ( 3 , 6 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 7 ) = 0._RPP ; c ( 5 , 6 , 7 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 7 ) = 80057267234686 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 7 ) = - 1003677958085818 7._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 7 ) = 115266961643356 7._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 7 , 7 ) = 0._RPP ; c ( 1 , 7 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 7 ) = 0._RPP ; c ( 3 , 7 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 7 ) = 0._RPP ; c ( 5 , 7 , 7 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 7 ) = 0._RPP ; c ( 7 , 7 , 7 ) = 660345506505409 1._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 7 , 7 ) = - 14780912554847 9._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 7 ) = 0._RPP ; c ( 1 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 7 ) = 0._RPP ; c ( 3 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 7 ) = 0._RPP ; c ( 5 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 7 ) = 0._RPP ; c ( 7 , 8 , 7 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 7 ) = 1784873725120 3._RPP / 16345929600 0._RPP ! stencil 8 !                    /                               ;                     / c ( 0 , 0 , 8 ) = 1784873725120 3._RPP / 16345929600 0._RPP ; c ( 1 , 0 , 8 ) = - 18955567275961 7._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 2 , 0 , 8 ) = 935506490307805 3._RPP / 130767436800 0._RPP ; c ( 3 , 0 , 8 ) = - 81699003745448 3._RPP / 5230697472 0._RPP !                    /                               ;                     / c ( 4 , 0 , 8 ) = 112305878501505 1._RPP / 5230697472 0._RPP ; c ( 5 , 0 , 8 ) = - 2491175852975000 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 6 , 0 , 8 ) = 1395244392999561 1._RPP / 130767436800 0._RPP ; c ( 7 , 0 , 8 ) = - 451752457452509 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 8 , 0 , 8 ) = 12973990640860 1._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 1 , 8 ) = 0._RPP ; c ( 1 , 1 , 8 ) = 1063735481545661 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 2 , 1 , 8 ) = - 2020412537734006 1._RPP / 32691859200 0._RPP ; c ( 3 , 1 , 8 ) = 8828714974335541 7._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 4 , 1 , 8 ) = - 2429347143458870 3._RPP / 13076743680 0._RPP ; c ( 5 , 1 , 8 ) = 10788739048624814 3._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 6 , 1 , 8 ) = - 3025005282549752 9._RPP / 32691859200 0._RPP ; c ( 7 , 1 , 8 ) = 13718972102530 9._RPP / 457228800 0._RPP !                    /                               ;                     / c ( 8 , 1 , 8 ) = - 564439940024630 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 2 , 8 ) = 0._RPP ; c ( 1 , 2 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 2 , 8 ) = 199495274192793 1._RPP / 1698278400 0._RPP ; c ( 3 , 2 , 8 ) = - 2399374389255760 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 4 , 2 , 8 ) = 15020534732683 3._RPP / 21228480 0._RPP ; c ( 5 , 2 , 8 ) = - 2938718777174794 1._RPP / 4670265600 0._RPP !                    /                               ;                     / c ( 6 , 2 , 8 ) = 3300852708223699 1._RPP / 9340531200 0._RPP ; c ( 7 , 2 , 8 ) = - 3753103645304716 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 2 , 8 ) = 2164462807751548 3._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 3 , 8 ) = 0._RPP ; c ( 1 , 3 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 3 , 8 ) = 0._RPP ; c ( 3 , 3 , 8 ) = 10504573010955745 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 4 , 3 , 8 ) = - 579411902443348 3._RPP / 373621248 0._RPP ; c ( 5 , 3 , 8 ) = 2580251345869183 3._RPP / 1868106240 0._RPP !                    /                               ;                     / c ( 6 , 3 , 8 ) = - 3629458001216861 3._RPP / 4670265600 0._RPP ; c ( 7 , 3 , 8 ) = 16544517891672647 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 3 , 8 ) = - 4784134214198129 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 4 , 8 ) = 0._RPP ; c ( 1 , 4 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 4 , 8 ) = 0._RPP ; c ( 3 , 4 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 4 , 8 ) = 800187970376734 7._RPP / 747242496 0._RPP ; c ( 5 , 4 , 8 ) = - 714007473389985 1._RPP / 373621248 0._RPP !                    /                               ;                     / c ( 6 , 4 , 8 ) = 22878692017843 3._RPP / 21228480 0._RPP ; c ( 7 , 4 , 8 ) = - 4602038409035702 3._RPP / 13076743680 0._RPP !                    /                               ;                     / c ( 8 , 4 , 8 ) = 53423709511790 3._RPP / 1046139494 4._RPP !                    /                               ;                     / c ( 0 , 5 , 8 ) = 0._RPP ; c ( 1 , 5 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 5 , 8 ) = 0._RPP ; c ( 3 , 5 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 5 , 8 ) = 0._RPP ; c ( 5 , 5 , 8 ) = 15964677371155834 7._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 6 , 5 , 8 ) = - 4514872822425481 7._RPP / 4670265600 0._RPP ; c ( 7 , 5 , 8 ) = 20717808425886056 9._RPP / 65383718400 0._RPP !                    /                               ;                     / c ( 8 , 5 , 8 ) = - 1208363205553750 3._RPP / 26153487360 0._RPP !                    /                               ;                     / c ( 0 , 6 , 8 ) = 0._RPP ; c ( 1 , 6 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 6 , 8 ) = 0._RPP ; c ( 3 , 6 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 6 , 8 ) = 0._RPP ; c ( 5 , 6 , 8 ) = 0._RPP !                    /                               ;                     / c ( 6 , 6 , 8 ) = 466071217217893 9._RPP / 1698278400 0._RPP ; c ( 7 , 6 , 8 ) = - 5911141295073430 1._RPP / 32691859200 0._RPP !                    /                               ;                     / c ( 8 , 6 , 8 ) = 3470956782876598 9._RPP / 130767436800 0._RPP !                    /                               ;                     / c ( 0 , 7 , 8 ) = 0._RPP ; c ( 1 , 7 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 7 , 8 ) = 0._RPP ; c ( 3 , 7 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 7 , 8 ) = 0._RPP ; c ( 5 , 7 , 8 ) = 0._RPP !                    /                               ;                     / c ( 6 , 7 , 8 ) = 0._RPP ; c ( 7 , 7 , 8 ) = 560275323330565 1._RPP / 18681062400 0._RPP !                    /                               ;                     / c ( 8 , 7 , 8 ) = - 89462836442080 1._RPP / 10059033600 0._RPP !                    /                               ;                     / c ( 0 , 8 , 8 ) = 0._RPP ; c ( 1 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 2 , 8 , 8 ) = 0._RPP ; c ( 3 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 4 , 8 , 8 ) = 0._RPP ; c ( 5 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 6 , 8 , 8 ) = 0._RPP ; c ( 7 , 8 , 8 ) = 0._RPP !                    /                               ;                     / c ( 8 , 8 , 8 ) = 10947113933269 9._RPP / 16345929600 0._RPP endselect endassociate endsubroutine create","tags":"","loc":"proc/create.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy beta. class ( beta_rec_js ), intent ( inout ) :: self !< Beta. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % coef )) deallocate ( self % coef ) endsubroutine destroy","tags":"","loc":"proc/destroy~11.html","title":"destroy – FORESEER"},{"text":"private pure function description(self) result(string) Return reconstructor string-descripition. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(in) :: self Reconstructor. Return Value character(len=:),\n  allocatable String-description. Calls proc~~description~5~~CallsGraph proc~description~5 description interface~str str proc~description~5->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self ) result ( string ) !< Return reconstructor string-descripition. class ( reconstructor_js ), intent ( in ) :: self !< Reconstructor. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = 'Jiang-Shu reconstructor:' // nl string = string // '  - S   = ' // trim ( str ( self % S )) // nl string = string // '  - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '  - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '  - ff  = ' // trim ( str ( self % ff )) // nl string = string // self % weights % description () endfunction description","tags":"","loc":"proc/description~5.html","title":"description – FORESEER"},{"text":"private subroutine create(self, constructor) Create interpolator. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Interpolator. class( base_object_constructor ), intent(in) :: constructor Constructor. Source Code create Source Code subroutine create ( self , constructor ) !< Create interpolator. class ( reconstructor_js ), intent ( inout ) :: self !< Interpolator. class ( base_object_constructor ), intent ( in ) :: constructor !< Constructor. type ( interpolations_factory ) :: i_factory !< Inteprolations factory. type ( weights_factory ) :: w_factory !< Weights factory. call self % destroy call self % create_ ( constructor = constructor ) select type ( constructor ) class is ( interpolator_object_constructor ) call i_factory % create ( constructor = constructor % interpolations_constructor , object = self % interpolations ) call w_factory % create ( constructor = constructor % weights_constructor , object = self % weights ) endselect endsubroutine create","tags":"","loc":"proc/create~2.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy reconstructor. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy reconstructor. class ( reconstructor_js ), intent ( inout ) :: self !< Reconstructor. call self % destroy_ if ( allocated ( self % interpolations )) deallocate ( self % interpolations ) if ( allocated ( self % weights )) deallocate ( self % weights ) endsubroutine destroy","tags":"","loc":"proc/destroy~12.html","title":"destroy – FORESEER"},{"text":"private pure subroutine interpolate_debug(self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. Source Code interpolate_debug Source Code pure subroutine interpolate_debug ( self , stencil , interpolation , si , weights ) !< Interpolate values (providing also debug values). class ( reconstructor_js ), intent ( inout ) :: self !< Reconstructor. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( RPP ), intent ( out ) :: si ( 1 :, 0 :) !< Computed values of smoothness indicators [1:2, 0:S-1]. real ( RPP ), intent ( out ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S-1]. call self % interpolate_standard ( stencil = stencil , interpolation = interpolation ) si = self % weights % smoothness_indicators () weights = self % weights % values endsubroutine interpolate_debug","tags":"","loc":"proc/interpolate_debug.html","title":"interpolate_debug – FORESEER"},{"text":"private pure subroutine interpolate_standard(self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Source Code interpolate_standard Source Code pure subroutine interpolate_standard ( self , stencil , interpolation ) !< Interpolate values (without providing debug values). class ( reconstructor_js ), intent ( inout ) :: self !< Reconstructor. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. integer ( I_P ) :: f , s !< Counters. call self % interpolations % compute ( stencil = stencil ) call self % weights % compute ( stencil = stencil ) interpolation = 0._RPP do s = 0 , self % S - 1 ! stencils loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) interpolation ( f + self % ff ) = interpolation ( f + self % ff ) + & self % weights % values ( f + self % ff , s ) * self % interpolations % values ( f , s ) enddo enddo endsubroutine interpolate_standard","tags":"","loc":"proc/interpolate_standard.html","title":"interpolate_standard – FORESEER"},{"text":"private pure function description(self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(in) :: self Alpha coefficient. Return Value character(len=:),\n  allocatable String-description. Calls proc~~description~6~~CallsGraph proc~description~6 description interface~str str proc~description~6->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self ) result ( string ) !< Return alpha string-descripition. class ( alpha_rec_js ), intent ( in ) :: self !< Alpha coefficient. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '    Jiang-Shu alpha coefficients for reconstructor:' // nl string = string // '      - S   = ' // trim ( str ( self % S )) // nl string = string // '      - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '      - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '      - ff  = ' // trim ( str ( self % ff )) // nl string = string // '      - eps = ' // trim ( str ( self % eps )) endfunction description","tags":"","loc":"proc/description~6.html","title":"description – FORESEER"},{"text":"private pure subroutine compute(self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha coefficient. class( beta_object ), intent(in) :: beta Beta coefficients. class( kappa_object ), intent(in) :: kappa Kappa coefficients. Source Code compute Source Code pure subroutine compute ( self , beta , kappa ) !< Compute alpha. class ( alpha_rec_js ), intent ( inout ) :: self !< Alpha coefficient. class ( beta_object ), intent ( in ) :: beta !< Beta coefficients. class ( kappa_object ), intent ( in ) :: kappa !< Kappa coefficients. integer ( I_P ) :: f , s1 !< Counters. self % values_sum = 0._RPP do s1 = 0 , self % S - 1 ! stencil loops do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = kappa % values ( f , s1 ) / ( self % eps + beta % values ( f , s1 )) ** self % S self % values_sum ( f ) = self % values_sum ( f ) + self % values ( f , s1 ) enddo enddo endsubroutine compute","tags":"","loc":"proc/compute~2.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. Source Code create Source Code subroutine create ( self , constructor ) !< Create alpha. class ( alpha_rec_js ), intent ( inout ) :: self !< Alpha. class ( base_object_constructor ), intent ( in ) :: constructor !< Alpha constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % values_sum ( 1 : 2 )) self % values = 0._RPP self % values_sum = 0._RPP endsubroutine create","tags":"","loc":"proc/create~3.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy alpha. class ( alpha_rec_js ), intent ( inout ) :: self !< Alpha. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % values_sum )) deallocate ( self % values_sum ) endsubroutine destroy","tags":"","loc":"proc/destroy~13.html","title":"destroy – FORESEER"},{"text":"private pure function description(self) result(string) Return string-description of kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(in) :: self Kappa. Return Value character(len=:),\n  allocatable String-description. Source Code description Source Code pure function description ( self ) result ( string ) !< Return string-description of kappa. class ( kappa_rec_js ), intent ( in ) :: self !< Kappa. character ( len = :), allocatable :: string !< String-description. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'kappa_rec_js%description to be implemented, do not use!' #endif endfunction description","tags":"","loc":"proc/description~7.html","title":"description – FORESEER"},{"text":"private pure subroutine compute(self) Compute kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. Calls proc~~compute~3~~CallsGraph proc~compute~3 compute val val proc~compute~3->val Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute Source Code pure subroutine compute ( self ) !< Compute kappa. class ( kappa_rec_js ), intent ( inout ) :: self !< Kappa. associate ( val => self % values ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 2._RPP / 3._RPP ! stencil 0 val ( 1 , 1 ) = 1._RPP / 3._RPP ! stencil 1 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 3._RPP ! stencil 0 val ( 2 , 1 ) = 2._RPP / 3._RPP ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 0.3_RPP ! stencil 0 val ( 1 , 1 ) = 0.6_RPP ! stencil 1 val ( 1 , 2 ) = 0.1_RPP ! stencil 2 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 0.1_RPP ! stencil 0 val ( 2 , 1 ) = 0.6_RPP ! stencil 1 val ( 2 , 2 ) = 0.3_RPP ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 4._RPP / 3 5._RPP ! stencil 0 val ( 1 , 1 ) = 1 8._RPP / 3 5._RPP ! stencil 1 val ( 1 , 2 ) = 1 2._RPP / 3 5._RPP ! stencil 2 val ( 1 , 3 ) = 1._RPP / 3 5._RPP ! stencil 3 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 3 5._RPP ! stencil 0 val ( 2 , 1 ) = 1 2._RPP / 3 5._RPP ! stencil 1 val ( 2 , 2 ) = 1 8._RPP / 3 5._RPP ! stencil 2 val ( 2 , 3 ) = 4._RPP / 3 5._RPP ! stencil 3 case ( 5 ) ! 9th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 5._RPP / 12 6._RPP ! stencil 0 val ( 1 , 1 ) = 2 0._RPP / 6 3._RPP ! stencil 1 val ( 1 , 2 ) = 1 0._RPP / 2 1._RPP ! stencil 2 val ( 1 , 3 ) = 1 0._RPP / 6 3._RPP ! stencil 3 val ( 1 , 4 ) = 1._RPP / 12 6._RPP ! stencil 4 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 12 6._RPP ! stencil 0 val ( 2 , 1 ) = 1 0._RPP / 6 3._RPP ! stencil 1 val ( 2 , 2 ) = 1 0._RPP / 2 1._RPP ! stencil 2 val ( 2 , 3 ) = 2 0._RPP / 6 3._RPP ! stencil 3 val ( 2 , 4 ) = 5._RPP / 12 6._RPP ! stencil 4 case ( 6 ) ! 11th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 1._RPP / 7 7._RPP ! stencil 0 val ( 1 , 1 ) = 2 5._RPP / 15 4._RPP ! stencil 1 val ( 1 , 2 ) = 10 0._RPP / 23 1._RPP ! stencil 2 val ( 1 , 3 ) = 2 5._RPP / 7 7._RPP ! stencil 3 val ( 1 , 4 ) = 5._RPP / 7 7._RPP ! stencil 4 val ( 1 , 5 ) = 1._RPP / 46 2._RPP ! stencil 5 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 46 2._RPP ! stencil 0 val ( 2 , 1 ) = 5._RPP / 7 7._RPP ! stencil 1 val ( 2 , 2 ) = 2 5._RPP / 7 7._RPP ! stencil 2 val ( 2 , 3 ) = 10 0._RPP / 23 1._RPP ! stencil 3 val ( 2 , 4 ) = 2 5._RPP / 15 4._RPP ! stencil 4 val ( 2 , 5 ) = 1._RPP / 7 7._RPP ! stencil 5 case ( 7 ) ! 13th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 7._RPP / 171 6._RPP ! stencil 0 val ( 1 , 1 ) = 2 1._RPP / 28 6._RPP ! stencil 1 val ( 1 , 2 ) = 17 5._RPP / 57 2._RPP ! stencil 2 val ( 1 , 3 ) = 17 5._RPP / 42 9._RPP ! stencil 3 val ( 1 , 4 ) = 10 5._RPP / 57 2._RPP ! stencil 4 val ( 1 , 5 ) = 7._RPP / 28 6._RPP ! stencil 5 val ( 1 , 6 ) = 1._RPP / 171 6._RPP ! stencil 6 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 171 6._RPP ! stencil 0 val ( 2 , 1 ) = 7._RPP / 28 6._RPP ! stencil 1 val ( 2 , 2 ) = 10 5._RPP / 57 2._RPP ! stencil 2 val ( 2 , 3 ) = 17 5._RPP / 42 9._RPP ! stencil 3 val ( 2 , 4 ) = 17 5._RPP / 57 2._RPP ! stencil 4 val ( 2 , 5 ) = 2 1._RPP / 28 6._RPP ! stencil 5 val ( 2 , 6 ) = 7._RPP / 171 6._RPP ! stencil 6 case ( 8 ) ! 15th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 8._RPP / 643 5._RPP ! stencil 0 val ( 1 , 1 ) = 19 6._RPP / 643 5._RPP ! stencil 1 val ( 1 , 2 ) = 39 2._RPP / 214 5._RPP ! stencil 2 val ( 1 , 3 ) = 49 0._RPP / 128 7._RPP ! stencil 3 val ( 1 , 4 ) = 39 2._RPP / 128 7._RPP ! stencil 4 val ( 1 , 5 ) = 19 6._RPP / 214 5._RPP ! stencil 5 val ( 1 , 6 ) = 5 6._RPP / 643 5._RPP ! stencil 6 val ( 1 , 7 ) = 1._RPP / 643 5._RPP ! stencil 7 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 643 5._RPP ! stencil 0 val ( 2 , 1 ) = 5 6._RPP / 643 5._RPP ! stencil 1 val ( 2 , 2 ) = 19 6._RPP / 214 5._RPP ! stencil 2 val ( 2 , 3 ) = 39 2._RPP / 128 7._RPP ! stencil 3 val ( 2 , 4 ) = 49 0._RPP / 128 7._RPP ! stencil 4 val ( 2 , 5 ) = 39 2._RPP / 214 5._RPP ! stencil 5 val ( 2 , 6 ) = 19 6._RPP / 643 5._RPP ! stencil 6 val ( 2 , 7 ) = 8._RPP / 643 5._RPP ! stencil 7 case ( 9 ) ! 17th order ! 1 => left interface (i-1/2) val ( 1 , 0 ) = 9._RPP / 2431 0._RPP ! stencil 0 val ( 1 , 1 ) = 14 4._RPP / 1215 5._RPP ! stencil 1 val ( 1 , 2 ) = 117 6._RPP / 1215 5._RPP ! stencil 2 val ( 1 , 3 ) = 352 8._RPP / 1215 5._RPP ! stencil 3 val ( 1 , 4 ) = 88 2._RPP / 243 1._RPP ! stencil 4 val ( 1 , 5 ) = 235 2._RPP / 1215 5._RPP ! stencil 5 val ( 1 , 6 ) = 50 4._RPP / 1215 5._RPP ! stencil 6 val ( 1 , 7 ) = 3 6._RPP / 1215 5._RPP ! stencil 7 val ( 1 , 8 ) = 1._RPP / 2431 0._RPP ! stencil 8 ! 2 => right interface (i+1/2) val ( 2 , 0 ) = 1._RPP / 2431 0._RPP ! stencil 0 val ( 2 , 1 ) = 3 6._RPP / 1215 5._RPP ! stencil 1 val ( 2 , 2 ) = 50 4._RPP / 1215 5._RPP ! stencil 2 val ( 2 , 3 ) = 235 2._RPP / 1215 5._RPP ! stencil 3 val ( 2 , 4 ) = 88 2._RPP / 243 1._RPP ! stencil 4 val ( 2 , 5 ) = 352 8._RPP / 1215 5._RPP ! stencil 5 val ( 2 , 6 ) = 117 6._RPP / 1215 5._RPP ! stencil 6 val ( 2 , 7 ) = 14 4._RPP / 1215 5._RPP ! stencil 7 val ( 2 , 8 ) = 9._RPP / 2431 0._RPP ! stencil 8 endselect endassociate endsubroutine compute","tags":"","loc":"proc/compute~3.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create kappa. Note The kappa coefficients are also computed, they being constants. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. class( base_object_constructor ), intent(in) :: constructor Kappa constructor. Source Code create Source Code subroutine create ( self , constructor ) !< Create kappa. !< !< @note The kappa coefficients are also computed, they being constants. class ( kappa_rec_js ), intent ( inout ) :: self !< Kappa. class ( base_object_constructor ), intent ( in ) :: constructor !< Kappa constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP call self % compute endsubroutine create","tags":"","loc":"proc/create~4.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy kappa. class ( kappa_rec_js ), intent ( inout ) :: self !< Kappa. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) endsubroutine destroy","tags":"","loc":"proc/destroy~14.html","title":"destroy – FORESEER"},{"text":"private pure function description(self) result(string) Return string-description of weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(in) :: self Weights. Return Value character(len=:),\n  allocatable String-description. Calls proc~~description~8~~CallsGraph proc~description~8 description interface~str str proc~description~8->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self ) result ( string ) !< Return string-description of weights. class ( weights_js ), intent ( in ) :: self !< Weights. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '  Jiang-Shu weights:' // nl string = string // '    - S   = ' // trim ( str ( self % S )) // nl string = string // '    - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '    - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '    - ff  = ' // trim ( str ( self % ff )) // nl string = string // self % alpha % description () endfunction description","tags":"","loc":"proc/description~8.html","title":"description – FORESEER"},{"text":"private pure function smoothness_indicators(self) result(si) Return smoothness indicators.. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(in) :: self Weights. Return Value real(kind=RPP),\n  allocatable,(:,:) Smoothness indicators. Source Code smoothness_indicators Source Code pure function smoothness_indicators ( self ) result ( si ) !< Return smoothness indicators.. class ( weights_js ), intent ( in ) :: self !< Weights. real ( RPP ), allocatable :: si (:,:) !< Smoothness indicators. if ( allocated ( self % beta )) then if ( allocated ( self % beta % values )) then si = self % beta % values endif endif endfunction smoothness_indicators","tags":"","loc":"proc/smoothness_indicators.html","title":"smoothness_indicators – FORESEER"},{"text":"private pure subroutine compute(self, stencil) Compute weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Source Code compute Source Code pure subroutine compute ( self , stencil ) !< Compute weights. class ( weights_js ), intent ( inout ) :: self !< Weights. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. integer ( I_P ) :: f , s !< Counters. call self % beta % compute ( stencil = stencil ) call self % alpha % compute ( beta = self % beta , kappa = self % kappa ) do s = 0 , self % S - 1 ! stencils loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f + self % ff , s ) = self % alpha % values ( f , s ) / self % alpha % values_sum ( f ) enddo enddo endsubroutine compute","tags":"","loc":"proc/compute~4.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create reconstructor. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. class( base_object_constructor ), intent(in) :: constructor Constructor. Source Code create Source Code subroutine create ( self , constructor ) !< Create reconstructor. class ( weights_js ), intent ( inout ) :: self !< Weights. class ( base_object_constructor ), intent ( in ) :: constructor !< Constructor. type ( alpha_factory ) :: a_factory !< Alpha factory. type ( beta_factory ) :: b_factory !< Beta factory. type ( kappa_factory ) :: k_factory !< Kappa factory. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP select type ( constructor ) type is ( weights_js_constructor ) associate ( alpha_constructor => constructor % alpha_constructor , & beta_constructor => constructor % beta_constructor , & kappa_constructor => constructor % kappa_constructor ) call a_factory % create ( constructor = alpha_constructor , object = self % alpha ) ! select type(alpha_constructor) ! type is(alpha_rec_js_constructor) !   call factory%create(constructor=alpha_constructor, object=self%alpha) ! type is(alpha_rec_m_constructor) !   call factory%create(constructor=alpha_constructor, object=self%alpha) ! type is(alpha_rec_z_constructor) !   call factory%create(constructor=alpha_constructor, object=self%alpha) ! endselect call b_factory % create ( constructor = beta_constructor , object = self % beta ) ! select type(beta_constructor) ! type is(beta_rec_js_constructor) !   allocate(beta_rec_js :: self%beta) !   call self%beta%create(constructor=beta_constructor) ! endselect call k_factory % create ( constructor = kappa_constructor , object = self % kappa ) ! select type(kappa_constructor) ! type is(kappa_rec_js_constructor) !   allocate(kappa_rec_js :: self%kappa) !   call self%kappa%create(constructor=kappa_constructor) ! endselect endassociate endselect endsubroutine create","tags":"","loc":"proc/create~5.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy weights. class ( weights_js ), intent ( inout ) :: self !< Weights. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % alpha )) deallocate ( self % alpha ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % kappa )) deallocate ( self % kappa ) endsubroutine destroy","tags":"","loc":"proc/destroy~15.html","title":"destroy – FORESEER"},{"text":"private pure function description(self) result(string) Return interpolator string-descripition. Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(in) :: self Interpolator. Return Value character(len=:),\n  allocatable String-description. Source Code description Source Code pure function description ( self ) result ( string ) !< Return interpolator string-descripition. class ( interpolator_js ), intent ( in ) :: self !< Interpolator. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line character. character ( len = :), allocatable :: dummy_string !< Dummy string. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolator_js to be implemented, do not use!' #endif endfunction description","tags":"","loc":"proc/description~9.html","title":"description – FORESEER"},{"text":"private pure subroutine interpolate_debug(self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. Source Code interpolate_debug Source Code pure subroutine interpolate_debug ( self , stencil , interpolation , si , weights ) !< Interpolate values (providing also debug values). class ( interpolator_js ), intent ( inout ) :: self !< Interpolator. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. real ( RPP ), intent ( out ) :: si ( 1 :, 0 :) !< Computed values of smoothness indicators [1:2, 0:S-1]. real ( RPP ), intent ( out ) :: weights ( 1 :, 0 :) !< Weights of the stencils, [1:2, 0:S-1]. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolator_js to be implemented, do not use!' #endif endsubroutine interpolate_debug","tags":"","loc":"proc/interpolate_debug~2.html","title":"interpolate_debug – FORESEER"},{"text":"private pure subroutine interpolate_standard(self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Source Code interpolate_standard Source Code pure subroutine interpolate_standard ( self , stencil , interpolation ) !< Interpolate values (without providing debug values). class ( interpolator_js ), intent ( inout ) :: self !< Interpolator. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil of the interpolation [1:2, 1-S:-1+S]. real ( RPP ), intent ( out ) :: interpolation ( 1 :) !< Result of the interpolation, [1:2]. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolator_js to be implemented, do not use!' #endif endsubroutine interpolate_standard","tags":"","loc":"proc/interpolate_standard~2.html","title":"interpolate_standard – FORESEER"},{"text":"private pure function description(self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(in) :: self Alpha coefficients. Return Value character(len=:),\n  allocatable String-description. Calls proc~~description~10~~CallsGraph proc~description~10 description interface~str str proc~description~10->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self ) result ( string ) !< Return alpha string-descripition. class ( alpha_rec_z ), intent ( in ) :: self !< Alpha coefficients. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '    Borges alpha coefficients for reconstructor:' // nl string = string // '      - S   = ' // trim ( str ( self % S )) // nl string = string // '      - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '      - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '      - ff  = ' // trim ( str ( self % ff )) // nl string = string // '      - eps = ' // trim ( str ( self % eps )) endfunction description","tags":"","loc":"proc/description~10.html","title":"description – FORESEER"},{"text":"private pure function tau(S, beta) result(w_tau) Compute the tau coefficient used in the WENO-Z alpha coefficients. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=RPP), intent(in) :: beta (0:S-1) Smoothness indicators. Return Value real(kind=RPP) Tau coefficient. Calls proc~~tau~~CallsGraph proc~tau tau proc~weno_odd weno_odd proc~tau->proc~weno_odd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~tau~~CalledByGraph proc~tau tau proc~compute~5 compute proc~compute~5->proc~tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tau Source Code pure function tau ( S , beta ) result ( w_tau ) !< Compute the tau coefficient used in the WENO-Z alpha coefficients. integer ( I_P ), intent ( in ) :: S !< Number of stencils used. real ( RPP ), intent ( in ) :: beta ( 0 : S - 1 ) !< Smoothness indicators. real ( RPP ) :: w_tau !< Tau coefficient. w_tau = abs ( beta ( 0 ) - & ( 1_I_P - weno_odd ( S )) * beta ( 1 ) - & ( 1_I_P - weno_odd ( S )) * beta ( S - 2 ) + & ( 1_I_P - 2_I_P * weno_odd ( S )) * beta ( S - 1 )) endfunction tau","tags":"","loc":"proc/tau.html","title":"tau – FORESEER"},{"text":"private pure function weno_exp(S) result(w_exp) Compute the exponent used in the alpha function. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Number of stencils used. Return Value integer(kind=I_P) Exponent used in the alpha function. Called By proc~~weno_exp~~CalledByGraph proc~weno_exp weno_exp proc~compute~5 compute proc~compute~5->proc~weno_exp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code weno_exp Source Code pure function weno_exp ( S ) result ( w_exp ) !< Compute the exponent used in the alpha function. integer ( I_P ), intent ( in ) :: S !< Number of stencils used. integer ( I_P ) :: w_exp !< Exponent used in the alpha function. w_exp = int ( S , I_P ) endfunction weno_exp","tags":"","loc":"proc/weno_exp.html","title":"weno_exp – FORESEER"},{"text":"private pure function weno_odd(S) result(w_odd) Compute the distinguisher between odd and even number of stencils. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Number of stencils used. Return Value integer(kind=I_P) Distinguishing between odd and even number of stencils. Called By proc~~weno_odd~~CalledByGraph proc~weno_odd weno_odd proc~tau tau proc~tau->proc~weno_odd proc~compute~5 compute proc~compute~5->proc~tau Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code weno_odd Source Code pure function weno_odd ( S ) result ( w_odd ) !< Compute the distinguisher between odd and even number of stencils. integer ( I_P ), intent ( in ) :: S !< Number of stencils used. integer ( I_P ) :: w_odd !< Distinguishing between odd and even number of stencils. w_odd = int ( mod ( S , 2_I_P ), I_P ) endfunction weno_odd","tags":"","loc":"proc/weno_odd.html","title":"weno_odd – FORESEER"},{"text":"private pure subroutine compute(self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. Calls proc~~compute~5~~CallsGraph proc~compute~5 compute proc~weno_exp weno_exp proc~compute~5->proc~weno_exp proc~tau tau proc~compute~5->proc~tau proc~weno_odd weno_odd proc~tau->proc~weno_odd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute Source Code pure subroutine compute ( self , beta , kappa ) !< Compute alpha. class ( alpha_rec_z ), intent ( inout ) :: self !< Alpha. class ( beta_object ), intent ( in ) :: beta !< Beta. class ( kappa_object ), intent ( in ) :: kappa !< Kappa. integer ( I_P ) :: f , s1 !< Counters. self % values_sum = 0._RPP do s1 = 0 , self % S - 1 ! stencil loops do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = kappa % values ( f , s1 ) * & (( 1._RPP + ( tau ( S = self % S , beta = beta % values ) / ( self % eps + beta % values ( f , s1 )))) ** ( weno_exp ( self % S ))) self % values_sum ( f ) = self % values_sum ( f ) + self % values ( f , s1 ) enddo enddo endsubroutine compute","tags":"","loc":"proc/compute~5.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. Source Code create Source Code subroutine create ( self , constructor ) !< Create alpha. class ( alpha_rec_z ), intent ( inout ) :: self !< Alpha. class ( base_object_constructor ), intent ( in ) :: constructor !< Alpha constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % values_sum ( 1 : 2 )) self % values = 0._RPP self % values_sum = 0._RPP endsubroutine create","tags":"","loc":"proc/create~6.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy alpha. class ( alpha_rec_z ), intent ( inout ) :: self !< Alpha. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % values_sum )) deallocate ( self % values_sum ) endsubroutine destroy","tags":"","loc":"proc/destroy~16.html","title":"destroy – FORESEER"},{"text":"private pure function description(self) result(string) Return interpolations string-description. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(in) :: self Interpolations. Return Value character(len=:),\n  allocatable String-description. Source Code description Source Code pure function description ( self ) result ( string ) !< Return interpolations string-description. class ( interpolations_rec_js ), intent ( in ) :: self !< Interpolations. character ( len = :), allocatable :: string !< String-description. #ifndef DEBUG ! error stop in pure procedure is a F2015 feature not yet supported in debug mode error stop 'interpolations_rec_js%description to be implemented, do not use!' #endif endfunction description","tags":"","loc":"proc/description~11.html","title":"description – FORESEER"},{"text":"private pure subroutine compute(self, stencil) Compute interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Source Code compute Source Code pure subroutine compute ( self , stencil ) !< Compute interpolations. class ( interpolations_rec_js ), intent ( inout ) :: self !< Interpolations. real ( RPP ), intent ( in ) :: stencil ( 1 :, 1 - self % S :) !< Stencil used for the interpolation, [1:2, 1-S:-1+S]. integer ( I_P ) :: s1 !< Counter. integer ( I_P ) :: s2 !< Counter. integer ( I_P ) :: f !< Counter. self % values = 0._RPP do s1 = 0 , self % S - 1 ! stencils loop do s2 = 0 , self % S - 1 ! values loop do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) self % values ( f , s1 ) = self % values ( f , s1 ) + self % coef ( f , s2 , s1 ) * stencil ( f + self % ff , - s2 + s1 ) enddo enddo enddo endsubroutine compute","tags":"","loc":"proc/compute~6.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. class( base_object_constructor ), intent(in) :: constructor Interpolations constructor. Calls proc~~create~7~~CallsGraph proc~create~7 create c c proc~create~7->c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code create Source Code subroutine create ( self , constructor ) !< Create interpolations. class ( interpolations_rec_js ), intent ( inout ) :: self !< Interpolations. class ( base_object_constructor ), intent ( in ) :: constructor !< Interpolations constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) self % values = 0._RPP allocate ( self % coef ( 1 : 2 , 0 : self % S - 1 , 0 : self % S - 1 )) associate ( c => self % coef ) select case ( self % S ) case ( 2 ) ! 3rd order ! 1 => left interface (i-1/2) !  cell  0           ;    cell  1 c ( 1 , 0 , 0 ) = 0.5_RPP ; c ( 1 , 1 , 0 ) = 0.5_RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 0.5_RPP ; c ( 1 , 1 , 1 ) = 1.5_RPP ! stencil 1 ! 2 => right interface (i+1/2) !  cell  0           ;    cell  1 c ( 2 , 0 , 0 ) = 1.5_RPP ; c ( 2 , 1 , 0 ) = - 0.5_RPP ! stencil 0 c ( 2 , 0 , 1 ) = 0.5_RPP ; c ( 2 , 1 , 1 ) = 0.5_RPP ! stencil 1 case ( 3 ) ! 5th order ! 1 => left interface (i-1/2) !  cell  0                 ;    cell  1                 ;    cell  2 c ( 1 , 0 , 0 ) = 1._RPP / 3._RPP ; c ( 1 , 1 , 0 ) = 5._RPP / 6._RPP ; c ( 1 , 2 , 0 ) = - 1._RPP / 6._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 6._RPP ; c ( 1 , 1 , 1 ) = 5._RPP / 6._RPP ; c ( 1 , 2 , 1 ) = 1._RPP / 3._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 3._RPP ; c ( 1 , 1 , 2 ) = - 7._RPP / 6._RPP ; c ( 1 , 2 , 2 ) = 1 1._RPP / 6._RPP ! stencil 2 ! 2 => right interface (i+1/2) !  cell  0                 ;    cell  1                 ;    cell  2 c ( 2 , 0 , 0 ) = 1 1._RPP / 6._RPP ; c ( 2 , 1 , 0 ) = - 7._RPP / 6._RPP ; c ( 2 , 2 , 0 ) = 1._RPP / 3._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 3._RPP ; c ( 2 , 1 , 1 ) = 5._RPP / 6._RPP ; c ( 2 , 2 , 1 ) = - 1._RPP / 6._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 6._RPP ; c ( 2 , 1 , 2 ) = 5._RPP / 6._RPP ; c ( 2 , 2 , 2 ) = 1._RPP / 3._RPP ! stencil 2 case ( 4 ) ! 7th order ! 1 => left interface (i-1/2) !  cell  0               ;    cell  1               ;    cell  2               ;    cell  3 c ( 1 , 0 , 0 ) = 1._RPP / 4._RPP ; c ( 1 , 1 , 0 ) = 1 3._RPP / 1 2._RPP ; c ( 1 , 2 , 0 ) = - 5._RPP / 1 2._RPP ; c ( 1 , 3 , 0 ) = 1._RPP / 1 2._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 1 2._RPP ; c ( 1 , 1 , 1 ) = 7._RPP / 1 2._RPP ; c ( 1 , 2 , 1 ) = 7._RPP / 1 2._RPP ; c ( 1 , 3 , 1 ) = - 1._RPP / 1 2._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 1 2._RPP ; c ( 1 , 1 , 2 ) = - 5._RPP / 1 2._RPP ; c ( 1 , 2 , 2 ) = 1 3._RPP / 1 2._RPP ; c ( 1 , 3 , 2 ) = 1._RPP / 4._RPP ! stencil 2 c ( 1 , 0 , 3 ) = - 1._RPP / 4._RPP ; c ( 1 , 1 , 3 ) = 1 3._RPP / 1 2._RPP ; c ( 1 , 2 , 3 ) =- 2 3._RPP / 1 2._RPP ; c ( 1 , 3 , 3 ) = 2 5._RPP / 1 2._RPP ! stencil 3 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1               ;   cell  2                ;    cell  3 c ( 2 , 0 , 0 ) = 2 5._RPP / 1 2._RPP ; c ( 2 , 1 , 0 ) =- 2 3._RPP / 1 2._RPP ; c ( 2 , 2 , 0 ) = 1 3._RPP / 1 2._RPP ; c ( 2 , 3 , 0 ) = - 1._RPP / 4._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 4._RPP ; c ( 2 , 1 , 1 ) = 1 3._RPP / 1 2._RPP ; c ( 2 , 2 , 1 ) = - 5._RPP / 1 2._RPP ; c ( 2 , 3 , 1 ) = 1._RPP / 1 2._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 1 2._RPP ; c ( 2 , 1 , 2 ) = 7._RPP / 1 2._RPP ; c ( 2 , 2 , 2 ) = 7._RPP / 1 2._RPP ; c ( 2 , 3 , 2 ) = - 1._RPP / 1 2._RPP ! stencil 2 c ( 2 , 0 , 3 ) = 1._RPP / 1 2._RPP ; c ( 2 , 1 , 3 ) = - 5._RPP / 1 2._RPP ; c ( 2 , 2 , 3 ) = 1 3._RPP / 1 2._RPP ; c ( 2 , 3 , 3 ) = 1._RPP / 4._RPP ! stencil 3 case ( 5 ) ! 9th order ! 1 => left interface (i-1/2) !  cell  0                ;    cell  1                ;    cell  2                ;    cell  3 c ( 1 , 0 , 0 ) = 1._RPP / 5._RPP ; c ( 1 , 1 , 0 ) = 7 7._RPP / 6 0._RPP ; c ( 1 , 2 , 0 ) = - 4 3._RPP / 6 0._RPP ; c ( 1 , 3 , 0 ) = 1 7._RPP / 6 0._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 2 0._RPP ; c ( 1 , 1 , 1 ) = 9._RPP / 2 0._RPP ; c ( 1 , 2 , 1 ) = 4 7._RPP / 6 0._RPP ; c ( 1 , 3 , 1 ) = - 1 3._RPP / 6 0._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 3 0._RPP ; c ( 1 , 1 , 2 ) = - 1 3._RPP / 6 0._RPP ; c ( 1 , 2 , 2 ) = 4 7._RPP / 6 0._RPP ; c ( 1 , 3 , 2 ) = 9._RPP / 2 0._RPP ! stencil 2 c ( 1 , 0 , 3 ) = - 1._RPP / 2 0._RPP ; c ( 1 , 1 , 3 ) = 1 7._RPP / 6 0._RPP ; c ( 1 , 2 , 3 ) = - 4 3._RPP / 6 0._RPP ; c ( 1 , 3 , 3 ) = 7 7._RPP / 6 0._RPP ! stencil 3 c ( 1 , 0 , 4 ) = 1._RPP / 5._RPP ; c ( 1 , 1 , 4 ) = - 2 1._RPP / 2 0._RPP ; c ( 1 , 2 , 4 ) = 13 7._RPP / 6 0._RPP ; c ( 1 , 3 , 4 ) =- 16 3._RPP / 6 0._RPP ! stencil 4 !  cell  4 c ( 1 , 4 , 0 ) = - 1._RPP / 2 0._RPP ! stencil 0 c ( 1 , 4 , 1 ) = 1._RPP / 3 0._RPP ! stencil 1 c ( 1 , 4 , 2 ) = - 1._RPP / 2 0._RPP ! stencil 2 c ( 1 , 4 , 3 ) = 1._RPP / 5._RPP ! stencil 3 c ( 1 , 4 , 4 ) = 13 7._RPP / 6 0._RPP ! stencil 4 ! 2 => right interface (i+1/2) !  cell  0               ;    cell  1               ;   cell  2                ;    cell  3 c ( 2 , 0 , 0 ) = 13 7._RPP / 6 0._RPP ; c ( 2 , 1 , 0 ) =- 16 3._RPP / 6 0._RPP ; c ( 2 , 2 , 0 ) = 13 7._RPP / 6 0._RPP ; c ( 2 , 3 , 0 ) = - 2 1._RPP / 2 0._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 5._RPP ; c ( 2 , 1 , 1 ) = 7 7._RPP / 6 0._RPP ; c ( 2 , 2 , 1 ) = - 4 3._RPP / 6 0._RPP ; c ( 2 , 3 , 1 ) = 1 7._RPP / 6 0._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 2 0._RPP ; c ( 2 , 1 , 2 ) = 9._RPP / 2 0._RPP ; c ( 2 , 2 , 2 ) = 4 7._RPP / 6 0._RPP ; c ( 2 , 3 , 2 ) = - 1 3._RPP / 6 0._RPP ! stencil 2 c ( 2 , 0 , 3 ) = 1._RPP / 3 0._RPP ; c ( 2 , 1 , 3 ) = - 1 3._RPP / 6 0._RPP ; c ( 2 , 2 , 3 ) = 4 7._RPP / 6 0._RPP ; c ( 2 , 3 , 3 ) = 9._RPP / 2 0._RPP ! stencil 3 c ( 2 , 0 , 4 ) = - 1._RPP / 2 0._RPP ; c ( 2 , 1 , 4 ) = 1 7._RPP / 6 0._RPP ; c ( 2 , 2 , 4 ) = - 4 3._RPP / 6 0._RPP ; c ( 2 , 3 , 4 ) = 7 7._RPP / 6 0._RPP ! stencil 4 !  cell  4 c ( 2 , 4 , 0 ) = 1._RPP / 5._RPP ! stencil 0 c ( 2 , 4 , 1 ) = - 1._RPP / 2 0._RPP ! stencil 1 c ( 2 , 4 , 2 ) = 1._RPP / 3 0._RPP ! stencil 2 c ( 2 , 4 , 3 ) = - 1._RPP / 2 0._RPP ! stencil 3 c ( 2 , 4 , 4 ) = 1._RPP / 5._RPP ! stencil 4 case ( 6 ) ! 11th order ! 1 => left interface (i-1/2) !  cell  0                ;    cell  1                ;    cell  2                ;    cell  3 c ( 1 , 0 , 0 ) = 1._RPP / 6._RPP ; c ( 1 , 1 , 0 ) = 2 9._RPP / 2 0._RPP ; c ( 1 , 2 , 0 ) = - 2 1._RPP / 2 0._RPP ; c ( 1 , 3 , 0 ) = 3 7._RPP / 6 0._RPP ! stencil 0 c ( 1 , 0 , 1 ) = - 1._RPP / 3 0._RPP ; c ( 1 , 1 , 1 ) = 1 1._RPP / 3 0._RPP ; c ( 1 , 2 , 1 ) = 1 9._RPP / 2 0._RPP ; c ( 1 , 3 , 1 ) = - 2 3._RPP / 6 0._RPP ! stencil 1 c ( 1 , 0 , 2 ) = 1._RPP / 6 0._RPP ; c ( 1 , 1 , 2 ) = - 2._RPP / 1 5._RPP ; c ( 1 , 2 , 2 ) = 3 7._RPP / 6 0._RPP ; c ( 1 , 3 , 2 ) = 3 7._RPP / 6 0._RPP ! stencil 2 c ( 1 , 0 , 3 ) = - 1._RPP / 6 0._RPP ; c ( 1 , 1 , 3 ) = 7._RPP / 6 0._RPP ; c ( 1 , 2 , 3 ) = - 2 3._RPP / 6 0._RPP ; c ( 1 , 3 , 3 ) = 1 9._RPP / 2 0._RPP ! stencil 3 c ( 1 , 0 , 4 ) = 1._RPP / 3 0._RPP ; c ( 1 , 1 , 4 ) = - 1 3._RPP / 6 0._RPP ; c ( 1 , 2 , 4 ) = 3 7._RPP / 6 0._RPP ; c ( 1 , 3 , 4 ) = - 2 1._RPP / 2 0._RPP ! stencil 4 c ( 1 , 0 , 5 ) = - 1._RPP / 6._RPP ; c ( 1 , 1 , 5 ) = 3 1._RPP / 3 0._RPP ; c ( 1 , 2 , 5 ) =- 16 3._RPP / 6 0._RPP ; c ( 1 , 3 , 5 ) = 7 9._RPP / 2 0._RPP ! stencil 5 !  cell  4                ;    cell  5 c ( 1 , 4 , 0 ) = - 1 3._RPP / 6 0._RPP ; c ( 1 , 5 , 0 ) = 1._RPP / 3 0._RPP ! stencil 0 c ( 1 , 4 , 1 ) = 7._RPP / 6 0._RPP ; c ( 1 , 5 , 1 ) = - 1._RPP / 6 0._RPP ! stencil 1 c ( 1 , 4 , 2 ) = - 2._RPP / 1 5._RPP ; c ( 1 , 5 , 2 ) = 1._RPP / 6 0._RPP ! stencil 2 c ( 1 , 4 , 3 ) = 1 1._RPP / 3 0._RPP ; c ( 1 , 5 , 3 ) = - 1._RPP / 3 0._RPP ! stencil 3 c ( 1 , 4 , 4 ) = 2 9._RPP / 2 0._RPP ; c ( 1 , 5 , 4 ) = 1._RPP / 6._RPP ! stencil 4 c ( 1 , 4 , 5 ) = - 7 1._RPP / 2 0._RPP ; c ( 1 , 5 , 5 ) = 4 9._RPP / 2 0._RPP ! stencil 5 ! 2 => right interface (i+1/2) !  cell  0                ;    cell  1                ;   cell  2                 ;    cell  3 c ( 2 , 0 , 0 ) = 4 9._RPP / 2 0._RPP ; c ( 2 , 1 , 0 ) = - 7 1._RPP / 2 0._RPP ; c ( 2 , 2 , 0 ) = 7 9._RPP / 2 0._RPP ; c ( 2 , 3 , 0 ) =- 16 3._RPP / 6 0._RPP ! stencil 0 c ( 2 , 0 , 1 ) = 1._RPP / 6._RPP ; c ( 2 , 1 , 1 ) = 2 9._RPP / 2 0._RPP ; c ( 2 , 2 , 1 ) = - 2 1._RPP / 2 0._RPP ; c ( 2 , 3 , 1 ) = 3 7._RPP / 6 0._RPP ! stencil 1 c ( 2 , 0 , 2 ) = - 1._RPP / 3 0._RPP ; c ( 2 , 1 , 2 ) = 1 1._RPP / 3 0._RPP ; c ( 2 , 2 , 2 ) = 1 9._RPP / 2 0._RPP ; c ( 2 , 3 , 2 ) = - 2 3._RPP / 6 0._RPP ! stencil 2 c ( 2 , 0 , 3 ) = 1._RPP / 6 0._RPP ; c ( 2 , 1 , 3 ) = - 2._RPP / 1 5._RPP ; c ( 2 , 2 , 3 ) = 3 7._RPP / 6 0._RPP ; c ( 2 , 3 , 3 ) = 3 7._RPP / 6 0._RPP ! stencil 3 c ( 2 , 0 , 4 ) = - 1._RPP / 6 0._RPP ; c ( 2 , 1 , 4 ) = 7._RPP / 6 0._RPP ; c ( 2 , 2 , 4 ) = - 2 3._RPP / 6 0._RPP ; c ( 2 , 3 , 4 ) = 1 9._RPP / 2 0._RPP ! stencil 4 c ( 2 , 0 , 5 ) = 1._RPP / 3 0._RPP ; c ( 2 , 1 , 5 ) = - 1 3._RPP / 6 0._RPP ; c ( 2 , 2 , 5 ) = 3 7._RPP / 6 0._RPP ; c ( 2 , 3 , 5 ) = - 2 1._RPP / 2 0._RPP ! stencil 5 !  cell  4                ;    cell  5 c ( 2 , 4 , 0 ) = 3 1._RPP / 3 0._RPP ; c ( 2 , 5 , 0 ) = - 1._RPP / 6._RPP ! stencil 0 c ( 2 , 4 , 1 ) = - 1 3._RPP / 6 0._RPP ; c ( 2 , 5 , 1 ) = 1._RPP / 3 0._RPP ! stencil 1 c ( 2 , 4 , 2 ) = 7._RPP / 6 0._RPP ; c ( 2 , 5 , 2 ) = - 1._RPP / 6 0._RPP ! stencil 2 c ( 2 , 4 , 3 ) = - 2._RPP / 1 5._RPP ; c ( 2 , 5 , 3 ) = 1._RPP / 6 0._RPP ! stencil 3 c ( 2 , 4 , 4 ) = 1 1._RPP / 3 0._RPP ; c ( 2 , 5 , 4 ) = - 1._RPP / 3 0._RPP ! stencil 4 c ( 2 , 4 , 5 ) = 2 9._RPP / 2 0._RPP ; c ( 2 , 5 , 5 ) = 1._RPP / 6._RPP ! stencil 5 case ( 7 ) ! 13th order !! 1 => left interface (i-1/2) !  cell  0                  ;    cell  1                  ;    cell  2 !c(1,0,0)=    1._RPP/7._RPP  ; c(1,1,0)=  223._RPP/140._RPP; c(1,2,0)= -197._RPP/140._RPP  ! stencil 0 !c(1,0,1)=   -1._RPP/42._RPP ; c(1,1,1)=   13._RPP/42._RPP ; c(1,2,1)=  153._RPP/140._RPP  ! stencil 1 !c(1,0,2)=    1._RPP/105._RPP; c(1,1,2)=  -19._RPP/210._RPP; c(1,2,2)=  107._RPP/210._RPP  ! stencil 2 !c(1,0,3)=   -1._RPP/140._RPP; c(1,1,3)=    5._RPP/84._RPP ; c(1,2,3)= -101._RPP/420._RPP  ! stencil 3 !c(1,0,4)=    1._RPP/105._RPP; c(1,1,4)=  -31._RPP/420._RPP; c(1,2,4)=  109._RPP/420._RPP  ! stencil 4 !c(1,0,5)=   -1._RPP/42._RPP ; c(1,1,5)=  -37._RPP/210._RPP; c(1,2,5)= -241._RPP/420._RPP  ! stencil 5 !c(1,0,6)=   -1._RPP/7._RPP  ; c(1,1,6)=  -43._RPP/42._RPP ; c(1,2,6)=  667._RPP/210._RPP  ! stencil 6 !!  cell  3                       cell  4                  ;    cell  5 !c(1,3,0)=  153._RPP/140._RPP; c(1,4,0)= -241._RPP/420._RPP; c(1,5,0)=   37._RPP/210._RPP  ! stencil 0 !c(1,3,1)= -241._RPP/420._RPP; c(1,4,1)=  109._RPP/420._RPP; c(1,5,1)=  -31._RPP/420._RPP  ! stencil 1 !c(1,3,2)=  319._RPP/420._RPP; c(1,4,2)= -101._RPP/420._RPP; c(1,5,2)=    5._RPP/84._RPP   ! stencil 2 !c(1,3,3)=  319._RPP/420._RPP; c(1,4,3)=  107._RPP/210._RPP; c(1,5,3)=  -19._RPP/210._RPP  ! stencil 3 !c(1,3,4)= -241._RPP/420._RPP; c(1,4,4)=  153._RPP/140._RPP; c(1,5,4)=   13._RPP/42._RPP   ! stencil 4 !c(1,3,5)=  153._RPP/140._RPP; c(1,4,5)= -197._RPP/140._RPP; c(1,5,5)=  223._RPP/140._RPP  ! stencil 5 !c(1,3,6)=-2341._RPP/420._RPP; c(1,4,6)=  853._RPP/140._RPP; c(1,5,6)= -617._RPP/140._RPP  ! stencil 6 !!  cell  6 !c(1,6,0)=   -1._RPP/42._RPP   ! stencil 0 !c(1,6,1)=    1._RPP/105._RPP  ! stencil 1 !c(1,6,2)=   -1._RPP/140._RPP  ! stencil 2 !c(1,6,3)=    1._RPP/105._RPP  ! stencil 3 !c(1,6,4)=   -1._RPP/42._RPP   ! stencil 4 !c(1,6,5)=    1._RPP/7._RPP    ! stencil 5 !c(1,6,6)=  363._RPP/140._RPP  ! stencil 6 !! 2 => right interface (i+1/2) !!  cell  0                  ;    cell  1                  ;    cell  2 !c(2,0,0)=  363._RPP/140._RPP; c(2,1,0)= -617._RPP/140._RPP; c(2,2,0)=  853._RPP/140._RPP  ! stencil 0 !c(2,0,1)=    1._RPP/7._RPP  ; c(2,1,1)=  223._RPP/140._RPP; c(2,2,1)= -197._RPP/140._RPP  ! stencil 1 !c(2,0,2)=   -1._RPP/42._RPP ; c(2,1,2)=   13._RPP/42._RPP ; c(2,2,2)=  153._RPP/140._RPP  ! stencil 2 !c(2,0,3)=    1._RPP/105._RPP; c(2,1,3)=  -19._RPP/210._RPP; c(2,2,3)=  107._RPP/210._RPP  ! stencil 3 !c(2,0,4)=   -1._RPP/140._RPP; c(2,1,4)=    5._RPP/84._RPP ; c(2,2,4)= -101._RPP/420._RPP  ! stencil 4 !c(2,0,5)=    1._RPP/105._RPP; c(2,1,5)=  -31._RPP/420._RPP; c(2,2,5)=  109._RPP/420._RPP  ! stencil 5 !c(2,0,6)=   -1._RPP/42._RPP ; c(2,1,6)=   37._RPP/210._RPP; c(2,2,6)= -241._RPP/420._RPP  ! stencil 6 !!  cell  3                  ;    cell  4                  ;    cell  5 !c(2,3,0)=-2341._RPP/420._RPP; c(2,4,0)=  667._RPP/210._RPP; c(2,5,0)=  -43._RPP/42._RPP   ! stencil 0 !c(2,3,1)=  153._RPP/140._RPP; c(2,4,1)= -241._RPP/420._RPP; c(2,5,1)=   37._RPP/210._RPP  ! stencil 1 !c(2,3,2)= -241._RPP/420._RPP; c(2,4,2)=  109._RPP/420._RPP; c(2,5,2)=  -31._RPP/420._RPP  ! stencil 2 !c(2,3,3)=  319._RPP/420._RPP; c(2,4,3)= -101._RPP/420._RPP; c(2,5,3)=    5._RPP/84._RPP   ! stencil 3 !c(2,3,4)=  319._RPP/420._RPP; c(2,4,4)=  107._RPP/210._RPP; c(2,5,4)=  -19._RPP/210._RPP  ! stencil 4 !c(2,3,5)= -241._RPP/420._RPP; c(2,4,5)=  153._RPP/140._RPP; c(2,5,5)=   13._RPP/42._RPP   ! stencil 5 !c(2,3,6)=  153._RPP/140._RPP; c(2,4,6)= -197._RPP/140._RPP; c(2,5,6)=  223._RPP/140._RPP  ! stencil 6 !!  cell  6 !c(2,6,0)=    1._RPP/7._RPP    ! stencil 0 !c(2,6,1)=   -1._RPP/42._RPP   ! stencil 1 !c(2,6,2)=    1._RPP/105._RPP  ! stencil 2 !c(2,6,3)=   -1._RPP/140._RPP  ! stencil 3 !c(2,6,4)=    1._RPP/105._RPP  ! stencil 4 !c(2,6,5)=   -1._RPP/42._RPP   ! stencil 5 !c(2,6,6)=    1._RPP/7._RPP    ! stencil 6 ! 1 => left interface (i-1/2) c ( 1 , 0 , 6 ) = 6 0._RPP / 42 0._RPP ; c ( 1 , 0 , 5 ) =- 1 0._RPP / 42 0._RPP ; c ( 1 , 0 , 4 ) = 4._RPP / 42 0._RPP ; c ( 1 , 0 , 3 ) =- 3._RPP / 42 0._RPP c ( 1 , 1 , 6 ) =- 43 0._RPP / 42 0._RPP ; c ( 1 , 1 , 5 ) = 7 4._RPP / 42 0._RPP ; c ( 1 , 1 , 4 ) =- 3 1._RPP / 42 0._RPP ; c ( 1 , 1 , 3 ) = 2 5._RPP / 42 0._RPP c ( 1 , 2 , 6 ) = 133 4._RPP / 42 0._RPP ; c ( 1 , 2 , 5 ) =- 24 1._RPP / 42 0._RPP ; c ( 1 , 2 , 4 ) = 10 9._RPP / 42 0._RPP ; c ( 1 , 2 , 3 ) =- 10 1._RPP / 42 0._RPP c ( 1 , 3 , 6 ) =- 234 1._RPP / 42 0._RPP ; c ( 1 , 3 , 5 ) = 45 9._RPP / 42 0._RPP ; c ( 1 , 3 , 4 ) =- 24 1._RPP / 42 0._RPP ; c ( 1 , 3 , 3 ) = 31 9._RPP / 42 0._RPP c ( 1 , 4 , 6 ) = 255 9._RPP / 42 0._RPP ; c ( 1 , 4 , 5 ) =- 59 1._RPP / 42 0._RPP ; c ( 1 , 4 , 4 ) = 45 9._RPP / 42 0._RPP ; c ( 1 , 4 , 3 ) = 21 4._RPP / 42 0._RPP c ( 1 , 5 , 6 ) =- 185 1._RPP / 42 0._RPP ; c ( 1 , 5 , 5 ) = 66 9._RPP / 42 0._RPP ; c ( 1 , 5 , 4 ) = 13 0._RPP / 42 0._RPP ; c ( 1 , 5 , 3 ) =- 3 8._RPP / 42 0._RPP c ( 1 , 6 , 6 ) = 108 9._RPP / 42 0._RPP ; c ( 1 , 6 , 5 ) = 6 0._RPP / 42 0._RPP ; c ( 1 , 6 , 4 ) =- 1 0._RPP / 42 0._RPP ; c ( 1 , 6 , 3 ) = 4._RPP / 42 0._RPP c ( 1 , 0 , 2 ) = 4._RPP / 42 0._RPP ; c ( 1 , 0 , 1 ) =- 1 0._RPP / 42 0._RPP ; c ( 1 , 0 , 0 ) = 6 0._RPP / 42 0._RPP c ( 1 , 1 , 2 ) =- 3 8._RPP / 42 0._RPP ; c ( 1 , 1 , 1 ) = 13 0._RPP / 42 0._RPP ; c ( 1 , 1 , 0 ) = 66 9._RPP / 42 0._RPP c ( 1 , 2 , 2 ) = 21 4._RPP / 42 0._RPP ; c ( 1 , 2 , 1 ) = 45 9._RPP / 42 0._RPP ; c ( 1 , 2 , 0 ) =- 59 1._RPP / 42 0._RPP c ( 1 , 3 , 2 ) = 31 9._RPP / 42 0._RPP ; c ( 1 , 3 , 1 ) =- 24 1._RPP / 42 0._RPP ; c ( 1 , 3 , 0 ) = 45 9._RPP / 42 0._RPP c ( 1 , 4 , 2 ) =- 10 1._RPP / 42 0._RPP ; c ( 1 , 4 , 1 ) = 10 9._RPP / 42 0._RPP ; c ( 1 , 4 , 0 ) =- 24 1._RPP / 42 0._RPP c ( 1 , 5 , 2 ) = 2 5._RPP / 42 0._RPP ; c ( 1 , 5 , 1 ) =- 3 1._RPP / 42 0._RPP ; c ( 1 , 5 , 0 ) = 7 4._RPP / 42 0._RPP c ( 1 , 6 , 2 ) =- 3._RPP / 42 0._RPP ; c ( 1 , 6 , 1 ) = 4._RPP / 42 0._RPP ; c ( 1 , 6 , 0 ) =- 1 0._RPP / 42 0._RPP ! 2 => right interface (i+1/2) c ( 2 , 6 , 0 ) = 6 0._RPP / 42 0._RPP ; c ( 2 , 6 , 1 ) =- 1 0._RPP / 42 0._RPP ; c ( 2 , 6 , 2 ) = 4._RPP / 42 0._RPP ; c ( 2 , 6 , 3 ) =- 3._RPP / 42 0._RPP c ( 2 , 5 , 0 ) =- 43 0._RPP / 42 0._RPP ; c ( 2 , 5 , 1 ) = 7 4._RPP / 42 0._RPP ; c ( 2 , 5 , 2 ) =- 3 1._RPP / 42 0._RPP ; c ( 2 , 5 , 3 ) = 2 5._RPP / 42 0._RPP c ( 2 , 4 , 0 ) = 133 4._RPP / 42 0._RPP ; c ( 2 , 4 , 1 ) =- 24 1._RPP / 42 0._RPP ; c ( 2 , 4 , 2 ) = 10 9._RPP / 42 0._RPP ; c ( 2 , 4 , 3 ) =- 10 1._RPP / 42 0._RPP c ( 2 , 3 , 0 ) =- 234 1._RPP / 42 0._RPP ; c ( 2 , 3 , 1 ) = 45 9._RPP / 42 0._RPP ; c ( 2 , 3 , 2 ) =- 24 1._RPP / 42 0._RPP ; c ( 2 , 3 , 3 ) = 31 9._RPP / 42 0._RPP c ( 2 , 2 , 0 ) = 255 9._RPP / 42 0._RPP ; c ( 2 , 2 , 1 ) =- 59 1._RPP / 42 0._RPP ; c ( 2 , 2 , 2 ) = 45 9._RPP / 42 0._RPP ; c ( 2 , 2 , 3 ) = 21 4._RPP / 42 0._RPP c ( 2 , 1 , 0 ) =- 185 1._RPP / 42 0._RPP ; c ( 2 , 1 , 1 ) = 66 9._RPP / 42 0._RPP ; c ( 2 , 1 , 2 ) = 13 0._RPP / 42 0._RPP ; c ( 2 , 1 , 3 ) =- 3 8._RPP / 42 0._RPP c ( 2 , 0 , 0 ) = 108 9._RPP / 42 0._RPP ; c ( 2 , 0 , 1 ) = 6 0._RPP / 42 0._RPP ; c ( 2 , 0 , 2 ) =- 1 0._RPP / 42 0._RPP ; c ( 2 , 0 , 3 ) = 4._RPP / 42 0._RPP c ( 2 , 6 , 4 ) = 4._RPP / 42 0._RPP ; c ( 2 , 6 , 5 ) =- 1 0._RPP / 42 0._RPP ; c ( 2 , 6 , 6 ) = 6 0._RPP / 42 0._RPP c ( 2 , 5 , 4 ) =- 3 8._RPP / 42 0._RPP ; c ( 2 , 5 , 5 ) = 13 0._RPP / 42 0._RPP ; c ( 2 , 5 , 6 ) = 66 9._RPP / 42 0._RPP c ( 2 , 4 , 4 ) = 21 4._RPP / 42 0._RPP ; c ( 2 , 4 , 5 ) = 45 9._RPP / 42 0._RPP ; c ( 2 , 4 , 6 ) =- 59 1._RPP / 42 0._RPP c ( 2 , 3 , 4 ) = 31 9._RPP / 42 0._RPP ; c ( 2 , 3 , 5 ) =- 24 1._RPP / 42 0._RPP ; c ( 2 , 3 , 6 ) = 45 9._RPP / 42 0._RPP c ( 2 , 2 , 4 ) =- 10 1._RPP / 42 0._RPP ; c ( 2 , 2 , 5 ) = 10 9._RPP / 42 0._RPP ; c ( 2 , 2 , 6 ) =- 24 1._RPP / 42 0._RPP c ( 2 , 1 , 4 ) = 2 5._RPP / 42 0._RPP ; c ( 2 , 1 , 5 ) =- 3 1._RPP / 42 0._RPP ; c ( 2 , 1 , 6 ) = 7 4._RPP / 42 0._RPP c ( 2 , 0 , 4 ) =- 3._RPP / 42 0._RPP ; c ( 2 , 0 , 5 ) = 4._RPP / 42 0._RPP ; c ( 2 , 0 , 6 ) =- 1 0._RPP / 42 0._RPP case ( 8 ) ! 15th order !! 1 => left interface (i-1/2) !!  cell  0                  ;    cell  1                  ;    cell  2 !c(1,0,0)=    7._RPP/56._RPP ; c(1,1,0)= 1443._RPP/840._RPP; c(1,2,0)=-1497._RPP/840._RPP  ! stencil 0 !c(1,0,1)=   -1._RPP/56._RPP ; c(1,1,1)=   15._RPP/56._RPP ; c(1,2,1)= 1023._RPP/840._RPP  ! stencil 1 !c(1,0,2)=    1._RPP/168._RPP; c(1,1,2)=  -11._RPP/168._RPP; c(1,2,2)=   73._RPP/168._RPP  ! stencil 2 !c(1,0,3)=   -3._RPP/840._RPP; c(1,1,3)=   29._RPP/840._RPP; c(1,2,3)= -139._RPP/840._RPP  ! stencil 3 !c(1,0,4)=    3._RPP/840._RPP; c(1,1,4)=  -27._RPP/840._RPP; c(1,2,4)=  113._RPP/840._RPP  ! stencil 4 !c(1,0,5)=   -1._RPP/168._RPP; c(1,1,5)=   43._RPP/840._RPP; c(1,2,5)= -167._RPP/840._RPP  ! stencil 5 !c(1,0,6)=    1._RPP/56._RPP ; c(1,1,6)=  -25._RPP/168._RPP; c(1,2,6)=  463._RPP/840._RPP  ! stencil 6 !c(1,0,7)=   -7._RPP/56._RPP ; c(1,1,7)=   57._RPP/56._RPP ; c(1,2,7)= -613._RPP/168._RPP  ! stencil 7 !!  cell  3                  ;    cell  4                  ;    cell  5 !c(1,3,0)= 1443._RPP/840._RPP; c(1,4,0)=-1007._RPP/840._RPP; c(1,5,0)=  463._RPP/840._RPP  ! stencil 0 !c(1,3,1)= -657._RPP/840._RPP; c(1,4,1)=  393._RPP/840._RPP; c(1,5,1)= -167._RPP/840._RPP  ! stencil 1 !c(1,3,2)=  743._RPP/840._RPP; c(1,4,2)= -307._RPP/840._RPP; c(1,5,2)=  113._RPP/840._RPP  ! stencil 2 !c(1,3,3)=  533._RPP/840._RPP; c(1,4,3)=  533._RPP/840._RPP; c(1,5,3)= -139._RPP/840._RPP  ! stencil 3 !c(1,3,4)= -307._RPP/840._RPP; c(1,4,4)=  743._RPP/840._RPP; c(1,5,4)=   73._RPP/168._RPP  ! stencil 4 !c(1,3,5)=  393._RPP/840._RPP; c(1,4,5)= -657._RPP/840._RPP; c(1,5,5)= 1023._RPP/840._RPP  ! stencil 5 !c(1,3,6)=-1007._RPP/840._RPP; c(1,4,6)= 1443._RPP/840._RPP; c(1,5,6)=-1497._RPP/840._RPP  ! stencil 6 !c(1,3,7)= 6343._RPP/840._RPP; c(1,4,7)=-8357._RPP/840._RPP; c(1,5,7)= 7323._RPP/840._RPP  ! stencil 7 !!  cell  6                  ;    cell  7 !c(1,6,0)=  -25._RPP/168._RPP; c(1,7,0)=    1._RPP/56._RPP   ! stencil 0 !c(1,6,1)=   43._RPP/840._RPP; c(1,7,1)=   -1._RPP/168._RPP  ! stencil 1 !c(1,6,2)=  -27._RPP/840._RPP; c(1,7,2)=    3._RPP/840._RPP  ! stencil 2 !c(1,6,3)=   29._RPP/840._RPP; c(1,7,3)=   -3._RPP/840._RPP  ! stencil 3 !c(1,6,4)=  -11._RPP/168._RPP; c(1,7,4)=    1._RPP/168._RPP  ! stencil 4 !c(1,6,5)=   15._RPP/56._RPP ; c(1,7,5)=   -1._RPP/56._RPP   ! stencil 5 !c(1,6,6)= 1443._RPP/840._RPP; c(1,7,6)=    7._RPP/56._RPP   ! stencil 6 !c(1,6,7)=-4437._RPP/840._RPP; c(1,7,7)= 2283._RPP/840._RPP  ! stencil 7 !! 2 => right interface (i+1/2) !!  cell  0                  ;    cell  1                  ;    cell  2 !c(2,0,0)= 2283._RPP/840._RPP; c(2,1,0)=-4437._RPP/840._RPP; c(2,2,0)= 7323._RPP/840._RPP  ! stencil 0 !c(2,0,1)=    7._RPP/56._RPP ; c(2,1,1)= 1443._RPP/840._RPP; c(2,2,1)=-1497._RPP/840._RPP  ! stencil 1 !c(2,0,2)=   -1._RPP/56._RPP ; c(2,1,2)=   15._RPP/56._RPP ; c(2,2,2)= 1023._RPP/840._RPP  ! stencil 2 !c(2,0,3)=    1._RPP/168._RPP; c(2,1,3)=  -11._RPP/168._RPP; c(2,2,3)=   73._RPP/168._RPP  ! stencil 3 !c(2,0,4)=   -3._RPP/840._RPP; c(2,1,4)=   29._RPP/840._RPP; c(2,2,4)= -139._RPP/840._RPP  ! stencil 4 !c(2,0,5)=    3._RPP/840._RPP; c(2,1,5)=  -27._RPP/840._RPP; c(2,2,5)=  113._RPP/840._RPP  ! stencil 5 !c(2,0,6)=   -1._RPP/168._RPP; c(2,1,6)=   43._RPP/840._RPP; c(2,2,6)= -167._RPP/840._RPP  ! stencil 6 !c(2,0,7)=    1._RPP/56._RPP ; c(2,1,7)=  -25._RPP/168._RPP; c(2,2,7)=  463._RPP/840._RPP  ! stencil 7 !!  cell  3                  ;    cell  4                  ;    cell  5 !c(2,3,0)=-8357._RPP/840._RPP; c(2,4,0)= 6343._RPP/840._RPP; c(2,5,0)= -613._RPP/168._RPP  ! stencil 0 !c(2,3,1)= 1443._RPP/840._RPP; c(2,4,1)=-1007._RPP/840._RPP; c(2,5,1)=  463._RPP/840._RPP  ! stencil 1 !c(2,3,2)= -657._RPP/840._RPP; c(2,4,2)=  393._RPP/840._RPP; c(2,5,2)= -167._RPP/840._RPP  ! stencil 2 !c(2,3,3)=  743._RPP/840._RPP; c(2,4,3)= -307._RPP/840._RPP; c(2,5,3)=  113._RPP/840._RPP  ! stencil 3 !c(2,3,4)=  533._RPP/840._RPP; c(2,4,4)=  533._RPP/840._RPP; c(2,5,4)= -139._RPP/840._RPP  ! stencil 4 !c(2,3,5)= -307._RPP/840._RPP; c(2,4,5)=  743._RPP/840._RPP; c(2,5,5)=   73._RPP/168._RPP  ! stencil 5 !c(2,3,6)=  393._RPP/840._RPP; c(2,4,6)= -657._RPP/840._RPP; c(2,5,6)= 1023._RPP/840._RPP  ! stencil 6 !c(2,3,7)=-1007._RPP/840._RPP; c(2,4,7)= 1443._RPP/840._RPP; c(2,5,7)=-1497._RPP/840._RPP  ! stencil 7 !!  cell  6                  ;    cell  7 !c(2,6,0)=   57._RPP/56._RPP ; c(2,7,0)=   -7._RPP/56._RPP   ! stencil 0 !c(2,6,1)=  -25._RPP/168._RPP; c(2,7,1)=    1._RPP/56._RPP   ! stencil 1 !c(2,6,2)=   43._RPP/840._RPP; c(2,7,2)=   -1._RPP/168._RPP  ! stencil 2 !c(2,6,3)=  -27._RPP/840._RPP; c(2,7,3)=    3._RPP/840._RPP  ! stencil 3 !c(2,6,4)=   29._RPP/840._RPP; c(2,7,4)=   -3._RPP/840._RPP  ! stencil 4 !c(2,6,5)=  -11._RPP/168._RPP; c(2,7,5)=    1._RPP/168._RPP  ! stencil 5 !c(2,6,6)=   15._RPP/56._RPP ; c(2,7,6)=   -1._RPP/56._RPP   ! stencil 6 !c(2,6,7)= 1443._RPP/840._RPP; c(2,7,7)=    7._RPP/56._RPP   ! stencil 7 ! 1 => left interface (i-1/2) c ( 1 , 0 , 7 ) =- 10 5._RPP / 84 0._RPP ; c ( 1 , 0 , 6 ) = 1 5._RPP / 84 0._RPP ; c ( 1 , 0 , 5 ) =- 5._RPP / 84 0._RPP ; c ( 1 , 0 , 4 ) = 3._RPP / 84 0._RPP c ( 1 , 1 , 7 ) = 85 5._RPP / 84 0._RPP ; c ( 1 , 1 , 6 ) =- 12 5._RPP / 84 0._RPP ; c ( 1 , 1 , 5 ) = 4 3._RPP / 84 0._RPP ; c ( 1 , 1 , 4 ) =- 2 7._RPP / 84 0._RPP c ( 1 , 2 , 7 ) =- 306 5._RPP / 84 0._RPP ; c ( 1 , 2 , 6 ) = 46 3._RPP / 84 0._RPP ; c ( 1 , 2 , 5 ) =- 16 7._RPP / 84 0._RPP ; c ( 1 , 2 , 4 ) = 11 3._RPP / 84 0._RPP c ( 1 , 3 , 7 ) = 634 3._RPP / 84 0._RPP ; c ( 1 , 3 , 6 ) =- 100 7._RPP / 84 0._RPP ; c ( 1 , 3 , 5 ) = 39 3._RPP / 84 0._RPP ; c ( 1 , 3 , 4 ) =- 30 7._RPP / 84 0._RPP c ( 1 , 4 , 7 ) =- 835 7._RPP / 84 0._RPP ; c ( 1 , 4 , 6 ) = 144 3._RPP / 84 0._RPP ; c ( 1 , 4 , 5 ) =- 65 7._RPP / 84 0._RPP ; c ( 1 , 4 , 4 ) = 74 3._RPP / 84 0._RPP c ( 1 , 5 , 7 ) = 732 3._RPP / 84 0._RPP ; c ( 1 , 5 , 6 ) =- 149 7._RPP / 84 0._RPP ; c ( 1 , 5 , 5 ) = 102 3._RPP / 84 0._RPP ; c ( 1 , 5 , 4 ) = 36 5._RPP / 84 0._RPP c ( 1 , 6 , 7 ) =- 443 7._RPP / 84 0._RPP ; c ( 1 , 6 , 6 ) = 144 3._RPP / 84 0._RPP ; c ( 1 , 6 , 5 ) = 22 5._RPP / 84 0._RPP ; c ( 1 , 6 , 4 ) =- 5 5._RPP / 84 0._RPP c ( 1 , 7 , 7 ) = 228 3._RPP / 84 0._RPP ; c ( 1 , 7 , 6 ) = 10 5._RPP / 84 0._RPP ; c ( 1 , 7 , 5 ) =- 1 5._RPP / 84 0._RPP ; c ( 1 , 7 , 4 ) = 5._RPP / 84 0._RPP c ( 1 , 0 , 3 ) =- 3._RPP / 84 0._RPP ; c ( 1 , 0 , 2 ) = 5._RPP / 84 0._RPP ; c ( 1 , 0 , 1 ) =- 1 5._RPP / 84 0._RPP ; c ( 1 , 0 , 0 ) = 10 5._RPP / 84 0._RPP c ( 1 , 1 , 3 ) = 2 9._RPP / 84 0._RPP ; c ( 1 , 1 , 2 ) =- 5 5._RPP / 84 0._RPP ; c ( 1 , 1 , 1 ) = 22 5._RPP / 84 0._RPP ; c ( 1 , 1 , 0 ) = 144 3._RPP / 84 0._RPP c ( 1 , 2 , 3 ) =- 13 9._RPP / 84 0._RPP ; c ( 1 , 2 , 2 ) = 36 5._RPP / 84 0._RPP ; c ( 1 , 2 , 1 ) = 102 3._RPP / 84 0._RPP ; c ( 1 , 2 , 0 ) =- 149 7._RPP / 84 0._RPP c ( 1 , 3 , 3 ) = 53 3._RPP / 84 0._RPP ; c ( 1 , 3 , 2 ) = 74 3._RPP / 84 0._RPP ; c ( 1 , 3 , 1 ) =- 65 7._RPP / 84 0._RPP ; c ( 1 , 3 , 0 ) = 144 3._RPP / 84 0._RPP c ( 1 , 4 , 3 ) = 53 3._RPP / 84 0._RPP ; c ( 1 , 4 , 2 ) =- 30 7._RPP / 84 0._RPP ; c ( 1 , 4 , 1 ) = 39 3._RPP / 84 0._RPP ; c ( 1 , 4 , 0 ) =- 100 7._RPP / 84 0._RPP c ( 1 , 5 , 3 ) =- 13 9._RPP / 84 0._RPP ; c ( 1 , 5 , 2 ) = 11 3._RPP / 84 0._RPP ; c ( 1 , 5 , 1 ) =- 16 7._RPP / 84 0._RPP ; c ( 1 , 5 , 0 ) = 46 3._RPP / 84 0._RPP c ( 1 , 6 , 3 ) = 2 9._RPP / 84 0._RPP ; c ( 1 , 6 , 2 ) =- 2 7._RPP / 84 0._RPP ; c ( 1 , 6 , 1 ) = 4 3._RPP / 84 0._RPP ; c ( 1 , 6 , 0 ) =- 12 5._RPP / 84 0._RPP c ( 1 , 7 , 3 ) =- 3._RPP / 84 0._RPP ; c ( 1 , 7 , 2 ) = 3._RPP / 84 0._RPP ; c ( 1 , 7 , 1 ) =- 5._RPP / 84 0._RPP ; c ( 1 , 7 , 0 ) = 1 5._RPP / 840 _ RPP ! 2 => right interface (i+1/2) c ( 2 , 7 , 0 ) =- 10 5._RPP / 84 0._RPP ; c ( 2 , 7 , 1 ) = 1 5._RPP / 84 0._RPP ; c ( 2 , 7 , 2 ) =- 5._RPP / 84 0._RPP ; c ( 2 , 7 , 3 ) = 3._RPP / 84 0._RPP c ( 2 , 6 , 0 ) = 85 5._RPP / 84 0._RPP ; c ( 2 , 6 , 1 ) =- 12 5._RPP / 84 0._RPP ; c ( 2 , 6 , 2 ) = 4 3._RPP / 84 0._RPP ; c ( 2 , 6 , 3 ) =- 2 7._RPP / 84 0._RPP c ( 2 , 5 , 0 ) =- 306 5._RPP / 84 0._RPP ; c ( 2 , 5 , 1 ) = 46 3._RPP / 84 0._RPP ; c ( 2 , 5 , 2 ) =- 16 7._RPP / 84 0._RPP ; c ( 2 , 5 , 3 ) = 11 3._RPP / 84 0._RPP c ( 2 , 4 , 0 ) = 634 3._RPP / 84 0._RPP ; c ( 2 , 4 , 1 ) =- 100 7._RPP / 84 0._RPP ; c ( 2 , 4 , 2 ) = 39 3._RPP / 84 0._RPP ; c ( 2 , 4 , 3 ) =- 30 7._RPP / 84 0._RPP c ( 2 , 3 , 0 ) =- 835 7._RPP / 84 0._RPP ; c ( 2 , 3 , 1 ) = 144 3._RPP / 84 0._RPP ; c ( 2 , 3 , 2 ) =- 65 7._RPP / 84 0._RPP ; c ( 2 , 3 , 3 ) = 74 3._RPP / 84 0._RPP c ( 2 , 2 , 0 ) = 732 3._RPP / 84 0._RPP ; c ( 2 , 2 , 1 ) =- 149 7._RPP / 84 0._RPP ; c ( 2 , 2 , 2 ) = 102 3._RPP / 84 0._RPP ; c ( 2 , 2 , 3 ) = 36 5._RPP / 84 0._RPP c ( 2 , 1 , 0 ) =- 443 7._RPP / 84 0._RPP ; c ( 2 , 1 , 1 ) = 144 3._RPP / 84 0._RPP ; c ( 2 , 1 , 2 ) = 22 5._RPP / 84 0._RPP ; c ( 2 , 1 , 3 ) =- 5 5._RPP / 84 0._RPP c ( 2 , 0 , 0 ) = 228 3._RPP / 84 0._RPP ; c ( 2 , 0 , 1 ) = 10 5._RPP / 84 0._RPP ; c ( 2 , 0 , 2 ) =- 1 5._RPP / 84 0._RPP ; c ( 2 , 0 , 3 ) = 5._RPP / 84 0._RPP c ( 2 , 7 , 4 ) =- 3._RPP / 84 0._RPP ; c ( 2 , 7 , 5 ) = 5._RPP / 84 0._RPP ; c ( 2 , 7 , 6 ) =- 1 5._RPP / 84 0._RPP ; c ( 2 , 7 , 7 ) = 10 5._RPP / 84 0._RPP c ( 2 , 6 , 4 ) = 2 9._RPP / 84 0._RPP ; c ( 2 , 6 , 5 ) =- 5 5._RPP / 84 0._RPP ; c ( 2 , 6 , 6 ) = 22 5._RPP / 84 0._RPP ; c ( 2 , 6 , 7 ) = 144 3._RPP / 84 0._RPP c ( 2 , 5 , 4 ) =- 13 9._RPP / 84 0._RPP ; c ( 2 , 5 , 5 ) = 36 5._RPP / 84 0._RPP ; c ( 2 , 5 , 6 ) = 102 3._RPP / 84 0._RPP ; c ( 2 , 5 , 7 ) =- 149 7._RPP / 84 0._RPP c ( 2 , 4 , 4 ) = 53 3._RPP / 84 0._RPP ; c ( 2 , 4 , 5 ) = 74 3._RPP / 84 0._RPP ; c ( 2 , 4 , 6 ) =- 65 7._RPP / 84 0._RPP ; c ( 2 , 4 , 7 ) = 144 3._RPP / 84 0._RPP c ( 2 , 3 , 4 ) = 53 3._RPP / 84 0._RPP ; c ( 2 , 3 , 5 ) =- 30 7._RPP / 84 0._RPP ; c ( 2 , 3 , 6 ) = 39 3._RPP / 84 0._RPP ; c ( 2 , 3 , 7 ) =- 100 7._RPP / 84 0._RPP c ( 2 , 2 , 4 ) =- 13 9._RPP / 84 0._RPP ; c ( 2 , 2 , 5 ) = 11 3._RPP / 84 0._RPP ; c ( 2 , 2 , 6 ) =- 16 7._RPP / 84 0._RPP ; c ( 2 , 2 , 7 ) = 46 3._RPP / 84 0._RPP c ( 2 , 1 , 4 ) = 2 9._RPP / 84 0._RPP ; c ( 2 , 1 , 5 ) =- 2 7._RPP / 84 0._RPP ; c ( 2 , 1 , 6 ) = 4 3._RPP / 84 0._RPP ; c ( 2 , 1 , 7 ) =- 12 5._RPP / 84 0._RPP c ( 2 , 0 , 4 ) =- 3._RPP / 84 0._RPP ; c ( 2 , 0 , 5 ) = 3._RPP / 84 0._RPP ; c ( 2 , 0 , 6 ) =- 5._RPP / 84 0._RPP ; c ( 2 , 0 , 7 ) = 1 5._RPP / 840 _ RPP case ( 9 ) ! 17th order ! 1 => left interface (i-1/2) !  cell  0                    ;     cell  1                   ;     cell  2 !c(1,0,0)=     1._RPP/9._RPP   ; c(1,1,0)=  4609._RPP/2520._RPP; c(1,2,0)= -5471._RPP/2520._RPP  ! stencil 0 !c(1,0,1)=    -7._RPP/504._RPP ; c(1,1,1)=   119._RPP/508._RPP ; c(1,2,1)=  3349._RPP/2520._RPP  ! stencil 1 !c(1,0,2)=     1._RPP/252._RPP ; c(1,1,2)=   -25._RPP/508._RPP ; c(1,2,2)=   191._RPP/504._RPP   ! stencil 2 !c(1,0,3)=    -1._RPP/504._RPP ; c(1,1,3)=    11._RPP/508._RPP ; c(1,2,3)=   -61._RPP/504._RPP   ! stencil 3 !c(1,0,4)=     1._RPP/630._RPP ; c(1,1,4)=   -41._RPP/2520._RPP; c(1,2,4)=   199._RPP/2520._RPP  ! stencil 4 !c(1,0,5)=    -1._RPP/504._RPP ; c(1,1,5)=    49._RPP/2520._RPP; c(1,2,5)=  -221._RPP/2520._RPP  ! stencil 5 !c(1,0,6)=     1._RPP/252._RPP ; c(1,1,6)=   -19._RPP/508._RPP ; c(1,2,6)=   409._RPP/2520._RPP  ! stencil 6 !c(1,0,7)=    -7._RPP/504._RPP ; c(1,1,7)=    65._RPP/508._RPP ; c(1,2,7)=  -271._RPP/504._RPP   ! stencil 7 !c(1,0,8)=     1._RPP/9._RPP   ; c(1,1,8)=  -511._RPP/508._RPP ; c(1,2,8)=  2081._RPP/504._RPP   ! stencil 8 !!  cell  3                    ;    cell  4                    ;     cell  5 !c(1,3,0)=  6289._RPP/2520._RPP; c(1,4,0)= -5471._RPP/2520._RPP; c(1,5,0)=  3349._RPP/2520._RPP  ! stencil 0 !c(1,3,1)= -2531._RPP/2520._RPP; c(1,4,1)=  1879._RPP/2520._RPP; c(1,5,1)= -1061._RPP/2520._RPP  ! stencil 1 !c(1,3,2)=  2509._RPP/2520._RPP; c(1,4,2)= -1271._RPP/2520._RPP; c(1,5,2)=   619._RPP/2520._RPP  ! stencil 2 !c(1,3,3)=   275._RPP/504._RPP ; c(1,4,3)=  1879._RPP/2520._RPP; c(1,5,3)=  -641._RPP/2520._RPP  ! stencil 3 !c(1,3,4)=  -641._RPP/2520._RPP; c(1,4,4)=  1879._RPP/2520._RPP; c(1,5,4)=   275._RPP/504._RPP   ! stencil 4 !c(1,3,5)=   619._RPP/2520._RPP; c(1,4,5)= -1271._RPP/2520._RPP; c(1,5,5)=  2509._RPP/2520._RPP  ! stencil 5 !c(1,3,6)= -1061._RPP/2520._RPP; c(1,4,6)=  1879._RPP/2520._RPP; c(1,5,6)= -2531._RPP/2520._RPP  ! stencil 6 !c(1,3,7)=  3349._RPP/2520._RPP; c(1,4,7)= -5471._RPP/2520._RPP; c(1,5,7)=  6289._RPP/2520._RPP  ! stencil 7 !c(1,3,8)= -4975._RPP/504._RPP ; c(1,4,8)= 38629._RPP/2520._RPP; c(1,5,8)=-40751._RPP/2520._RPP  ! stencil 8 !!   cell  6                   ;     cell  7                   ;     cell  8 !c(1,6,0)=  -271._RPP/504._RPP ; c(1,7,0)=    65._RPP/504._RPP ; c(1,8,0)=    -1._RPP/72._RPP    ! stencil 0 !c(1,6,1)=   409._RPP/2520._RPP; c(1,7,1)=    19._RPP/504._RPP ; c(1,8,1)=     1._RPP/252._RPP   ! stencil 1 !c(1,6,2)=  -221._RPP/2520._RPP; c(1,7,2)=    49._RPP/2520._RPP; c(1,8,2)=    -1._RPP/504._RPP   ! stencil 2 !c(1,6,3)=   199._RPP/2520._RPP; c(1,7,3)=   -41._RPP/2520._RPP; c(1,8,3)=     1._RPP/630._RPP   ! stencil 3 !c(1,6,4)=   -61._RPP/504._RPP ; c(1,7,4)=    11._RPP/504._RPP ; c(1,8,4)=    -1._RPP/504._RPP   ! stencil 4 !c(1,6,5)=   955._RPP/2520._RPP; c(1,7,5)=   -25._RPP/504._RPP ; c(1,8,5)=     1._RPP/252._RPP   ! stencil 5 !c(1,6,6)=  3349._RPP/2520._RPP; c(1,7,6)=   119._RPP/504._RPP ; c(1,8,6)=     -1._RPP/72._RPP   ! stencil 6 !c(1,6,7)= -5471._RPP/2520._RPP; c(1,7,7)=  4609._RPP/2520._RPP; c(1,8,7)=      7._RPP/63._RPP   ! stencil 7 !c(1,6,8)= 29809._RPP/2520._RPP; c(1,7,8)=-15551._RPP/2520._RPP; c(1,8,8)=   7129._RPP/2520._RPP ! stencil 8 !! 2 => right interface (i+1/2) !!  cell  0                    ;     cell  1                   ;     cell  2 !c(2,0,0)=  7129._RPP/2520._RPP; c(2,1,0)=-15551._RPP/2520._RPP; c(2,2,0)= 29809._RPP/2520._RPP  ! stencil 0 !c(2,0,1)=     7._RPP/63._RPP  ; c(2,1,1)=  4609._RPP/2520._RPP; c(2,2,1)= -5471._RPP/2520._RPP  ! stencil 1 !c(2,0,2)=    -1._RPP/72._RPP  ; c(2,1,2)=   119._RPP/504._RPP ; c(2,2,2)=  3349._RPP/2520._RPP  ! stencil 2 !c(2,0,3)=    1._RPP/252._RPP  ; c(2,1,3)=   -25._RPP/504._RPP ; c(2,2,3)=   955._RPP/2520._RPP  ! stencil 3 !c(2,0,4)=   -1._RPP/504._RPP  ; c(2,1,4)=    11._RPP/504._RPP ; c(2,2,4)=   -61._RPP/504._RPP   ! stencil 4 !c(2,0,5)=    1._RPP/630._RPP  ; c(2,1,5)=   -41._RPP/2520._RPP; c(2,2,5)=   199._RPP/2520._RPP  ! stencil 5 !c(2,0,6)=   -1._RPP/504._RPP  ; c(2,1,6)=    49._RPP/2520._RPP; c(2,2,6)=  -221._RPP/2520._RPP  ! stencil 6 !c(2,0,7)=    1._RPP/252._RPP  ; c(2,1,7)=    19._RPP/504._RPP ; c(2,2,7)=   409._RPP/2520._RPP  ! stencil 7 !c(2,0,8)=   -1._RPP/72._RPP   ; c(2,1,8)=    65._RPP/504._RPP ; c(2,2,8)=  -271._RPP/504._RPP   ! stencil 8 !!   cell  3                   ; !  cell  4                    ;     cell  5 !c(2,3,0)=-40751._RPP/2520._RPP; c(2,4,0)= 38629._RPP/2520._RPP; c(2,5,0)= -4975._RPP/504._RPP   ! stencil 0 !c(2,3,1)=  6289._RPP/2520._RPP; c(2,4,1)= -5471._RPP/2520._RPP; c(2,5,1)=  3349._RPP/2520._RPP  ! stencil 1 !c(2,3,2)= -2531._RPP/2520._RPP; c(2,4,2)=  1879._RPP/2520._RPP; c(2,5,2)= -1061._RPP/2520._RPP  ! stencil 2 !c(2,3,3)=  2509._RPP/2520._RPP; c(2,4,3)= -1271._RPP/2520._RPP; c(2,5,3)=   619._RPP/2520._RPP  ! stencil 3 !c(2,3,4)=   275._RPP/504._RPP ; c(2,4,4)=  1879._RPP/2520._RPP; c(2,5,4)=  -641._RPP/2520._RPP  ! stencil 4 !c(2,3,5)=  -641._RPP/2520._RPP; c(2,4,5)=  1879._RPP/2520._RPP; c(2,5,5)=   275._RPP/504._RPP   ! stencil 5 !c(2,3,6)=   619._RPP/2520._RPP; c(2,4,6)= -1271._RPP/2520._RPP; c(2,5,6)=  2509._RPP/2520._RPP  ! stencil 6 !c(2,3,7)= -1061._RPP/2520._RPP; c(2,4,7)=  1879._RPP/2520._RPP; c(2,5,7)= -2531._RPP/2520._RPP  ! stencil 7 !c(2,3,8)=  3349._RPP/2520._RPP; c(2,4,8)= -5471._RPP/2520._RPP; c(2,5,8)=  6289._RPP/2520._RPP  ! stencil 8 !!   cell  6                   ;     cell  7                   ;     cell  8 !c(2,6,0)=  2081._RPP/504._RPP ; c(2,7,0)=  -511._RPP/508._RPP ; c(2,8,0)=     1._RPP/9._RPP     ! stencil 0 !c(2,6,1)=  -271._RPP/504._RPP ; c(2,7,1)=    65._RPP/508._RPP ; c(2,8,1)=    -7._RPP/504._RPP   ! stencil 1 !c(2,6,2)=   409._RPP/2520._RPP; c(2,7,2)=   -19._RPP/508._RPP ; c(2,8,2)=     1._RPP/252._RPP   ! stencil 2 !c(2,6,3)=  -221._RPP/2520._RPP; c(2,7,3)=    49._RPP/2520._RPP; c(2,8,3)=    -1._RPP/504._RPP   ! stencil 3 !c(2,6,4)=   199._RPP/2520._RPP; c(2,7,4)=   -41._RPP/2520._RPP; c(2,8,4)=     1._RPP/630._RPP   ! stencil 4 !c(2,6,5)=   -61._RPP/504._RPP ; c(2,7,5)=    11._RPP/508._RPP ; c(2,8,5)=    -1._RPP/504._RPP   ! stencil 5 !c(2,6,6)=   191._RPP/504._RPP ; c(2,7,6)=   -25._RPP/508._RPP ; c(2,8,6)=     1._RPP/252._RPP   ! stencil 6 !c(2,6,7)=  3349._RPP/2520._RPP; c(2,7,7)=   119._RPP/508._RPP ; c(2,8,7)=    -7._RPP/504._RPP   ! stencil 7 !c(2,6,8)= -5471._RPP/2520._RPP; c(2,7,8)=  4609._RPP/2520._RPP; c(2,8,8)=     1._RPP/9._RPP     ! stencil 8 ! 1 => left interface (i-1/2) c ( 1 , 0 , 8 ) = 28 0._RPP / 252 0._RPP ; c ( 1 , 0 , 7 ) =- 3 5._RPP / 252 0._RPP ; c ( 1 , 0 , 6 ) = 1 0._RPP / 252 0._RPP c ( 1 , 1 , 8 ) =- 255 5._RPP / 252 0._RPP ; c ( 1 , 1 , 7 ) = 32 5._RPP / 252 0._RPP ; c ( 1 , 1 , 6 ) =- 9 5._RPP / 252 0._RPP c ( 1 , 2 , 8 ) = 1040 5._RPP / 252 0._RPP ; c ( 1 , 2 , 7 ) =- 135 5._RPP / 252 0._RPP ; c ( 1 , 2 , 6 ) = 40 9._RPP / 252 0._RPP c ( 1 , 3 , 8 ) =- 2487 5._RPP / 252 0._RPP ; c ( 1 , 3 , 7 ) = 334 9._RPP / 252 0._RPP ; c ( 1 , 3 , 6 ) =- 106 1._RPP / 252 0._RPP c ( 1 , 4 , 8 ) = 3862 9._RPP / 252 0._RPP ; c ( 1 , 4 , 7 ) =- 547 1._RPP / 252 0._RPP ; c ( 1 , 4 , 6 ) = 187 9._RPP / 252 0._RPP c ( 1 , 5 , 8 ) =- 4075 1._RPP / 252 0._RPP ; c ( 1 , 5 , 7 ) = 628 9._RPP / 252 0._RPP ; c ( 1 , 5 , 6 ) =- 253 1._RPP / 252 0._RPP c ( 1 , 6 , 8 ) = 2980 9._RPP / 252 0._RPP ; c ( 1 , 6 , 7 ) =- 547 1._RPP / 252 0._RPP ; c ( 1 , 6 , 6 ) = 334 9._RPP / 252 0._RPP c ( 1 , 7 , 8 ) =- 1555 1._RPP / 252 0._RPP ; c ( 1 , 7 , 7 ) = 460 9._RPP / 252 0._RPP ; c ( 1 , 7 , 6 ) = 59 5._RPP / 252 0._RPP c ( 1 , 8 , 8 ) = 712 9._RPP / 252 0._RPP ; c ( 1 , 8 , 7 ) = 28 0._RPP / 252 0._RPP ; c ( 1 , 8 , 6 ) =- 3 5._RPP / 252 0._RPP c ( 1 , 0 , 5 ) =- 5._RPP / 252 0._RPP ; c ( 1 , 0 , 4 ) = 4._RPP / 252 0._RPP ; c ( 1 , 0 , 3 ) =- 5._RPP / 252 0._RPP c ( 1 , 1 , 5 ) = 4 9._RPP / 252 0._RPP ; c ( 1 , 1 , 4 ) =- 4 1._RPP / 252 0._RPP ; c ( 1 , 1 , 3 ) = 5 5._RPP / 252 0._RPP c ( 1 , 2 , 5 ) =- 22 1._RPP / 252 0._RPP ; c ( 1 , 2 , 4 ) = 19 9._RPP / 252 0._RPP ; c ( 1 , 2 , 3 ) =- 30 5._RPP / 252 0._RPP c ( 1 , 3 , 5 ) = 61 9._RPP / 252 0._RPP ; c ( 1 , 3 , 4 ) =- 64 1._RPP / 252 0._RPP ; c ( 1 , 3 , 3 ) = 137 5._RPP / 252 0._RPP c ( 1 , 4 , 5 ) =- 127 1._RPP / 252 0._RPP ; c ( 1 , 4 , 4 ) = 187 9._RPP / 252 0._RPP ; c ( 1 , 4 , 3 ) = 187 9._RPP / 252 0._RPP c ( 1 , 5 , 5 ) = 250 9._RPP / 252 0._RPP ; c ( 1 , 5 , 4 ) = 137 5._RPP / 252 0._RPP ; c ( 1 , 5 , 3 ) =- 64 1._RPP / 252 0._RPP c ( 1 , 6 , 5 ) = 95 5._RPP / 252 0._RPP ; c ( 1 , 6 , 4 ) =- 30 5._RPP / 252 0._RPP ; c ( 1 , 6 , 3 ) = 19 9._RPP / 252 0._RPP c ( 1 , 7 , 5 ) =- 12 5._RPP / 252 0._RPP ; c ( 1 , 7 , 4 ) = 5 5._RPP / 252 0._RPP ; c ( 1 , 7 , 3 ) =- 4 1._RPP / 252 0._RPP c ( 1 , 8 , 5 ) = 1 0._RPP / 252 0._RPP ; c ( 1 , 8 , 4 ) =- 5._RPP / 252 0._RPP ; c ( 1 , 8 , 3 ) = 4._RPP / 252 0._RPP c ( 1 , 0 , 2 ) = 1 0._RPP / 252 0._RPP ; c ( 1 , 0 , 1 ) =- 3 5._RPP / 252 0._RPP ; c ( 1 , 0 , 0 ) = 28 0._RPP / 252 0._RPP c ( 1 , 1 , 2 ) =- 12 5._RPP / 252 0._RPP ; c ( 1 , 1 , 1 ) = 59 5._RPP / 252 0._RPP ; c ( 1 , 1 , 0 ) = 460 9._RPP / 252 0._RPP c ( 1 , 2 , 2 ) = 95 5._RPP / 252 0._RPP ; c ( 1 , 2 , 1 ) = 334 9._RPP / 252 0._RPP ; c ( 1 , 2 , 0 ) =- 547 1._RPP / 252 0._RPP c ( 1 , 3 , 2 ) = 250 9._RPP / 252 0._RPP ; c ( 1 , 3 , 1 ) =- 253 1._RPP / 252 0._RPP ; c ( 1 , 3 , 0 ) = 628 9._RPP / 252 0._RPP c ( 1 , 4 , 2 ) =- 127 1._RPP / 252 0._RPP ; c ( 1 , 4 , 1 ) = 187 9._RPP / 252 0._RPP ; c ( 1 , 4 , 0 ) =- 547 1._RPP / 252 0._RPP c ( 1 , 5 , 2 ) = 61 9._RPP / 252 0._RPP ; c ( 1 , 5 , 1 ) =- 106 1._RPP / 252 0._RPP ; c ( 1 , 5 , 0 ) = 334 9._RPP / 252 0._RPP c ( 1 , 6 , 2 ) =- 22 1._RPP / 252 0._RPP ; c ( 1 , 6 , 1 ) = 40 9._RPP / 252 0._RPP ; c ( 1 , 6 , 0 ) =- 135 5._RPP / 252 0._RPP c ( 1 , 7 , 2 ) = 4 9._RPP / 252 0._RPP ; c ( 1 , 7 , 1 ) =- 9 5._RPP / 252 0._RPP ; c ( 1 , 7 , 0 ) = 32 5._RPP / 252 0._RPP c ( 1 , 8 , 2 ) =- 5._RPP / 252 0._RPP ; c ( 1 , 8 , 1 ) = 1 0._RPP / 252 0._RPP ; c ( 1 , 8 , 0 ) =- 3 5._RPP / 252 0._RPP ! 2 => right interface (i+1/2) c ( 2 , 8 , 0 ) = 28 0._RPP / 252 0._RPP ; c ( 2 , 8 , 1 ) =- 3 5._RPP / 252 0._RPP ; c ( 2 , 8 , 2 ) = 1 0._RPP / 252 0._RPP c ( 2 , 7 , 0 ) =- 255 5._RPP / 252 0._RPP ; c ( 2 , 7 , 1 ) = 32 5._RPP / 252 0._RPP ; c ( 2 , 7 , 2 ) =- 9 5._RPP / 252 0._RPP c ( 2 , 6 , 0 ) = 1040 5._RPP / 252 0._RPP ; c ( 2 , 6 , 1 ) =- 135 5._RPP / 252 0._RPP ; c ( 2 , 6 , 2 ) = 40 9._RPP / 252 0._RPP c ( 2 , 5 , 0 ) =- 2487 5._RPP / 252 0._RPP ; c ( 2 , 5 , 1 ) = 334 9._RPP / 252 0._RPP ; c ( 2 , 5 , 2 ) =- 106 1._RPP / 252 0._RPP c ( 2 , 4 , 0 ) = 3862 9._RPP / 252 0._RPP ; c ( 2 , 4 , 1 ) =- 547 1._RPP / 252 0._RPP ; c ( 2 , 4 , 2 ) = 187 9._RPP / 252 0._RPP c ( 2 , 3 , 0 ) =- 4075 1._RPP / 252 0._RPP ; c ( 2 , 3 , 1 ) = 628 9._RPP / 252 0._RPP ; c ( 2 , 3 , 2 ) =- 253 1._RPP / 252 0._RPP c ( 2 , 2 , 0 ) = 2980 9._RPP / 252 0._RPP ; c ( 2 , 2 , 1 ) =- 547 1._RPP / 252 0._RPP ; c ( 2 , 2 , 2 ) = 334 9._RPP / 252 0._RPP c ( 2 , 1 , 0 ) =- 1555 1._RPP / 252 0._RPP ; c ( 2 , 1 , 1 ) = 460 9._RPP / 252 0._RPP ; c ( 2 , 1 , 2 ) = 59 5._RPP / 252 0._RPP c ( 2 , 0 , 0 ) = 712 9._RPP / 252 0._RPP ; c ( 2 , 0 , 1 ) = 28 0._RPP / 252 0._RPP ; c ( 2 , 0 , 2 ) =- 3 5._RPP / 252 0._RPP c ( 2 , 8 , 3 ) =- 5._RPP / 252 0._RPP ; c ( 2 , 8 , 4 ) = 4._RPP / 252 0._RPP ; c ( 2 , 8 , 5 ) =- 5._RPP / 252 0._RPP c ( 2 , 7 , 3 ) = 4 9._RPP / 252 0._RPP ; c ( 2 , 7 , 4 ) =- 4 1._RPP / 252 0._RPP ; c ( 2 , 7 , 5 ) = 5 5._RPP / 252 0._RPP c ( 2 , 6 , 3 ) =- 22 1._RPP / 252 0._RPP ; c ( 2 , 6 , 4 ) = 19 9._RPP / 252 0._RPP ; c ( 2 , 6 , 5 ) =- 30 5._RPP / 252 0._RPP c ( 2 , 5 , 3 ) = 61 9._RPP / 252 0._RPP ; c ( 2 , 5 , 4 ) =- 64 1._RPP / 252 0._RPP ; c ( 2 , 5 , 5 ) = 137 5._RPP / 252 0._RPP c ( 2 , 4 , 3 ) =- 127 1._RPP / 252 0._RPP ; c ( 2 , 4 , 4 ) = 187 9._RPP / 252 0._RPP ; c ( 2 , 4 , 5 ) = 187 9._RPP / 252 0._RPP c ( 2 , 3 , 3 ) = 250 9._RPP / 252 0._RPP ; c ( 2 , 3 , 4 ) = 137 5._RPP / 252 0._RPP ; c ( 2 , 3 , 5 ) =- 64 1._RPP / 252 0._RPP c ( 2 , 2 , 3 ) = 95 5._RPP / 252 0._RPP ; c ( 2 , 2 , 4 ) =- 30 5._RPP / 252 0._RPP ; c ( 2 , 2 , 5 ) = 19 9._RPP / 252 0._RPP c ( 2 , 1 , 3 ) =- 12 5._RPP / 252 0._RPP ; c ( 2 , 1 , 4 ) = 5 5._RPP / 252 0._RPP ; c ( 2 , 1 , 5 ) =- 4 1._RPP / 252 0._RPP c ( 2 , 0 , 3 ) = 1 0._RPP / 252 0._RPP ; c ( 2 , 0 , 4 ) =- 5._RPP / 252 0._RPP ; c ( 2 , 0 , 5 ) = 4._RPP / 252 0._RPP c ( 2 , 8 , 6 ) = 1 0._RPP / 252 0._RPP ; c ( 2 , 8 , 7 ) =- 3 5._RPP / 252 0._RPP ; c ( 2 , 8 , 8 ) = 28 0._RPP / 252 0._RPP c ( 2 , 7 , 6 ) =- 12 5._RPP / 252 0._RPP ; c ( 2 , 7 , 7 ) = 59 5._RPP / 252 0._RPP ; c ( 2 , 7 , 8 ) = 460 9._RPP / 252 0._RPP c ( 2 , 6 , 6 ) = 95 5._RPP / 252 0._RPP ; c ( 2 , 6 , 7 ) = 334 9._RPP / 252 0._RPP ; c ( 2 , 6 , 8 ) =- 547 1._RPP / 252 0._RPP c ( 2 , 5 , 6 ) = 250 9._RPP / 252 0._RPP ; c ( 2 , 5 , 7 ) =- 253 1._RPP / 252 0._RPP ; c ( 2 , 5 , 8 ) = 628 9._RPP / 252 0._RPP c ( 2 , 4 , 6 ) =- 127 1._RPP / 252 0._RPP ; c ( 2 , 4 , 7 ) = 187 9._RPP / 252 0._RPP ; c ( 2 , 4 , 8 ) =- 547 1._RPP / 252 0._RPP c ( 2 , 3 , 6 ) = 61 9._RPP / 252 0._RPP ; c ( 2 , 3 , 7 ) =- 106 1._RPP / 252 0._RPP ; c ( 2 , 3 , 8 ) = 334 9._RPP / 252 0._RPP c ( 2 , 2 , 6 ) =- 22 1._RPP / 252 0._RPP ; c ( 2 , 2 , 7 ) = 40 9._RPP / 252 0._RPP ; c ( 2 , 2 , 8 ) =- 135 5._RPP / 252 0._RPP c ( 2 , 1 , 6 ) = 4 9._RPP / 252 0._RPP ; c ( 2 , 1 , 7 ) =- 9 5._RPP / 252 0._RPP ; c ( 2 , 1 , 8 ) = 32 5._RPP / 252 0._RPP c ( 2 , 0 , 6 ) =- 5._RPP / 252 0._RPP ; c ( 2 , 0 , 7 ) = 1 0._RPP / 252 0._RPP ; c ( 2 , 0 , 8 ) =- 3 5._RPP / 252 0._RPP endselect endassociate endsubroutine create","tags":"","loc":"proc/create~7.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy interpolations. class ( interpolations_rec_js ), intent ( inout ) :: self !< Interpolations. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % coef )) deallocate ( self % coef ) endsubroutine destroy","tags":"","loc":"proc/destroy~17.html","title":"destroy – FORESEER"},{"text":"private pure function description(self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(in) :: self Alpha. Return Value character(len=:),\n  allocatable String-description. Calls proc~~description~12~~CallsGraph proc~description~12 description interface~str str proc~description~12->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self ) result ( string ) !< Return alpha string-descripition. class ( alpha_rec_m ), intent ( in ) :: self !< Alpha. character ( len = :), allocatable :: string !< String-description. character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !< New line char. string = '    Henrick alpha coefficients for reconstructor:' // nl string = string // '      - S   = ' // trim ( str ( self % S )) // nl string = string // '      - f1  = ' // trim ( str ( self % f1 )) // nl string = string // '      - f2  = ' // trim ( str ( self % f2 )) // nl string = string // '      - ff  = ' // trim ( str ( self % ff )) // nl string = string // '      - eps = ' // trim ( str ( self % eps )) // nl associate ( alpha_base => self % alpha_base ) select type ( alpha_base ) type is ( alpha_rec_js ) string = string // '      - base-mapped-alpha type = Jiang-Shu' type is ( alpha_rec_z ) string = string // '      - base-mapped-alpha type = Bogeg' endselect endassociate endfunction description","tags":"","loc":"proc/description~12.html","title":"description – FORESEER"},{"text":"private pure subroutine compute(self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. Source Code compute Source Code pure subroutine compute ( self , beta , kappa ) !< Compute alpha. class ( alpha_rec_m ), intent ( inout ) :: self !< Alpha. class ( beta_object ), intent ( in ) :: beta !< Beta. class ( kappa_object ), intent ( in ) :: kappa !< Kappa. real ( RPP ) :: kappa_base !< Kappa evaluated from the base alphas. integer ( I_P ) :: f , s1 !< Counters. self % values_sum = 0._RPP call self % alpha_base % compute ( beta = beta , kappa = kappa ) do s1 = 0 , self % S - 1 ! stencil loops do f = self % f1 , self % f2 ! 1 => left interface (i-1/2), 2 => right interface (i+1/2) kappa_base = self % alpha_base % values ( f , s1 ) / self % alpha_base % values_sum ( f ) self % values ( f , s1 ) = & ( kappa_base * ( kappa % values ( f , s1 ) + kappa % values ( f , s1 ) * kappa % values ( f , s1 ) - & 3._RPP * kappa % values ( f , s1 ) * kappa_base + kappa_base * & kappa_base )) / & ( kappa % values ( f , s1 ) * kappa % values ( f , s1 ) + kappa_base * & ( 1._RPP - 2._RPP * kappa % values ( f , s1 ))) self % values_sum ( f ) = self % values_sum ( f ) + self % values ( f , s1 ) enddo enddo endsubroutine compute","tags":"","loc":"proc/compute~7.html","title":"compute – FORESEER"},{"text":"private subroutine create(self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. Source Code create Source Code subroutine create ( self , constructor ) !< Create alpha. class ( alpha_rec_m ), intent ( inout ) :: self !< Alpha. class ( base_object_constructor ), intent ( in ) :: constructor !< Alpha constructor. call self % destroy call self % create_ ( constructor = constructor ) allocate ( self % values ( 1 : 2 , 0 : self % S - 1 )) allocate ( self % values_sum ( 1 : 2 )) self % values = 0._RPP self % values_sum = 0._RPP select type ( constructor ) type is ( alpha_rec_m_constructor ) if ( allocated ( constructor % base_type )) then select case ( constructor % base_type ) case ( 'JS' ) if ( allocated ( self % alpha_base )) deallocate ( self % alpha_base ) allocate ( alpha_rec_js :: self % alpha_base ) call self % alpha_base % create ( constructor = constructor ) case ( 'Z' ) if ( allocated ( self % alpha_base )) deallocate ( self % alpha_base ) allocate ( alpha_rec_z :: self % alpha_base ) call self % alpha_base % create ( constructor = constructor ) endselect endif class default ! @TODO add error handling endselect endsubroutine create","tags":"","loc":"proc/create~8.html","title":"create – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy alpha. class ( alpha_rec_m ), intent ( inout ) :: self !< Alpha. call self % destroy_ if ( allocated ( self % values )) deallocate ( self % values ) if ( allocated ( self % values_sum )) deallocate ( self % values_sum ) if ( allocated ( self % alpha_base )) deallocate ( self % alpha_base ) endsubroutine destroy","tags":"","loc":"proc/destroy~18.html","title":"destroy – FORESEER"},{"text":"private subroutine create(constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. Source Code create Source Code subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[kappa_object]] given its constructor. class ( kappa_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( kappa_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( kappa_rec_js_constructor ) allocate ( kappa_rec_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create","tags":"","loc":"proc/create~9.html","title":"create – FORESEER"},{"text":"private subroutine create_constructor(interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor. Source Code create_constructor Source Code subroutine create_constructor ( interpolator_type , S , constructor ) !< Create an instance of concrete extension of [[kappa_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( kappa_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( kappa_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( kappa_rec_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( kappa_rec_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( kappa_rec_js_constructor :: constructor ) endselect call constructor % create ( S = S ) endsubroutine create_constructor","tags":"","loc":"proc/create_constructor.html","title":"create_constructor – FORESEER"},{"text":"private subroutine create(constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. Source Code create Source Code subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[weights_object]] given its constructor. class ( weights_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( weights_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( weights_js_constructor ) allocate ( weights_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create","tags":"","loc":"proc/create~10.html","title":"create – FORESEER"},{"text":"private subroutine create_constructor(interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. Source Code create_constructor Source Code subroutine create_constructor ( interpolator_type , S , alpha_constructor , beta_constructor , kappa_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[weights_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), intent ( in ) :: alpha_constructor !< Alpha constructor. class ( beta_object_constructor ), intent ( in ) :: beta_constructor !< Beta constructor. class ( kappa_object_constructor ), intent ( in ) :: kappa_constructor !< kappa constructor. class ( weights_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( weights_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( weights_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( weights_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( weights_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) select type ( constructor ) type is ( weights_js_constructor ) allocate ( constructor % alpha_constructor , source = alpha_constructor ) allocate ( constructor % beta_constructor , source = beta_constructor ) allocate ( constructor % kappa_constructor , source = kappa_constructor ) endselect endsubroutine create_constructor","tags":"","loc":"proc/create_constructor~2.html","title":"create_constructor – FORESEER"},{"text":"private subroutine create(constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. Source Code create Source Code subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[interpolator_object]] given its constructor. class ( interpolator_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolator_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) ! type is(interpolator_js_constructor) ! allocate(interpolator_js :: object) type is ( reconstructor_js_constructor ) allocate ( reconstructor_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create","tags":"","loc":"proc/create~11.html","title":"create – FORESEER"},{"text":"private subroutine create_constructor(interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp. Source Code create_constructor Source Code subroutine create_constructor ( interpolator_type , S , interpolations_constructor , weights_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[weights_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), intent ( in ) :: interpolations_constructor !< Interpolations const. class ( weights_object_constructor ), intent ( in ) :: weights_constructor !< Weights constructor. class ( interpolator_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left interp. logical , intent ( in ), optional :: face_right !< Activate right interp. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( reconstructor_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( reconstructor_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( reconstructor_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( reconstructor_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) select type ( constructor ) type is ( reconstructor_js_constructor ) allocate ( constructor % interpolations_constructor , source = interpolations_constructor ) allocate ( constructor % weights_constructor , source = weights_constructor ) endselect endsubroutine create_constructor","tags":"","loc":"proc/create_constructor~3.html","title":"create_constructor – FORESEER"},{"text":"private subroutine create(constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. Source Code create Source Code subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[interpolations_object]] given its constructor. class ( interpolations_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolations_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( interpolations_rec_js_constructor ) allocate ( interpolations_rec_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create","tags":"","loc":"proc/create~12.html","title":"create – FORESEER"},{"text":"private subroutine create_constructor(interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. Source Code create_constructor Source Code subroutine create_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[beta_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interp. logical , intent ( in ), optional :: face_right !< Activate right-face interp. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( interpolations_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( interpolations_rec_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( interpolations_rec_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( interpolations_rec_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) endsubroutine create_constructor","tags":"","loc":"proc/create_constructor~4.html","title":"create_constructor – FORESEER"},{"text":"private subroutine create_alpha_object(constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. Source Code create_alpha_object Source Code subroutine create_alpha_object ( constructor , object ) !< Create an instance of concrete extension of [[alpha_object]] given its constructor. class ( alpha_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( alpha_object ), allocatable , intent ( out ) :: object !< Object. type ( alpha_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_alpha_object","tags":"","loc":"proc/create_alpha_object.html","title":"create_alpha_object – FORESEER"},{"text":"private subroutine create_alpha_object_constructor(interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division. Source Code create_alpha_object_constructor Source Code subroutine create_alpha_object_constructor ( interpolator_type , S , constructor , face_left , face_right , eps ) !< Create an instance of concrete extension of [[alpha_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero/division. type ( alpha_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = constructor , & face_left = face_left , & face_right = face_right , & eps = eps ) endsubroutine create_alpha_object_constructor","tags":"","loc":"proc/create_alpha_object_constructor.html","title":"create_alpha_object_constructor – FORESEER"},{"text":"private subroutine create_beta_object(constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. Source Code create_beta_object Source Code subroutine create_beta_object ( constructor , object ) !< Create an instance of concrete extension of [[beta_object]] given its constructor. class ( beta_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( beta_object ), allocatable , intent ( out ) :: object !< Object. type ( beta_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_beta_object","tags":"","loc":"proc/create_beta_object.html","title":"create_beta_object – FORESEER"},{"text":"private subroutine create_beta_object_constructor(interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. Source Code create_beta_object_constructor Source Code subroutine create_beta_object_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[beta_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( beta_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. type ( beta_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_beta_object_constructor","tags":"","loc":"proc/create_beta_object_constructor.html","title":"create_beta_object_constructor – FORESEER"},{"text":"private subroutine create_interpolations_object(constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. Source Code create_interpolations_object Source Code subroutine create_interpolations_object ( constructor , object ) !< Create an instance of concrete extension of [[interpolations_object]] given its constructor. class ( interpolations_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolations_object ), allocatable , intent ( out ) :: object !< Object. type ( interpolations_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_interpolations_object","tags":"","loc":"proc/create_interpolations_object.html","title":"create_interpolations_object – FORESEER"},{"text":"private subroutine create_interpolations_object_constructor(interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of interpolations_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. Source Code create_interpolations_object_constructor Source Code subroutine create_interpolations_object_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[interpolations_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interp. logical , intent ( in ), optional :: face_right !< Activate right-face interp. type ( interpolations_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_interpolations_object_constructor","tags":"","loc":"proc/create_interpolations_object_constructor.html","title":"create_interpolations_object_constructor – FORESEER"},{"text":"private subroutine create_interpolator(self, interpolator_type, S, interpolator, face_left, face_right, eps) Create an instance of concrete extension of interpolator_object given user options. Arguments Type Intent Optional Attributes Name class( objects_factory ), intent(in) :: self The factory. character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolator_object ), intent(out), allocatable :: interpolator Interpolator. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/div. Source Code create_interpolator Source Code subroutine create_interpolator ( self , interpolator_type , S , interpolator , face_left , face_right , eps ) !< Create an instance of concrete extension of [[interpolator_object]] given user options. class ( objects_factory ), intent ( in ) :: self !< The factory. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolator_object ), allocatable , intent ( out ) :: interpolator !< Interpolator. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero/div. class ( alpha_object_constructor ), allocatable :: alpha_constructor !< Alpha constructor. class ( beta_object_constructor ), allocatable :: beta_constructor !< Beta constructor. class ( interpolations_object_constructor ), allocatable :: interpolations_constructor !< Interpolations constructor. class ( kappa_object_constructor ), allocatable :: kappa_constructor !< Kappa constructor. class ( weights_object_constructor ), allocatable :: weights_constructor !< Weights constructor. class ( interpolator_object_constructor ), allocatable :: interpolator_constructor !< Interpolator constructor. call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = alpha_constructor , & face_left = face_left , & face_right = face_right , & eps = eps ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = beta_constructor , & face_left = face_left , & face_right = face_right ) call self % create_constructor ( interpolator_type = interpolator_type , S = S , constructor = kappa_constructor ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & alpha_constructor = alpha_constructor , & beta_constructor = beta_constructor , & kappa_constructor = kappa_constructor , & constructor = weights_constructor , & face_left = face_left , & face_right = face_right ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & constructor = interpolations_constructor , & face_left = face_left , & face_right = face_right ) call self % create_constructor ( interpolator_type = interpolator_type , & S = S , & interpolations_constructor = interpolations_constructor , & weights_constructor = weights_constructor , & constructor = interpolator_constructor , & face_left = face_left , & face_right = face_right ) call self % create_interpolator_object ( constructor = interpolator_constructor , object = interpolator ) endsubroutine create_interpolator","tags":"","loc":"proc/create_interpolator.html","title":"create_interpolator – FORESEER"},{"text":"private subroutine create_interpolator_object(constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. Source Code create_interpolator_object Source Code subroutine create_interpolator_object ( constructor , object ) !< Create an instance of concrete extension of [[interpolator_object]] given its constructor. class ( interpolator_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( interpolator_object ), allocatable , intent ( out ) :: object !< Object. type ( interpolator_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_interpolator_object","tags":"","loc":"proc/create_interpolator_object.html","title":"create_interpolator_object – FORESEER"},{"text":"private subroutine create_interpolator_object_constructor(interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of interpolator_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp. Source Code create_interpolator_object_constructor Source Code subroutine create_interpolator_object_constructor ( interpolator_type , S , interpolations_constructor , weights_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[interpolator_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( interpolations_object_constructor ), intent ( in ) :: interpolations_constructor !< Interpolations const. class ( weights_object_constructor ), intent ( in ) :: weights_constructor !< Weights constructor. class ( interpolator_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left interp. logical , intent ( in ), optional :: face_right !< Activate right interp. type ( interpolator_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & interpolations_constructor = interpolations_constructor , & weights_constructor = weights_constructor , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_interpolator_object_constructor","tags":"","loc":"proc/create_interpolator_object_constructor.html","title":"create_interpolator_object_constructor – FORESEER"},{"text":"private subroutine create_kappa_object(constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. Source Code create_kappa_object Source Code subroutine create_kappa_object ( constructor , object ) !< Create an instance of concrete extension of [[kappa_object]] given its constructor. class ( kappa_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( kappa_object ), allocatable , intent ( out ) :: object !< Object. type ( kappa_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_kappa_object","tags":"","loc":"proc/create_kappa_object.html","title":"create_kappa_object – FORESEER"},{"text":"private subroutine create_kappa_object_constructor(interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor. Source Code create_kappa_object_constructor Source Code subroutine create_kappa_object_constructor ( interpolator_type , S , constructor ) !< Create an instance of concrete extension of [[kappa_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( kappa_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. type ( kappa_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , S = S , constructor = constructor ) endsubroutine create_kappa_object_constructor","tags":"","loc":"proc/create_kappa_object_constructor.html","title":"create_kappa_object_constructor – FORESEER"},{"text":"private subroutine create_weights_object(constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. Source Code create_weights_object Source Code subroutine create_weights_object ( constructor , object ) !< Create an instance of concrete extension of [[weights_object]] given its constructor. class ( weights_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( weights_object ), allocatable , intent ( out ) :: object !< Object. type ( weights_factory ) :: factory !< The factory. call factory % create ( constructor = constructor , object = object ) endsubroutine create_weights_object","tags":"","loc":"proc/create_weights_object.html","title":"create_weights_object – FORESEER"},{"text":"private subroutine create_weights_object_constructor(interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. Source Code create_weights_object_constructor Source Code subroutine create_weights_object_constructor ( interpolator_type , S , alpha_constructor , beta_constructor , kappa_constructor , & constructor , face_left , face_right ) !< Create an instance of concrete extension of [[weights_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), intent ( in ) :: alpha_constructor !< Alpha constructor. class ( beta_object_constructor ), intent ( in ) :: beta_constructor !< Beta constructor. class ( kappa_object_constructor ), intent ( in ) :: kappa_constructor !< kappa constructor. class ( weights_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interp. logical , intent ( in ), optional :: face_right !< Activate right-face interp. type ( weights_factory ) :: factory !< The factory. call factory % create_constructor ( interpolator_type = interpolator_type , & S = S , & alpha_constructor = alpha_constructor , & beta_constructor = beta_constructor , & kappa_constructor = kappa_constructor , & constructor = constructor , & face_left = face_left , & face_right = face_right ) endsubroutine create_weights_object_constructor","tags":"","loc":"proc/create_weights_object_constructor.html","title":"create_weights_object_constructor – FORESEER"},{"text":"private subroutine create(constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. Source Code create Source Code subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[alpha_object]] given its constructor. class ( alpha_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( alpha_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( alpha_rec_js_constructor ) allocate ( alpha_rec_js :: object ) type is ( alpha_rec_m_constructor ) allocate ( alpha_rec_m :: object ) type is ( alpha_rec_z_constructor ) allocate ( alpha_rec_z :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create","tags":"","loc":"proc/create~13.html","title":"create – FORESEER"},{"text":"private subroutine create_constructor(interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division. Source Code create_constructor Source Code subroutine create_constructor ( interpolator_type , S , constructor , face_left , face_right , eps ) !< Create an instance of concrete extension of [[alpha_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( alpha_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. real ( RPP ), intent ( in ), optional :: eps !< Small epsilon to avoid zero/division. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( alpha_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( alpha_rec_m_constructor :: constructor ) select type ( constructor ) type is ( alpha_rec_m_constructor ) constructor % base_type = 'JS' endselect case ( 'reconstructor-M-Z' ) allocate ( alpha_rec_m_constructor :: constructor ) select type ( constructor ) type is ( alpha_rec_m_constructor ) constructor % base_type = 'Z' endselect case ( 'reconstructor-Z' ) allocate ( alpha_rec_z_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right , eps = eps ) endsubroutine create_constructor","tags":"","loc":"proc/create_constructor~5.html","title":"create_constructor – FORESEER"},{"text":"private subroutine create(constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. Source Code create Source Code subroutine create ( constructor , object ) !< Create an instance of concrete extension of [[beta_object]] given its constructor. class ( beta_object_constructor ), intent ( in ) :: constructor !< Constructor. class ( beta_object ), allocatable , intent ( out ) :: object !< Object. select type ( constructor ) type is ( beta_rec_js_constructor ) allocate ( beta_rec_js :: object ) class default error stop 'error: WenOOF object factory do NOT know the constructor given' endselect call object % create ( constructor = constructor ) endsubroutine create","tags":"","loc":"proc/create~14.html","title":"create – FORESEER"},{"text":"private subroutine create_constructor(interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. Source Code create_constructor Source Code subroutine create_constructor ( interpolator_type , S , constructor , face_left , face_right ) !< Create an instance of concrete extension of [[beta_object_constructor]]. character ( * ), intent ( in ) :: interpolator_type !< Type of the interpolator. integer ( I_P ), intent ( in ) :: S !< Stencils dimension. class ( beta_object_constructor ), allocatable , intent ( out ) :: constructor !< Constructor. logical , intent ( in ), optional :: face_left !< Activate left-face interpolations. logical , intent ( in ), optional :: face_right !< Activate right-face interpolations. select case ( trim ( adjustl ( interpolator_type ))) case ( 'interpolator-JS' ) ! @TODO implement this error stop 'interpolator-JS to be implemented' case ( 'reconstructor-JS' ) allocate ( beta_rec_js_constructor :: constructor ) case ( 'reconstructor-M-JS' ) allocate ( beta_rec_js_constructor :: constructor ) case ( 'reconstructor-M-Z' ) allocate ( beta_rec_js_constructor :: constructor ) case ( 'reconstructor-Z' ) allocate ( beta_rec_js_constructor :: constructor ) endselect call constructor % create ( S = S , face_left = face_left , face_right = face_right ) endsubroutine create_constructor","tags":"","loc":"proc/create_constructor~6.html","title":"create_constructor – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_llf~~UsesGraph module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~penf penf module~penf->module~foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_eos_object module~penf->module~foreseer_conservative_object module~penf->module~foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_compressible_object module~penf->module~foreseer_conservative_compressible module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~penf_stringify var panmoduleforeseer_riemann_solver_compressible_llfUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_llfUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_llf~~UsedByGraph module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_llfUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_llfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_llf Subroutines compute_waves initialize solve Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. real(kind=R8P), public :: d_1 = 0._R8P (gamma-1)/2 of state 1. real(kind=R8P), public :: d_4 = 0._R8P (gamma-1)/2 of state 4. real(kind=R8P), public :: e_1 = 0._R8P 2*g/(g-1) of state 1. real(kind=R8P), public :: e_4 = 0._R8P 2*g/(g-1) of state 4. real(kind=R8P), public :: g_1 = 0._R8P Specific heats ratio gamma=cp/cv of state 1. real(kind=R8P), public :: g_4 = 0._R8P Specific heats ratio gamma=cp/cv of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. Subroutines private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_llf.html","title":"foreseer_riemann_solver_compressible_llf – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_pvl~~UsesGraph module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~penf penf module~penf->module~foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_eos_object module~penf->module~foreseer_conservative_object module~penf->module~foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_compressible_object module~penf->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~penf_stringify var panmoduleforeseer_riemann_solver_compressible_pvlUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_pvlUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Primitive Variables Linearization based Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_pvl~~UsedByGraph module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_pvlUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_pvlUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_waves_interface solve_interface Derived Types riemann_solver_compressible_pvl Subroutines compute_p23 compute_u23 compute_up23 compute_waves compute_waves_u23 compute_waves_up23 initialize solve solve_u23 solve_up23 Abstract Interfaces abstract interface private pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. abstract interface private pure subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl Primitive Variables Linearization based Riemann solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. procedure( compute_waves_interface ), public, pointer :: compute_waves_ => compute_waves_up23 Compute waves pattern real(kind=R8P), public :: d_1 = 0._R8P (gamma-1)/2 of state 1. real(kind=R8P), public :: d_4 = 0._R8P (gamma-1)/2 of state 4. real(kind=R8P), public :: e_1 = 0._R8P 2*g/(g-1) of state 1. real(kind=R8P), public :: e_4 = 0._R8P 2*g/(g-1) of state 4. real(kind=R8P), public :: g_1 = 0._R8P Specific heats ratio gamma=cp/cv of state 1. real(kind=R8P), public :: g_4 = 0._R8P Specific heats ratio gamma=cp/cv of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. procedure( solve_interface ), public, pointer :: solve_ => solve_up23 Solve Riemann problem. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, private, pass(self) :: compute_p23 Compute interstates pressure. procedure, private, pass(self) :: compute_u23 Compute interstates velocity. procedure, private, pass(self) :: compute_up23 Compute interstates velocity and pressure. procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, private, pass(self) :: compute_waves_u23 Compute waves speed by u23 algorithm. procedure, private, pass(self) :: compute_waves_up23 Compute waves speed by up23 algorithm. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. procedure, private, pass(self) :: solve_u23 Compute whole pattern by u23 algorithm. procedure, private, pass(self) :: solve_up23 Compute whole pattern by up23 algorithm. Subroutines private elemental subroutine compute_p23 (self) Compute interstates pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. private elemental subroutine compute_u23 (self) Compute interstates velocity. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. private elemental subroutine compute_up23 (self) Compute interstates velocity and pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private pure subroutine compute_waves_u23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private pure subroutine compute_waves_up23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private pure subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private pure subroutine solve_u23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem by u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private pure subroutine solve_up23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem up23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Riemann pattern. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_pvl.html","title":"foreseer_riemann_solver_compressible_pvl – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_primitive_compressible foreseer_eos_object penf vecfor module~~foreseer_compressible_transformations~~UsesGraph module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf penf module~penf->module~foreseer_compressible_transformations module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer_compressible_transformations vecfor vecfor vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_conservative_object vecfor->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~penf_stringify module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_primitive_object->module~foreseer_primitive_compressible var panmoduleforeseer_compressible_transformationsUsesGraph = svgPanZoom('#moduleforeseer_compressible_transformationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define compressible variables transformations of FORESEER library. Used By module~~foreseer_compressible_transformations~~UsedByGraph module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer foreseer module~foreseer_compressible_transformations->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_compressible_transformationsUsedByGraph = svgPanZoom('#moduleforeseer_compressible_transformationsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions conservative_to_primitive_compressible primitive_to_conservative_compressible Functions public elemental function conservative_to_primitive_compressible (conservative, eos) result(primitive_) Return a primitive_compressible state transforming a given conservative_compressible state. Arguments Type Intent Optional Attributes Name type( conservative_compressible ), intent(in) :: conservative Conservative state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( primitive_compressible ) Primitive state. public elemental function primitive_to_conservative_compressible (primitive, eos) result(conservative_) Return a conservative_compressible state transforming a given primitive_compressible state. Arguments Type Intent Optional Attributes Name type( primitive_compressible ), intent(in) :: primitive Primitive state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( conservative_compressible ) Conservative state.","tags":"","loc":"module/foreseer_compressible_transformations.html","title":"foreseer_compressible_transformations – FORESEER"},{"text":"Uses: foreseer_conservative_object foreseer_eos_object penf vecfor module~~foreseer_riemann_solver_object~~UsesGraph module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf penf module~penf->module~foreseer_riemann_solver_object module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object vecfor vecfor vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_conservative_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmoduleforeseer_riemann_solver_objectUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_object~~UsedByGraph module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer foreseer module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_objectUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_waves_interface description_interface initialize_interface solve_interface Derived Types riemann_solver_object Abstract Interfaces abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine initialize_interface (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Derived Types type, public, abstract :: riemann_solver_object Abstract Riemann Solver. Type-Bound Procedures procedure(compute_waves_interface), public, pass(self) :: compute_waves Compute waves pattern. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(initialize_interface), public, pass(self) :: initialize Initialize solver. procedure(solve_interface), public, pass(self) :: solve Solve Riemann Problem.","tags":"","loc":"module/foreseer_riemann_solver_object.html","title":"foreseer_riemann_solver_object – FORESEER"},{"text":"Uses: foreseer_eos_object penf module~~foreseer_eos_compressible~~UsesGraph module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_eos_compressible module~penf penf module~penf->module~foreseer_eos_compressible module~penf->module~foreseer_eos_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmoduleforeseer_eos_compressibleUsesGraph = svgPanZoom('#moduleforeseer_eos_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. Used By module~~foreseer_eos_compressible~~UsedByGraph module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer foreseer module~foreseer_eos_compressible->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_eos_compressibleUsedByGraph = svgPanZoom('#moduleforeseer_eos_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces eos_compressible Derived Types eos_compressible Functions R cp cv density energy eos_compressible_instance gam pressure speed_of_sound temperature Interfaces public interface eos_compressible Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Derived Types type, public, extends( eos_object ) :: eos_compressible Equation of state (EOS) of ideal compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), private :: cp_ = 0._R8P Specific heat at constant pressure cp . real(kind=R8P), private :: cv_ = 0._R8P Specific heat at constant volume cv . Constructor Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) Return and instance of eos_compressible . Type-Bound Procedures procedure, public, pass(self) :: R Return fluid constant R=cp-cv . procedure, public, pass(self) :: cp Return specific heat at constant pressure. procedure, public, pass(self) :: cv Return specific heat at constant volume. procedure, public, pass(self) :: density Return density. procedure, public, pass(self) :: energy Return specific internal energy. procedure, public, pass(self) :: gam Return specific heats ratio gamma=cp/cv . procedure, public, pass(self) :: pressure Return pressure. procedure, public, pass(self) :: speed_of_sound Return speed of sound. procedure, public, pass(self) :: temperature Return temperature. Functions private elemental function R (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. private elemental function cp (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. private elemental function cv (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. private elemental function density (self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. private elemental function energy (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . private elemental function gam (self) result(gam_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. private elemental function pressure (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. private elemental function speed_of_sound (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. private elemental function temperature (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value.","tags":"","loc":"module/foreseer_eos_compressible.html","title":"foreseer_eos_compressible – FORESEER"},{"text":"Uses: penf module~~foreseer_eos_object~~UsesGraph module~foreseer_eos_object foreseer_eos_object module~penf penf module~penf->module~foreseer_eos_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmoduleforeseer_eos_objectUsesGraph = svgPanZoom('#moduleforeseer_eos_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract equation of state (EOS) for FORESEER library. Used By module~~foreseer_eos_object~~UsedByGraph module~foreseer_eos_object foreseer_eos_object module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer foreseer module~foreseer_eos_object->module~foreseer module~foreseer_primitive_object foreseer_primitive_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer module~foreseer_compressible_transformations->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_eos_objectUsedByGraph = svgPanZoom('#moduleforeseer_eos_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces R_interface cp_interface cv_interface density_interface energy_interface gam_interface pressure_interface speed_of_sound_interface temperature_interface Derived Types eos_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function R_interface (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function cp_interface (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function cv_interface (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function density_interface (self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function energy_interface (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function gam_interface (self) result(gam_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function pressure_interface (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function speed_of_sound_interface (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function temperature_interface (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Derived Types type, public, abstract :: eos_object Equation of State (EOS) object class. Type-Bound Procedures procedure(R_interface), public, pass(self) :: R Return fluid constant R=cp-cv . procedure(cp_interface), public, pass(self) :: cp Return specific heat at constant pressure. procedure(cv_interface), public, pass(self) :: cv Return specific heat at constant volume. procedure(density_interface), public, pass(self) :: density Return density. procedure(energy_interface), public, pass(self) :: energy Return specific internal energy. procedure(gam_interface), public, pass(self) :: gam Return specific heats ratio gamma=cp/cv . procedure(pressure_interface), public, pass(self) :: pressure Return pressure. procedure(speed_of_sound_interface), public, pass(self) :: speed_of_sound Return speed of sound. procedure(temperature_interface), public, pass(self) :: temperature Return temperature.","tags":"","loc":"module/foreseer_eos_object.html","title":"foreseer_eos_object – FORESEER"},{"text":"Uses: iso_fortran_env foreseer_primitive_object foreseer_eos_object penf vecfor module~~foreseer_primitive_compressible~~UsesGraph module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf penf module~penf->module~foreseer_primitive_compressible module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_primitive_object->module~foreseer_primitive_compressible vecfor vecfor vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_primitive_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmoduleforeseer_primitive_compressibleUsesGraph = svgPanZoom('#moduleforeseer_primitive_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. Used By module~~foreseer_primitive_compressible~~UsedByGraph module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_compressible_transformations->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_primitive_compressibleUsedByGraph = svgPanZoom('#moduleforeseer_primitive_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces primitive_compressible Derived Types primitive_compressible Functions add array description energy left_eigenvectors momentum negative positive prim_divide_real prim_multiply_prim prim_multiply_real primitive_compressible_instance primitive_compressible_pointer real_multiply_prim right_eigenvectors sub Subroutines destroy initialize prim_assign_prim Interfaces public interface primitive_compressible Overload primitive_compressible name with its constructor. private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . Derived Types type, public, extends( primitive_object ) :: primitive_compressible Convervative compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor Overload primitive_compressible name with its constructor. private elemental function primitive_compressible_instance (density, velocity, pressure) Return and instance of primitive_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy primitive. procedure, public, pass(self) :: energy Return energy value. procedure, public, pass(self) :: initialize Initialize primitive. procedure, public, pass(self) :: left_eigenvectors Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . procedure, public, pass(self) :: momentum Return momentum vector. procedure, public, pass(self) :: negative Unary operator - prim . generic, public :: operator(*) => prim_multiply_prim, prim_multiply_real, real_multiply_prim Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => prim_divide_real Overload / . procedure, public, pass(self) :: positive Unary operator + prim . procedure, public, pass(lhs) :: prim_assign_prim Operator = . procedure, public, pass(lhs) :: prim_divide_real Operator prim / real . procedure, public, pass(lhs) :: prim_multiply_prim Operator * . procedure, public, pass(lhs) :: prim_multiply_real Operator prim * real . procedure, public, pass(rhs) :: real_multiply_prim Operator real * prim . procedure, public, pass(self) :: right_eigenvectors Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . procedure, public, pass(lhs) :: sub Operator - . Functions private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. private pure function left_eigenvectors (self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . public function primitive_compressible_pointer (to, error_message) result(pointer_) Return primitive_compressible pointer associated to primitive_object or its extensions until primitive_compressible included. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( primitive_compressible ),\n  pointer Associated pointer. private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private pure function right_eigenvectors (self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Subroutines private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/foreseer_primitive_compressible.html","title":"foreseer_primitive_compressible – FORESEER"},{"text":"Uses: iso_fortran_env foreseer_conservative_object foreseer_eos_object penf vecfor module~~foreseer_conservative_compressible~~UsesGraph module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf penf module~penf->module~foreseer_conservative_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_conservative_object->module~foreseer_conservative_compressible vecfor vecfor vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_conservative_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmoduleforeseer_conservative_compressibleUsesGraph = svgPanZoom('#moduleforeseer_conservative_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. Used By module~~foreseer_conservative_compressible~~UsedByGraph module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_conservative_compressible->module~foreseer module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_conservative_compressibleUsedByGraph = svgPanZoom('#moduleforeseer_conservative_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces conservative_compressible Derived Types conservative_compressible Functions add array cons_divide_real cons_multiply_cons cons_multiply_real conservative_compressible_instance conservative_compressible_pointer description negative positive pressure real_multiply_cons sub velocity Subroutines compute_fluxes compute_fluxes_from_primitive cons_assign_cons destroy initialize Interfaces public interface conservative_compressible Overload conservative_compressible name with its constructor. private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . Derived Types type, public, extends( conservative_object ) :: conservative_compressible Convervative compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: energy = 0._R8P Energy, rho * E , rho being the density and E the specific energy. type(vector), public :: momentum Momentum, rho * v , rho being the density and v the velocity vector. Constructor Overload conservative_compressible name with its constructor. private elemental function conservative_compressible_instance (density, momentum, energy) Return and instance of conservative_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . procedure, public, pass(self) :: compute_fluxes Compute conservative fluxes. procedure, public, pass(self) :: compute_fluxes_from_primitive Compute conservative fluxes from primitives at interface. procedure, public, pass(lhs) :: cons_assign_cons Operator = . procedure, public, pass(lhs) :: cons_divide_real Operator cons / real . procedure, public, pass(lhs) :: cons_multiply_cons Operator * . procedure, public, pass(lhs) :: cons_multiply_real Operator cons * real . procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy conservative. procedure, public, pass(self) :: initialize Initialize conservative. procedure, public, pass(self) :: negative Unary operator - cons . generic, public :: operator(*) => cons_multiply_cons, cons_multiply_real, real_multiply_cons Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => cons_divide_real Overload / . procedure, public, pass(self) :: positive Unary operator + cons . procedure, public, pass(self) :: pressure Return pressure value. procedure, public, pass(rhs) :: real_multiply_cons Operator real * cons . procedure, public, pass(lhs) :: sub Operator - . procedure, public, pass(self) :: velocity Return velocity vector. Functions private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . public function conservative_compressible_pointer (to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( conservative_compressible ),\n  pointer Associated pointer. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. private elemental function pressure (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private elemental function velocity (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Subroutines private subroutine compute_fluxes (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. private elemental subroutine compute_fluxes_from_primitive (self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. private subroutine initialize (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state.","tags":"","loc":"module/foreseer_conservative_compressible.html","title":"foreseer_conservative_compressible – FORESEER"},{"text":"Uses: foreseer_eos_object penf vecfor module~~foreseer_conservative_object~~UsesGraph module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_conservative_object vecfor vecfor vecfor->module~foreseer_conservative_object module~penf penf module~penf->module~foreseer_conservative_object module~penf->module~foreseer_eos_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmoduleforeseer_conservative_objectUsesGraph = svgPanZoom('#moduleforeseer_conservative_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract conservative state of a Riemann Problem for FORESEER library. Used By module~~foreseer_conservative_object~~UsedByGraph module~foreseer_conservative_object foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_compressible_transformations->module~foreseer var panmoduleforeseer_conservative_objectUsedByGraph = svgPanZoom('#moduleforeseer_conservative_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces array_interface assignment_interface compute_fluxes_interface cons_operator_real description_interface destroy_interface initialize_interface pressure_interface real_operator_cons symmetric_operator unary_operator velocity_interface Derived Types conservative_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function array_interface (self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. abstract interface Abstract interfaces of deferred methods of conservative_object . private pure subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine compute_fluxes_interface (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. abstract interface Abstract interfaces of deferred methods of conservative_object . private function cons_operator_real (lhs, rhs) result(operator_result) Operator cons.op.real . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental subroutine destroy_interface (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine initialize_interface (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function pressure_interface (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. abstract interface Abstract interfaces of deferred methods of conservative_object . private function real_operator_cons (lhs, rhs) result(operator_result) Operator real.op.cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private function symmetric_operator (lhs, rhs) result(operator_result) Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private function unary_operator (self) result(operator_result) Unary operator .op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function velocity_interface (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Derived Types type, public, abstract :: conservative_object Convervative object class. Type-Bound Procedures procedure(symmetric_operator), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . procedure(compute_fluxes_interface), public, pass(self) :: compute_fluxes Compute conservative fluxes. procedure(assignment_interface), public, pass(lhs) :: cons_assign_cons Operator = . procedure(cons_operator_real), public, pass(lhs) :: cons_divide_real Operator cons / real . procedure(symmetric_operator), public, pass(lhs) :: cons_multiply_cons Operator * . procedure(cons_operator_real), public, pass(lhs) :: cons_multiply_real Operator cons * real . procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(destroy_interface), public, pass(self) :: destroy Destroy conservative. procedure(initialize_interface), public, pass(self) :: initialize Initialize conservative. procedure(unary_operator), public, pass(self) :: negative Unary operator - cons . generic, public :: operator(*) => cons_multiply_cons, cons_multiply_real, real_multiply_cons Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => cons_divide_real Overload / . procedure(unary_operator), public, pass(self) :: positive Unary operator + cons . procedure(pressure_interface), public, pass(self) :: pressure Return pressure value. procedure(real_operator_cons), public, pass(rhs) :: real_multiply_cons Operator real * cons . procedure(symmetric_operator), public, pass(lhs) :: sub Operator - . procedure(velocity_interface), public, pass(self) :: velocity Return velocity vector.","tags":"","loc":"module/foreseer_conservative_object.html","title":"foreseer_conservative_object – FORESEER"},{"text":"Uses: foreseer_compressible_transformations foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_compressible foreseer_eos_object foreseer_primitive_compressible foreseer_primitive_object foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_object module~~foreseer~~UsesGraph module~foreseer foreseer module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~penf penf module~penf->module~foreseer_eos_object module~penf->module~foreseer_eos_compressible module~penf->module~foreseer_conservative_object module~penf->module~foreseer_riemann_solver_object module~penf->module~foreseer_primitive_object module~penf->module~foreseer_riemann_solver_compressible_object module~penf->module~foreseer_conservative_compressible module~penf->module~foreseer_primitive_compressible module~penf->module~foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_compressible_transformations module~penf->module~foreseer_riemann_solver_compressible_llf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~penf_stringify vecfor vecfor vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_primitive_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_llf var panmoduleforeseerUsesGraph = svgPanZoom('#moduleforeseerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER, FOrtran RiEmann SolvErs EnviRonment. Used By module~~foreseer~~UsedByGraph module~foreseer foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/foreseer.html","title":"foreseer – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_object~~UsesGraph module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~penf penf module~penf->module~foreseer_riemann_solver_compressible_object module~penf->module~foreseer_eos_object module~penf->module~foreseer_conservative_object module~penf->module~foreseer_riemann_solver_object module~penf->module~foreseer_conservative_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~penf_stringify var panmoduleforeseer_riemann_solver_compressible_objectUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Riemann solver for ideal compressible fluid for FORESEER library. Used By module~~foreseer_riemann_solver_compressible_object~~UsedByGraph module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_objectUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_object Functions description Subroutines compute_fluxes set_states14 Derived Types type, public, abstract, extends( riemann_solver_object ) :: riemann_solver_compressible_object Riemann solver for ideal compressible fluid object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. real(kind=R8P), public :: d_1 = 0._R8P (gamma-1)/2 of state 1. real(kind=R8P), public :: d_4 = 0._R8P (gamma-1)/2 of state 4. real(kind=R8P), public :: e_1 = 0._R8P 2*g/(g-1) of state 1. real(kind=R8P), public :: e_4 = 0._R8P 2*g/(g-1) of state 4. real(kind=R8P), public :: g_1 = 0._R8P Specific heats ratio gamma=cp/cv of state 1. real(kind=R8P), public :: g_4 = 0._R8P Specific heats ratio gamma=cp/cv of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure(compute_waves_interface), public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure(initialize_interface), public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure(solve_interface), public, pass(self) :: solve Solve Riemann Problem. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given.","tags":"","loc":"module/foreseer_riemann_solver_compressible_object.html","title":"foreseer_riemann_solver_compressible_object – FORESEER"},{"text":"Uses: foreseer_eos_object penf vecfor module~~foreseer_primitive_object~~UsesGraph module~foreseer_primitive_object foreseer_primitive_object module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_primitive_object vecfor vecfor vecfor->module~foreseer_primitive_object module~penf penf module~penf->module~foreseer_primitive_object module~penf->module~foreseer_eos_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmoduleforeseer_primitive_objectUsesGraph = svgPanZoom('#moduleforeseer_primitive_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract primitive state of a Riemann Problem for FORESEER library. Used By module~~foreseer_primitive_object~~UsedByGraph module~foreseer_primitive_object foreseer_primitive_object module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer foreseer module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer_compressible_transformations program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_compressible_transformations->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_primitive_objectUsedByGraph = svgPanZoom('#moduleforeseer_primitive_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces array_interface assignment_interface description_interface destroy_interface energy_interface initialize_interface momentum_interface prim_operator_real real_operator_prim symmetric_operator unary_operator Derived Types primitive_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function array_interface (self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. abstract interface Abstract interfaces of deferred methods of primitive_object . private pure subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental subroutine destroy_interface (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function energy_interface (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. abstract interface Abstract interfaces of deferred methods of primitive_object . private subroutine initialize_interface (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function momentum_interface (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. abstract interface Abstract interfaces of deferred methods of primitive_object . private function prim_operator_real (lhs, rhs) result(operator_result) Operator prim.op.real . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of primitive_object . private function real_operator_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of primitive_object . private function symmetric_operator (lhs, rhs) result(operator_result) Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of primitive_object . private function unary_operator (self) result(operator_result) Unary operator .op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Derived Types type, public, abstract :: primitive_object Convervative object class. Type-Bound Procedures procedure(symmetric_operator), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(destroy_interface), public, pass(self) :: destroy Destroy primitive. procedure(energy_interface), public, pass(self) :: energy Return energy value. procedure(initialize_interface), public, pass(self) :: initialize Initialize primitive. procedure(momentum_interface), public, pass(self) :: momentum Return momentum vector. procedure(unary_operator), public, pass(self) :: negative Unary operator - prim . generic, public :: operator(*) => prim_multiply_prim, prim_multiply_real, real_multiply_prim Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => prim_divide_real Overload / . procedure(unary_operator), public, pass(self) :: positive Unary operator + prim . procedure(assignment_interface), public, pass(lhs) :: prim_assign_prim Operator = . procedure(prim_operator_real), public, pass(lhs) :: prim_divide_real Operator prim / real . procedure(symmetric_operator), public, pass(lhs) :: prim_multiply_prim Operator * . procedure(prim_operator_real), public, pass(lhs) :: prim_multiply_real Operator prim * real . procedure(real_operator_prim), public, pass(rhs) :: real_multiply_prim Operator real * prim . procedure(symmetric_operator), public, pass(lhs) :: sub Operator - .","tags":"","loc":"module/foreseer_primitive_object.html","title":"foreseer_primitive_object – FORESEER"},{"text":"Uses: foreseer penf foodie vecfor wenoof module~~foreseer_euler_1d~~UsesGraph module~foreseer_euler_1d foreseer_euler_1d module~penf penf module~penf->module~foreseer_euler_1d module~wenoof wenoof module~penf->module~wenoof module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf vecfor vecfor vecfor->module~foreseer_euler_1d vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_primitive_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_llf module~wenoof->module~foreseer_euler_1d module~foreseer foreseer module~foreseer->module~foreseer_euler_1d module~foodie foodie module~foodie->module~foreseer_euler_1d module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~wenoof_reconstructor_js iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth var panmoduleforeseer_euler_1dUsesGraph = svgPanZoom('#moduleforeseer_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Definition of Euler 1D class for FORESEER test. Used By module~~foreseer_euler_1d~~UsedByGraph module~foreseer_euler_1d foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces reconstruct_interfaces_ riemann_solver_ Derived Types euler_1d Functions add_euler compute_dt dEuler_dt euler_local_error euler_multiply_euler euler_multiply_real output real_multiply_euler sub_euler Subroutines destroy euler_assign_euler euler_assign_real impose_boundary_conditions initialize reconstruct_interfaces_characteristic reconstruct_interfaces_conservative reconstruct_interfaces_primitive riemann_solver_llf riemann_solver_pvl Abstract Interfaces abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine reconstruct_interfaces_ (self, conservative, r_conservative) Reconstruct interface states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative variables. abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine riemann_solver_ (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Derived Types type, public, extends( integrand ) :: euler_1d Euler 1D PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: BC_L Left boundary condition type. character(len=:), public, allocatable :: BC_R Right boundary condition type. real(kind=R8P), public :: Dx = 0._R8P Space step. integer(kind=I4P), public :: Ng = 0 Ghost cells number. integer(kind=I4P), public :: Ni = 0 Space dimension. type( conservative_compressible ), public, allocatable :: U (:) Integrand (state) variables. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. type( eos_compressible ), public :: eos Equation of state. class( interpolator_object ), public, allocatable :: interpolator WENO interpolator. procedure( reconstruct_interfaces_ ), public, pointer :: reconstruct_interfaces => reconstruct_interfaces_characteristic Reconstruct interface states. procedure( riemann_solver_ ), public, pointer :: riemann_solver => riemann_solver_llf Actual Riemann Problem solver. integer(kind=I4P), public :: weno_order = 0 WENO reconstruction order. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Operator + . procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Operator = . procedure, public, pass(lhs) :: assign_real => euler_assign_real Operator euler = real . generic, public :: assignment(=) => assign_integrand Overloading = assignament. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: initialize Initialize field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Operator * . procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Operator euler * real . procedure, public, pass(lhs) :: local_error => euler_local_error Operator ||euler-euler|| . generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(-) => sub Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure, public, pass(self) :: output Extract Euler field. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Operator real * euler . procedure, private, pass(self) :: reconstruct_interfaces_characteristic Reconstruct (charc.) interface states. procedure, private, pass(self) :: reconstruct_interfaces_conservative Reconstruct (cons.) interface states. procedure, private, pass(self) :: reconstruct_interfaces_primitive Reconstruct (prim.) interface states. procedure, private, pass(self) :: riemann_solver_llf LLF Riemann Problem solver. procedure, private, pass(self) :: riemann_solver_pvl PVL Riemann Problem solver. procedure, public, pass(lhs) :: sub => sub_euler Operator - . procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. Functions private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private pure function compute_dt (self, steps_max, t_max, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. integer(kind=I4P), intent(in) :: steps_max Maximun number of time steps. real(kind=R8P), intent(in) :: t_max Maximum integration time. real(kind=R8P), intent(in) :: t Time. real(kind=R8P), intent(in) :: CFL CFL value. Return Value real(kind=R8P) Time step. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. real(kind=R8P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private pure function output (self, is_primitive) result(state) Output the Euler field state. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. logical, intent(in), optional :: is_primitive Output in primitive variables. Return Value real(kind=R8P),\n  allocatable, (:,:) Euler state vector. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Subroutines private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private pure subroutine impose_boundary_conditions (self, U) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(inout) :: U (1-self%Ng:) Conservative variables. private subroutine initialize (self, Ni, Dx, BC_L, BC_R, initial_state, eos, weno_order, weno_variables, riemann_solver_scheme) Initialize field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. integer(kind=I4P), intent(in) :: Ni Space dimension. real(kind=R8P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. type( primitive_compressible ), intent(in) :: initial_state (1:) Initial state of primitive variables. type( eos_compressible ), intent(in) :: eos Equation of state. integer(kind=I4P), intent(in), optional :: weno_order WENO reconstruction order. character(len=*), intent(in), optional :: weno_variables Variables on which WENO reconstruction is done. character(len=*), intent(in), optional :: riemann_solver_scheme Riemann solver scheme. private subroutine reconstruct_interfaces_characteristic (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine reconstruct_interfaces_conservative (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine reconstruct_interfaces_primitive (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine riemann_solver_llf (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private subroutine riemann_solver_pvl (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_euler_1d.html","title":"foreseer_euler_1d – FORESEER"},{"text":"Uses: iso_fortran_env module~~face~~UsesGraph module~face face iso_fortran_env iso_fortran_env iso_fortran_env->module~face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FACE, Fortran Ansi Colors Environment Used By module~~face~~UsedByGraph module~face face module~flap_command_line_interface_t flap_command_line_interface_t module~face->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~face->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t flap_command_line_argument_t module~face->module~flap_command_line_argument_t module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube var panmodulefaceUsedByGraph = svgPanZoom('#modulefaceUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables CODE_CLEAR CODE_END CODE_START COLORS_BG COLORS_FG ESCAPE LOWER_ALPHABET NL STYLES UPPER_ALPHABET Functions color_index colorize style_index upper Subroutines colors_samples styles_samples Variables Type Visibility Attributes Name Initial character(len=4), private, parameter :: CODE_CLEAR = CODE_START//'0'//CODE_END Clear all styles, \"[0m\". character(len=1), private, parameter :: CODE_END = 'm' End ansi code, \"m\". character(len=2), private, parameter :: CODE_START = ESCAPE//'[' Start ansi code, \"[\". character(len=15), private, parameter :: COLORS_BG (1:2,1:17) = reshape(['BLACK          ', '40             ', 'RED            ', '41             ', 'GREEN          ', '42             ', 'YELLOW         ', '43             ', 'BLUE           ', '44             ', 'MAGENTA        ', '45             ', 'CYAN           ', '46             ', 'WHITE          ', '47             ', 'DEFAULT        ', '49             ', 'BLACK_INTENSE  ', '100            ', 'RED_INTENSE    ', '101            ', 'GREEN_INTENSE  ', '102            ', 'YELLOW_INTENSE ', '103            ', 'BLUE_INTENSE   ', '104            ', 'MAGENTA_INTENSE', '105            ', 'CYAN_INTENSE   ', '106            ', 'WHITE_INTENSE  ', '107            '], [2, 17]) Background colors. character(len=15), private, parameter :: COLORS_FG (1:2,1:17) = reshape(['BLACK          ', '30             ', 'RED            ', '31             ', 'GREEN          ', '32             ', 'YELLOW         ', '33             ', 'BLUE           ', '34             ', 'MAGENTA        ', '35             ', 'CYAN           ', '36             ', 'WHITE          ', '37             ', 'DEFAULT        ', '39             ', 'BLACK_INTENSE  ', '90             ', 'RED_INTENSE    ', '91             ', 'GREEN_INTENSE  ', '92             ', 'YELLOW_INTENSE ', '93             ', 'BLUE_INTENSE   ', '94             ', 'MAGENTA_INTENSE', '95             ', 'CYAN_INTENSE   ', '96             ', 'WHITE_INTENSE  ', '97             '], [2, 17]) Foreground colors. character(len=1), private, parameter :: ESCAPE = achar(27) \"\" character. character(len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(len=1), private, parameter :: NL = new_line('a') New line character. character(len=17), private, parameter :: STYLES (1:2,1:16) = reshape(['BOLD_ON          ', '1                ', 'ITALICS_ON       ', '3                ', 'UNDERLINE_ON     ', '4                ', 'INVERSE_ON       ', '7                ', 'STRIKETHROUGH_ON ', '9                ', 'BOLD_OFF         ', '22               ', 'ITALICS_OFF      ', '23               ', 'UNDERLINE_OFF    ', '24               ', 'INVERSE_OFF      ', '27               ', 'STRIKETHROUGH_OFF', '29               ', 'FRAMED_ON        ', '51               ', 'ENCIRCLED_ON     ', '52               ', 'OVERLINED_ON     ', '53               ', 'FRAMED_OFF       ', '54               ', 'ENCIRCLED_OFF    ', '54               ', 'OVERLINED_OFF    ', '55               '], [2, 16]) Styles. character(len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. Functions private elemental function color_index (color) Return the array-index corresponding to the queried color. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: color Color definition. Return Value integer(kind=int32) Index into the colors arrays. public pure function colorize (string, color_fg, color_bg, style) result(colorized) Colorize and stylize strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. character(len=*), intent(in), optional :: color_fg Foreground color definition. character(len=*), intent(in), optional :: color_bg Background color definition. character(len=*), intent(in), optional :: style Style definition. Return Value character(len=:),\n  allocatable Colorized string. private elemental function style_index (style) Return the array-index corresponding to the queried style. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: style Style definition. Return Value integer(kind=int32) Index into the styles array. private elemental function upper (string) Return a string with all uppercase characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input string. Return Value character(len=len(string)) Upper case string. Subroutines public subroutine colors_samples () Print to standard output all colors samples. Arguments None public subroutine styles_samples () Print to standard output all styles samples. Arguments None","tags":"","loc":"module/face.html","title":"face – FORESEER"},{"text":"Uses: face flap_command_line_argument_t flap_command_line_arguments_group_t flap_object_t flap_utils_m penf module~~flap_command_line_interface_t~~UsesGraph module~flap_command_line_interface_t flap_command_line_interface_t module~face face module~face->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~face->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~face->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~penf penf module~penf->module~flap_command_line_interface_t module~penf->module~flap_utils_m module~penf->module~flap_command_line_argument_t module~penf->module~flap_command_line_arguments_group_t module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~face iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmoduleflap_command_line_interface_tUsesGraph = svgPanZoom('#moduleflap_command_line_interface_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Command Line Interface (CLI) class. Used By module~~flap_command_line_interface_t~~UsedByGraph module~flap_command_line_interface_t flap_command_line_interface_t module~flap flap module~flap_command_line_interface_t->module~flap program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ERROR_MISSING_CLA ERROR_MISSING_GROUP ERROR_MISSING_SELECTION_CLA ERROR_TOO_FEW_CLAS MAX_VAL_LEN Derived Types command_line_interface Functions is_called_group is_defined is_defined_group is_parsed is_passed signature usage Subroutines add add_group check check_m_exclusive cli_assign_cli errored finalize free get_args_from_invocation get_args_from_string get_cla get_cla_list get_cla_list_varying_I1P get_cla_list_varying_I2P get_cla_list_varying_I4P get_cla_list_varying_I8P get_cla_list_varying_R16P get_cla_list_varying_R4P get_cla_list_varying_R8P get_cla_list_varying_char get_cla_list_varying_logical get_clasg_indexes init parse print_usage save_man_page save_usage_to_markdown set_mutually_exclusive_groups Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: ERROR_MISSING_CLA = 25 CLA not found in CLI. integer(kind=I4P), public, parameter :: ERROR_MISSING_GROUP = 26 Group not found in CLI. integer(kind=I4P), public, parameter :: ERROR_MISSING_SELECTION_CLA = 27 CLA selection in CLI failing. integer(kind=I4P), public, parameter :: ERROR_TOO_FEW_CLAS = 28 Insufficient arguments for CLI. integer(kind=I4P), public, parameter :: MAX_VAL_LEN = 1000 Maximum number of characters of CLA value. Derived Types type, public, extends( object ) :: command_line_interface Command Line Interface (CLI) class. Components Type Visibility Attributes Name Initial character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=:), public, allocatable :: authors Authors list. type( command_line_arguments_group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=:), public, allocatable :: description Detailed description. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=512), private, allocatable :: examples (:) Examples of correct usage. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. logical, private :: is_parsed_ = .false. Parse status. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: progname Program name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: add Add CLA to CLI. procedure, public :: add_group Add CLAs group CLI. procedure, public, pass(lhs ) :: assign_object Assignment overloading. generic, private :: assignment(=) => cli_assign_cli CLI assignment overloading. procedure, private :: check Check data consistency. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. procedure, private :: cli_assign_cli CLI assignment overloading. procedure, private :: errored Trig error occurence and print meaningful message. procedure, public :: free Free dynamic memory. procedure, public, pass(self) :: free_object Free dynamic memory. generic, public :: get => get_cla, get_cla_list Get CLA value(s) from CLAs list parsed. generic, private :: get_args => get_args_from_string, get_args_from_invocation Get CLAs. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. procedure, private :: get_args_from_string Get CLAs from string. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. procedure, private :: get_clasg_indexes Get CLAs groups indexes. generic, public :: get_varying => get_cla_list_varying_R8P, get_cla_list_varying_R4P, get_cla_list_varying_I8P, get_cla_list_varying_I4P, get_cla_list_varying_I2P, get_cla_list_varying_I1P, get_cla_list_varying_logical, get_cla_list_varying_char Get CLA value(s) from CLAs list parsed, varying size list. procedure, public :: init Initialize CLI. procedure, public :: is_defined Check if a CLA has been defined. procedure, public :: is_defined_group Check if a CLAs group has been defined. procedure, public :: is_parsed Check if CLI has been parsed. procedure, public :: is_passed Check if a CLA has been passed. procedure, public :: parse Parse Command Line Interfaces. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public :: print_usage Print correct usage of CLI. procedure, public, pass(self) :: print_version Print version. procedure, public :: run_command => is_called_group Check if a CLAs group has been run. procedure, public :: save_man_page Save man page build on CLI. procedure, public :: save_usage_to_markdown Save parts of the CLI as markdown. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. procedure, public :: signature Get CLI signature. procedure, public :: usage Get CLI usage. Functions private function is_called_group (self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. private function is_defined (self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. private function is_defined_group (self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. private elemental function is_parsed (self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. private function is_passed (self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. private function signature (self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value character(len=:),\n  allocatable Signature. private function usage (self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),\n  allocatable Usage string. Subroutines private subroutine add (self, pref, group, group_index, switch, switch_ab, help, help_markdown, help_color, help_style, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. character(len=*), intent(in), optional :: help_markdown Longer help message, markdown formatted. character(len=*), intent(in), optional :: help_color ANSI color of help messages. character(len=*), intent(in), optional :: help_style ANSI style of help messages. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine add_group (self, help, description, exclude, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. private subroutine check (self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. private subroutine errored (self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R16P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_clasg_indexes (self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine init (self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun, error_color, error_style) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help. integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info. integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info. character(len=*), intent(in), optional :: error_color ANSI color of error messages. character(len=*), intent(in), optional :: error_style ANSI style of error messages. private subroutine parse (self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine print_usage (self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine save_man_page (self, man_file, error) Save man page build on the CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine save_usage_to_markdown (self, markdown_file, error) Save the CLI as a markdown page, for inclusion into the documentation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine set_mutually_exclusive_groups (self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs.","tags":"","loc":"module/flap_command_line_interface_t.html","title":"flap_command_line_interface_t – FORESEER"},{"text":"Uses: face flap_command_line_argument_t flap_object_t penf module~~flap_command_line_arguments_group_t~~UsesGraph module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf penf module~penf->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~face face module~face->module~flap_command_line_arguments_group_t module~face->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_argument_t module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~face iso_fortran_env->module~flap_object_t iso_fortran_env->module~penf_stringify module~flap_utils_m->module~flap_command_line_argument_t var panmoduleflap_command_line_arguments_group_tUsesGraph = svgPanZoom('#moduleflap_command_line_arguments_group_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Command Line Arguments Group (CLAsG) class. Used By module~~flap_command_line_arguments_group_t~~UsedByGraph module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap flap module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_interface_t->module~flap program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube var panmoduleflap_command_line_arguments_group_tUsedByGraph = svgPanZoom('#moduleflap_command_line_arguments_group_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ERROR_CONSISTENCY ERROR_M_EXCLUDE STATUS_PRINT_H STATUS_PRINT_V Derived Types command_line_arguments_group Functions is_defined is_passed signature usage Subroutines add check check_m_exclusive clasg_assign_clasg errored finalize free is_required_passed parse raise_error_m_exclude sanitize_defaults Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: ERROR_CONSISTENCY = 23 CLAs group consistency error. integer(kind=I4P), private, parameter :: ERROR_M_EXCLUDE = 24 Two mutually exclusive CLAs group have been called. integer(kind=I4P), public, parameter :: STATUS_PRINT_H = -2 Print help status. integer(kind=I4P), public, parameter :: STATUS_PRINT_V = -1 Print version status. Derived Types type, public, extends( object ) :: command_line_arguments_group Command Line Arguments Group (CLAsG) class. Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_optional = 0_I4P Number of optional command line arguments. integer(kind=I4P), private :: Na_required = 0_I4P Number of required command line arguments. character(len=:), public, allocatable :: authors Authors list. type( command_line_argument ), public, allocatable :: cla (:) CLA list [1:Na]. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=:), public, allocatable :: group Group name (command). character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. logical, public :: is_called = .false. Flag for checking if CLAs group has been passed to CLI. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: progname Program name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: add Add CLA to CLAsG. procedure, public, pass(lhs ) :: assign_object Assignment overloading. generic, private :: assignment(=) => clasg_assign_clasg Assignment operator overloading. procedure, public :: check Check data consistency. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs have been passed. procedure, private :: clasg_assign_clasg Assignment operator. procedure, private :: errored Trig error occurrence and print meaningful message. procedure, public :: free Free dynamic memory. procedure, public, pass(self) :: free_object Free dynamic memory. procedure, public :: is_defined Check if a CLA has been defined. procedure, public :: is_passed Check if a CLA has been passed. procedure, public :: is_required_passed Check if required CLAs are passed. procedure, public :: parse Parse CLAsG arguments. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: print_version Print version. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. procedure, public :: sanitize_defaults Sanitize default values. procedure, public :: signature Get CLAsG signature. procedure, public :: usage Get correct CLAsG usage. Functions private function is_defined (self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. private pure function is_passed (self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. private function signature (self) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. Return Value character(len=:),\n  allocatable Signature. private function usage (self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),\n  allocatable Usage string. Subroutines private subroutine add (self, pref, cla) Add CLA to CLAs list. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. private subroutine errored (self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. private subroutine is_required_passed (self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine parse (self, args, pref) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in) :: args (:) Command line arguments. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine sanitize_defaults (self) Sanitize defaults values. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data.","tags":"","loc":"module/flap_command_line_arguments_group_t.html","title":"flap_command_line_arguments_group_t – FORESEER"},{"text":"Uses: penf module~~flap_utils_m~~UsesGraph module~flap_utils_m flap_utils_m module~penf penf module~penf->module~flap_utils_m module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLAP utils. Used By module~~flap_utils_m~~UsedByGraph module~flap_utils_m flap_utils_m module~flap_command_line_argument_t flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap flap module~flap_command_line_argument_t->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap var panmoduleflap_utils_mUsedByGraph = svgPanZoom('#moduleflap_utils_mUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces count Functions count_substring replace replace_all unique upper_case wstrip Subroutines tokenize Interfaces public interface count Overload intrinsic function count for counting substring occurences into strings. private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Functions private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. public pure function replace (string, substring, restring) result(newstring) Replace substring (only first occurrence) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. public pure function replace_all (string, substring, restring) result(newstring) Replace substring (all occurrences) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. public elemental function unique (string, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be parsed. character(len=*), intent(in) :: substring Substring which multiple occurences must be reduced to one. Return Value character(len=len(string)) String parsed. public elemental function upper_case (string) Convert the lower case characters of a string to upper case one. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. public pure function wstrip (string) result(newstring) Strip out leading and trailing white spaces from a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. Return Value character(len=:),\n  allocatable New modified string. Subroutines public pure subroutine tokenize (strin, delimiter, toks, Nt) Tokenize a string in order to parse it. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens.","tags":"","loc":"module/flap_utils_m.html","title":"flap_utils_m – FORESEER"},{"text":"Uses: face flap_object_t flap_utils_m penf module~~flap_command_line_argument_t~~UsesGraph module~flap_command_line_argument_t flap_command_line_argument_t module~penf penf module~penf->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~face face module~face->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_argument_t module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~face iso_fortran_env->module~flap_object_t iso_fortran_env->module~penf_stringify var panmoduleflap_command_line_argument_tUsesGraph = svgPanZoom('#moduleflap_command_line_argument_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Command Line Argument (CLA) class. Used By module~~flap_command_line_argument_t~~UsedByGraph module~flap_command_line_argument_t flap_command_line_argument_t module~flap flap module~flap_command_line_argument_t->module~flap module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube module~flap_command_line_interface_t->module~flap module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t var panmoduleflap_command_line_argument_tUsedByGraph = svgPanZoom('#moduleflap_command_line_argument_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ACTION_PRINT_HELP ACTION_PRINT_VERS ACTION_STORE ACTION_STORE_FALSE ACTION_STORE_STAR ACTION_STORE_TRUE ARGS_SEP ERROR_ACTION_UNKNOWN ERROR_CASTING_LOGICAL ERROR_CHOICES_LOGICAL ERROR_ENVVAR_NARGS ERROR_ENVVAR_NOT_STORE ERROR_ENVVAR_POSITIONAL ERROR_MISSING_REQUIRED ERROR_M_EXCLUDE ERROR_NAMED_NO_NAME ERROR_NARGS_INSUFFICIENT ERROR_NOT_IN_CHOICES ERROR_NO_LIST ERROR_OPTIONAL_NO_DEF ERROR_POSITIONAL_M_EXCLUDE ERROR_POSITIONAL_NO_POSITION ERROR_POSITIONAL_NO_STORE ERROR_REQUIRED_M_EXCLUDE ERROR_STORE_STAR_ENVVAR ERROR_STORE_STAR_NARGS ERROR_STORE_STAR_POSITIONAL ERROR_UNKNOWN ERROR_VALUE_MISSING Derived Types command_line_argument Functions check_list_size is_required_passed signature usage Subroutines check check_action_consistency check_choices check_envvar_consistency check_m_exclude_consistency check_named_consistency check_optional_consistency check_positional_consistency cla_assign_cla errored finalize free get_cla get_cla_from_buffer get_cla_list get_cla_list_from_buffer get_cla_list_varying_I1P get_cla_list_varying_I2P get_cla_list_varying_I4P get_cla_list_varying_I8P get_cla_list_varying_R16P get_cla_list_varying_R4P get_cla_list_varying_R8P get_cla_list_varying_char get_cla_list_varying_logical raise_error_m_exclude raise_error_nargs_insufficient raise_error_switch_unknown raise_error_value_missing sanitize_defaults Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: ACTION_PRINT_HELP = 'PRINT_HELP' Print help message. character(len=*), public, parameter :: ACTION_PRINT_VERS = 'PRINT_VERSION' Print version. character(len=*), public, parameter :: ACTION_STORE = 'STORE' Store value (if invoked a value must be passed). character(len=*), public, parameter :: ACTION_STORE_FALSE = 'STORE_FALSE' Store .false. without the necessity of a value. character(len=*), public, parameter :: ACTION_STORE_STAR = 'STORE*' Store value or revert on default is invoked alone. character(len=*), public, parameter :: ACTION_STORE_TRUE = 'STORE_TRUE' Store .true. without the necessity of a value. character(len=*), public, parameter :: ARGS_SEP = '||!||' Arguments separator for multiple valued (list) CLA. integer(kind=I4P), private, parameter :: ERROR_ACTION_UNKNOWN = 22 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: ERROR_CASTING_LOGICAL = 10 Error casting CLA value to logical type. integer(kind=I4P), private, parameter :: ERROR_CHOICES_LOGICAL = 11 Error adding choices check for CLA val of logical type. integer(kind=I4P), private, parameter :: ERROR_ENVVAR_NARGS = 18 Envvar not allowed for list-values CLA. integer(kind=I4P), private, parameter :: ERROR_ENVVAR_NOT_STORE = 17 Envvar not allowed action different from store; integer(kind=I4P), private, parameter :: ERROR_ENVVAR_POSITIONAL = 16 Envvar not allowed for positional CLA. integer(kind=I4P), private, parameter :: ERROR_MISSING_REQUIRED = 8 Missing required CLA. integer(kind=I4P), private, parameter :: ERROR_M_EXCLUDE = 9 Two mutually exclusive CLAs have been passed. integer(kind=I4P), private, parameter :: ERROR_NAMED_NO_NAME = 4 Named CLA without switch name. integer(kind=I4P), private, parameter :: ERROR_NARGS_INSUFFICIENT = 13 Multi-valued CLA with insufficient arguments. integer(kind=I4P), private, parameter :: ERROR_NOT_IN_CHOICES = 7 CLA value out of a specified choices. integer(kind=I4P), private, parameter :: ERROR_NO_LIST = 12 Actual CLA is not list-values. integer(kind=I4P), private, parameter :: ERROR_OPTIONAL_NO_DEF = 1 Optional CLA without default value. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_M_EXCLUDE = 3 Positional CLA cannot exclude others. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_NO_POSITION = 5 Positional CLA without position. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_NO_STORE = 6 Positional CLA without action_store. integer(kind=I4P), private, parameter :: ERROR_REQUIRED_M_EXCLUDE = 2 Required CLA cannot exclude others. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_ENVVAR = 21 Action store* not allowed for environment variable CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_NARGS = 20 Action store* not allowed for list-values CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_POSITIONAL = 19 Action store* not allowed for positional CLA. integer(kind=I4P), private, parameter :: ERROR_UNKNOWN = 15 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: ERROR_VALUE_MISSING = 14 Missing value of CLA. Derived Types type, public, extends( object ) :: command_line_argument Command Line Argument (CLA) class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: act CLA value action. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), public, allocatable :: def Default value. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: envvar Environment variable from which take value. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. logical, public :: is_hidden = .false. Flag for hiding CLA, thus it does not compare into help. logical, public :: is_passed = .false. Flag for checking if CLA has been passed to CLI. logical, public :: is_positional = .false. Flag for checking if CLA is a positional or a named CLA. logical, public :: is_required = .false. Flag for set required argument. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: nargs Number of arguments consumed by CLA. integer(kind=I4P), public :: position = 0_I4P Position of positional CLA. character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: switch Switch name. character(len=:), public, allocatable :: switch_ab Abbreviated switch name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: val CLA value. character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Finalizations Procedures final :: finalize Free dynamic memory when finalizing. Type-Bound Procedures procedure, public, pass(lhs ) :: assign_object Assignment overloading. generic, private :: assignment(=) => cla_assign_cla Assignment operator overloading. procedure, public :: check Check data consistency. procedure, private :: check_action_consistency Check CLA action consistency. procedure, private :: check_choices Check if CLA value is in allowed choices. procedure, private :: check_envvar_consistency Check data consistency for envvar CLA. procedure, private :: check_list_size Check CLA multiple values list size consistency. procedure, private :: check_m_exclude_consistency Check mutually exclusion consistency. procedure, private :: check_named_consistency Check named CLA consistency. procedure, private :: check_optional_consistency Check optional CLA consistency. procedure, private :: check_positional_consistency Check positional CLA consistency. procedure, private :: cla_assign_cla Assignment operator. procedure, private :: errored Trig error occurence and print meaningful message. procedure, public :: free Free dynamic memory. procedure, public, pass(self) :: free_object Free dynamic memory. generic, public :: get => get_cla, get_cla_list Get CLA value(s). procedure, private :: get_cla Get CLA (single) value. procedure, private :: get_cla_from_buffer Get CLA (single) value from a buffer. procedure, private :: get_cla_list Get CLA multiple values. procedure, private :: get_cla_list_from_buffer Get CLA (single) value from a buffer. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values, varying size, I1P. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values, varying size, I2P. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values, varying size, I4P. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values, varying size, I8P. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values, varying size, R16P. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values, varying size, R4P. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values, varying size, R8P. procedure, private :: get_cla_list_varying_char Get CLA multiple values, varying size, char. procedure, private :: get_cla_list_varying_logical Get CLA multiple values, varying size, bool. generic, public :: get_varying => get_cla_list_varying_R8P, get_cla_list_varying_R4P, get_cla_list_varying_I8P, get_cla_list_varying_I4P, get_cla_list_varying_I2P, get_cla_list_varying_I1P, get_cla_list_varying_logical, get_cla_list_varying_char Get CLA value(s) from varying size list. procedure, public :: is_required_passed Check if required CLA is passed. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: print_version Print version. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. procedure, public :: raise_error_nargs_insufficient Raise error insufficient number of argument values passed. procedure, public :: raise_error_switch_unknown Raise error switch_unknown. procedure, public :: raise_error_value_missing Raise error missing value. procedure, public :: sanitize_defaults Sanitize default values. procedure, public :: signature Get signature. procedure, public :: usage Get correct usage. Functions private function check_list_size (self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. private function is_required_passed (self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. private function signature (self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value character(len=:),\n  allocatable Signature. private function usage (self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),\n  allocatable Usage string. Subroutines private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_action_consistency (self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_choices (self, val, pref) Check if CLA value is in allowed choices. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_envvar_consistency (self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_m_exclude_consistency (self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_named_consistency (self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_optional_consistency (self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine check_positional_consistency (self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. private subroutine errored (self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_from_buffer (self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. private subroutine get_cla_list_from_buffer (self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R16P (self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine raise_error_nargs_insufficient (self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine raise_error_switch_unknown (self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine raise_error_value_missing (self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine sanitize_defaults (self) Sanitize defaults values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data.","tags":"","loc":"module/flap_command_line_argument_t.html","title":"flap_command_line_argument_t – FORESEER"},{"text":"Uses: iso_fortran_env penf module~~flap_object_t~~UsesGraph module~flap_object_t flap_object_t module~penf penf module~penf->module~flap_object_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Base (abstract) class upon which FLAP's concrete classes are built. Used By module~~flap_object_t~~UsedByGraph module~flap_object_t flap_object_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_object_t->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube var panmoduleflap_object_tUsedByGraph = svgPanZoom('#moduleflap_object_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types object Subroutines assign_object free_object print_error_message print_version Derived Types type, public, abstract :: object Base (abstract) class upon which FLAP's concrete classes are built. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: epilog Epilogue message. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. character(len=:), public, allocatable :: error_color ANSI color of error messages. integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. character(len=:), public, allocatable :: error_style ANSI style of error messages. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_color ANSI color of help messages. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: help_style ANSI style of help messages. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: progname Program name. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages character(len=:), public, allocatable :: version Program version. integer(kind=I4P), public :: version_lun = stdout Output unit to print version message Type-Bound Procedures procedure, public, pass(lhs ) :: assign_object Assignment overloading. procedure, public, pass(self) :: free_object Free dynamic memory. procedure, public, pass(self) :: print_error_message Print meaningful error message. procedure, public, pass(self) :: print_version Print version. Subroutines private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string.","tags":"","loc":"module/flap_object_t.html","title":"flap_object_t – FORESEER"},{"text":"Uses: flap_command_line_argument_t flap_command_line_arguments_group_t flap_command_line_interface_t module~~flap~~UsesGraph module~flap flap module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~face face module~face->module~flap_command_line_interface_t module~face->module~flap_command_line_argument_t module~face->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~penf penf module~penf->module~flap_command_line_interface_t module~penf->module~flap_command_line_argument_t module~penf->module~flap_command_line_arguments_group_t module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~face iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmoduleflapUsesGraph = svgPanZoom('#moduleflapUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLAP, Fortran command Line Arguments Parser for poor people Used By module~~flap~~UsedByGraph module~flap flap program~foreseer_test_shock_tube foreseer_test_shock_tube module~flap->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/flap.html","title":"flap – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_backward_differentiation_formula~~UsesGraph module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_backward_differentiation_formula Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Backward Differentiation Formula class scheme implemented is:  U&#94;{n+N_s} + \\sum_{s=1}&#94;{N_s} \\alpha_s U&#94;{n+N_s-s} = \\Delta t \\left[ \\beta R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients \\alpha_s and \\beta define the actual scheme, that is selected accordingly\n to the number of steps used. Currently, the following schemes are available: Step beta alpha 1 alpha 2 alpha 3 alpha 4 alpha 5 alpha 6 1 1 -1 2 2/3 -4/3 1/3 3 6/11 -18/11 9/11 -2/11 4 12/25 -48/25 36/25 -16/25 3/25 5 60/137 -300/137 300/137 -200/137 75/137 -12/137 6 60/147 -360/147 450/147 -400/147 225/147 -72/147 10/147 Bibliography Used By module~~foodie_integrator_backward_differentiation_formula~~UsedByGraph module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulefoodie_integrator_backward_differentiation_formulaUsedByGraph = svgPanZoom('#modulefoodie_integrator_backward_differentiation_formulaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_steps Derived Types back_df_integrator Functions is_supported max_steps min_steps Subroutines destroy init integrate update_previous Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 6 Maximum number of steps supported. integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of steps supported. character(len=99), private, parameter :: supported_steps = '1-6' List of supported steps number. Valid format is 1-2,4,9-23... . Derived Types type, public :: back_df_integrator FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order\n accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: a (:) \\alpha coefficients. real(kind=R_P), private :: b = 0.0_R_P \\beta coefficient. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: steps = 0 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. procedure, public, nopass :: max_steps Return the maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. Functions private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. private elemental subroutine init (self, steps) Create the actual BDF integrator: initialize the alpha and beta coefficients. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(inout) :: self BDF integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. private subroutine update_previous (self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( back_df_integrator ), intent(in) :: self Actual BDF integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field.","tags":"","loc":"module/foodie_integrator_backward_differentiation_formula.html","title":"foodie_integrator_backward_differentiation_formula – FORESEER"},{"text":"Uses: foodie_kinds module~~foodie_adt_integrand~~UsesGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_adt_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract type integrand for building FOODIE ODE integrators. Used By module~~foodie_adt_integrand~~UsedByGraph module~foodie_adt_integrand foodie_adt_integrand module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_adt_integrand->module~foodie module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulefoodie_adt_integrandUsedByGraph = svgPanZoom('#modulefoodie_adt_integrandUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces assignment_integrand integrand_op_real local_error_operator real_op_integrand symmetric_operator time_derivative Derived Types integrand Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private pure subroutine assignment_integrand (lhs, rhs) Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real (lhs, rhs) result(operator_result) Asymmetric type operator integrand.op.real. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function local_error_operator (lhs, rhs) result(error) Estimate local truncation error between 2 solution approximations. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand (lhs, rhs) result(operator_result) Asymmetric type operator real.op.integrand. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator (lhs, rhs) result(operator_result) Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative (self, t) result(dState_dt) Time derivative function of integrand class, i.e. the residuals function. Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Derived Types type, public, abstract :: integrand Abstract type for building FOODIE ODE integrators. Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures procedure(symmetric_operator), public, pass(lhs) :: add Integrand + integrand operator. procedure(assignment_integrand), public, pass(lhs) :: assign_integrand Integrand = integrand. generic, public :: assignment(=) => assign_integrand Overloading = assignament. procedure(symmetric_operator), public, pass(lhs) :: integrand_multiply_integrand Integrand * integrand operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_multiply_real Integrand * real operator. procedure(local_error_operator), public, pass(lhs) :: local_error ||integrand - integrand||. generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(-) => sub Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure(real_op_integrand), public, pass(rhs) :: real_multiply_integrand Real * integrand operator. procedure(symmetric_operator), public, pass(lhs) :: sub Integrand - integrand operator. procedure(time_derivative), public, pass(self) :: t Time derivative, residuals.","tags":"","loc":"module/foodie_adt_integrand.html","title":"foodie_adt_integrand – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_tvd_runge_kutta~~UsesGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_tvd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. 0 | 0\n ---|---\n    | 1 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. 0 | 0     0\n  1 | 1     0\n ---|-----------\n    | 1/2   1/2 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. 0   | 0     0     0\n  1   | 1     0     0\n  1/2 | 1/4   1/4   0\n -----|-----------------\n      | 1/6   1/6   1/3 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. 0                | 0                  0                  0                  0                  0\n  0.39175222700392 | 0.39175222700392   0                  0                  0                  0\n  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0\n  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0\n  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0\n ------------------|---------------------------------------------------------------------------------------------\n                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 Bibliography [1] Coefficients for the study of Runge-Kutta integration processes , Butcher, J.C., J. Austral. Math. Soc., Vol. 3,\n pages: 185–201, 1963. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of\n Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. Used By module~~foodie_integrator_tvd_runge_kutta~~UsedByGraph module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_stages Derived Types tvd_runge_kutta_integrator Functions is_supported max_stages min_stages Subroutines destroy init integrate Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 5 Maximum number of stages supported. integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of stages supported. character(len=99), private, parameter :: supported_stages = '1-3,5' List of supported stages number. Valid format is 1-2,4,9-23... . Derived Types type, public :: tvd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:) \\beta Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. procedure, public, nopass :: max_stages Return the maximum number of stages supported. procedure, public, nopass :: min_stages Return the minimum number of stages supported. Functions private elemental function is_supported (stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . private pure function max_stages () Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. private pure function min_stages () Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. private elemental subroutine init (self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. private subroutine integrate (self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_euler_explicit~~UsesGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By module~~foodie_integrator_euler_explicit~~UsedByGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie foodie module~foodie_integrator_euler_explicit->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_stages_steps Derived Types euler_explicit_integrator Functions is_supported max_stages_steps min_stages_steps Subroutines integrate Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 1 Maximum number of stages/steps supported. integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of stages/steps supported. character(len=1), private, parameter :: supported_stages_steps = '1' List of supported stages/steps number. Valid format is 1-2,4,9-23... . Derived Types type, public :: euler_explicit_integrator FOODIE integrator: provide an explicit Euler scheme, it being 1st order accurate. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of stages/steps is supported or not. procedure, public, nopass :: max_stages_steps Return the maximum number of stages/steps supported. procedure, public, nopass :: min_stages_steps Return the minimum number of stages/steps supported. Functions private elemental function is_supported (stages_steps) Check if the queried number of stages/steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages_steps Number of stages/steps used. Return Value logical Is true is the stages number is in supported_stages_steps . private pure function max_stages_steps () Return the maximum number of stages/steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages/steps supported. private pure function min_stages_steps () Return the minimum number of stages/steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages/steps supported. Subroutines private subroutine integrate (U, Dt, t) Integrate field with explicit Euler scheme, 1st order. Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FORESEER"},{"text":"FOODIE kinds: definition of reals and integer kind parameters of FOODIE library. Used By module~~foodie_kinds~~UsedByGraph module~foodie_kinds foodie_kinds module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulefoodie_kindsUsedByGraph = svgPanZoom('#modulefoodie_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables I1P I2P I4P I8P I_P R4P R8P R_P Variables Type Visibility Attributes Name Initial integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I_P = I4P Default integer precision. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R_P = R8P Default real precision.","tags":"","loc":"module/foodie_kinds.html","title":"foodie_kinds – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_leapfrog~~UsesGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is:  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps:\n  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2}) \n  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha \n  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1) \n Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme.\n The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are \\nu=0.01 \\alpha=0.53 Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. Bibliography [1] The integration of a low order spectral form of the primitive meteorological equations , Robert, A. J., J. Meteor. Soc.\n Japan,vol. 44, pages 237–245, 1966. [2] Frequency filter for time integrations , Asselin, R., Monthly Weather Review, vol. 100, pages 487–490, 1972. [3] The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations , Williams, P.D., Monthly\n Weather Review, vol. 139(6), pages 1996–2007, June 2011. Used By module~~foodie_integrator_leapfrog~~UsedByGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie foodie module~foodie_integrator_leapfrog->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_steps Derived Types leapfrog_integrator Functions is_supported max_steps min_steps Subroutines init integrate Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 2 Maximum number of steps supported. integer(kind=I_P), private, parameter :: min_ss = 2 Minimum number of steps supported. character(len=99), private, parameter :: supported_steps = '2' List of supported steps number. Valid format is 1-2,4,9-23... . Derived Types type, public :: leapfrog_integrator FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: alpha = 0.53_R_P Robert-Asselin-Williams filter coefficient. real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. procedure, public, nopass :: max_steps Return the maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. Functions private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Subroutines private elemental subroutine init (self, nu, alpha) Create the actual leapfrog integrator: initialize the filter coefficient. Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. private subroutine integrate (self, U, previous, Dt, t, filter) Integrate field with leapfrog class scheme. Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:2) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. class( integrand ), intent(inout), optional :: filter Filter field displacement.","tags":"","loc":"module/foodie_integrator_leapfrog.html","title":"foodie_integrator_leapfrog – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_adams_bashforth~~UsesGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_adams_bashforth Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [1, 16] . Note that the scheme using only 1 step reverts\n to Explicit Forward Euler. The formal order of accuracy varies consistently in [1st, 16th] order. Bibliography [1] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr.,\n G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [2] Linear multistep method , wikipedia article . Used By module~~foodie_integrator_adams_bashforth~~UsedByGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulefoodie_integrator_adams_bashforthUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforthUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_steps Derived Types adams_bashforth_integrator Functions is_supported max_steps min_steps Subroutines destroy init integrate update_previous Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 16 Maximum number of steps supported. integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of steps supported. character(len=99), private, parameter :: supported_steps = '1-16' List of supported steps number. Valid format is 1-2,4,9-23... . Derived Types type, public :: adams_bashforth_integrator FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: steps = 0 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. procedure, public, nopass :: max_steps Return the maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. Functions private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. private elemental subroutine init (self, steps) Create the actual Adams-Bashforth integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. private subroutine integrate (self, U, previous, Dt, t, autoupdate) Integrate field with Adams-Bashforth class scheme. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. private subroutine update_previous (self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field.","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – FORESEER"},{"text":"Uses: foodie_kinds module~~foodie_utils~~UsesGraph module~foodie_utils foodie_utils module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE utils: module of (possible) unrelated utilities of FOODIE library. Used By module~~foodie_utils~~UsedByGraph module~foodie_utils foodie_utils module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulefoodie_utilsUsedByGraph = svgPanZoom('#modulefoodie_utilsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions is_admissible Subroutines tokenize Functions public elemental function is_admissible (n, adm_range) Check if the queried number n is admitted by the admissible range list adm_range . Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: n Number queried. character(len=*), intent(in) :: adm_range Admissible range string. Return Value logical Is true is the number is in adm_range . Subroutines private pure subroutine tokenize (string, delimiter, toks, Nt) Tokenize a string in order to parse it. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(string)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I_P), intent(out), optional :: Nt Number of tokens.","tags":"","loc":"module/foodie_utils.html","title":"foodie_utils – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_adams_moulton~~UsesGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_moulton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Moulton class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } +\n b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [0, 15] . Note that the scheme using only 1 step reverts\n to Implciti Backwarad Euler. The formal order of accuracy varies consistently in [1st, 16th] order. Bibliography [1] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr.,\n G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [2] Linear multistep method , wikipedia article . Used By module~~foodie_integrator_adams_moulton~~UsedByGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulefoodie_integrator_adams_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_steps Derived Types adams_moulton_integrator Functions is_supported max_steps min_steps Subroutines destroy init integrate update_previous Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 15 Maximum number of steps supported. integer(kind=I_P), private, parameter :: min_ss = 0 Minimum number of steps supported. character(len=99), private, parameter :: supported_steps = '0-15' List of supported steps number. Valid format is 1-2,4,9-23... . Derived Types type, public :: adams_moulton_integrator FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: b (:) b coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: steps = -1 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. procedure, public, nopass :: max_steps Return the maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. procedure, public, pass(self) :: update_previous Cyclic update previous time steps. Functions private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. private elemental subroutine init (self, steps) Create the actual Adams-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. private subroutine integrate (self, U, previous, Dt, t, iterations, autoupdate) Integrate field with Adams-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations. logical, intent(in), optional :: autoupdate Perform cyclic autoupdate of previous time steps. private subroutine update_previous (self, U, previous) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( adams_moulton_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(in) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field.","tags":"","loc":"module/foodie_integrator_adams_moulton.html","title":"foodie_integrator_adams_moulton – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_low_storage_runge_kutta~~UsesGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the low storage property allowing for an efficient use of the memory.\n Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form: \\begin{matrix}\n K_1 = U&#94;n \\\\\n K_2 = 0 \\\\\n\\left.\\begin{matrix}\n K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\\n K_1 = K_1 + B_s K_2\n\\end{matrix}\\right\\} s=1,2,...N_s\\\\\nU&#94;{n+1} = K_1\n\\end{matrix} where Ns is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table\n form. The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being\n meaningless for a first order scheme. However it is added for safety reason. Stage A B C 1 0 1 0 5 stages, SSP, 4th order This scheme is a low storage RK(5, 4), based on the solution 3 proposed in [2]. Stage A B C 1 0 1432997174477/9575080441755 0 2 -567301805773 /1357537059087 5161836677717/13612068292357 1432997174477/9575080441755 3 -2404267990393/2016746695238 1720146321549/2090206949498 2526269341429/6820363962896 4 -3550918686646/2091501179385 3134564353537/4481467310338 2006345519317/3224310063776 5 -1275806237668/842570457699 2277821191437/14882151754819 2802321613138/2924317926251 6 stages, 4th order This scheme is a low storage RK(6, 4), by [3]. Stage A B C 1 0 0.122000000000 0 2 -0.691750960670 0.477263056358 0.122000000000 3 -1.727127405211 0.381941220320 0.269115878630 4 -0.694890150986 0.447757195744 0.447717183551 5 -1.039942756197 0.498614246822 0.749979795490 6 -1.531977447611 0.186648570846 0.898555413085 7 stages, 4th order This scheme is a low storage RK(7, 4), by [3]. Stage A B C 1 0 0.117322146869 0 2 -0.647900745934 0.503270262127 0.117322146869 3 -2.704760863204 0.233663281658 0.294523230758 4 -0.460080550118 0.283419634625 0.305658622131 5 -0.500581787785 0.540367414023 0.582864148403 6 -1.906532255913 0.371499414620 0.858664273599 7 -1.450000000000 0.136670099385 0.868664273599 12 stages, 4th order This scheme is a low storage RK(12, 4), by [4]. Stage A B C 1 0 0.0650008435125904 0 2 -0.0923311242368072 0.0161459902249842 0.0650008435125904 3 -0.9441056581158819 0.5758627178358159 0.0796560563081853 4 -4.3271273247576394 0.1649758848361671 0.1620416710085376 5 -2.1557771329026072 0.3934619494248182 0.2248877362907778 6 -0.9770727190189062 0.0443509641602719 0.2952293985641261 7 -0.7581835342571139 0.2074504268408778 0.3318332506149405 8 -1.7977525470825499 0.6914247433015102 0.4094724050198658 9 -2.6915667972700770 0.3766646883450449 0.6356954475753369 10 -4.6466798960268143 0.0757190350155483 0.6806551557645497 11 -0.1539613783825189 0.2027862031054088 0.7143773712418350 12 -0.5943293901830616 0.2167029365631842 0.9032588871651854 13 stages, 4th order This scheme is a low storage RK(13, 4), by [4]. Stage A B C 1 0 0.0271990297818803 0 2 -0.6160178650170565 0.1772488819905108 0.0271990297818803 3 -0.4449487060774118 0.0378528418949694 0.0952594339119365 4 -1.0952033345276178 0.6086431830142991 0.1266450286591127 5 -1.2256030785959187 0.2154313974316100 0.1825883045699772 6 -0.2740182222332805 0.2066152563885843 0.3737511439063931 7 -0.0411952089052647 0.0415864076069797 0.5301279418422206 8 -0.1797084899153560 0.0219891884310925 0.5704177433952291 9 -1.1771530652064288 0.9893081222650993 0.5885784947099155 10 -0.4078831463120878 0.0063199019859826 0.6160769826246714 11 -0.8295636426191777 0.3749640721105318 0.6223252334314046 12 -4.7895970584252288 1.6080235151003195 0.6897593128753419 13 -0.6606671432964504 0.0961209123818189 0.9126827615920843 14 stages, 4th order This scheme is a low storage RK(14, 4), by [4]. Stage A B C 1 0 0.0367762454319673 0 2 -0.7188012108672410 0.3136296607553959 0.0367762454319673 3 -0.7785331173421570 0.1531848691869027 0.1249685262725025 4 -0.0053282796654044 0.0030097086818182 0.2446177702277698 5 -0.8552979934029281 0.3326293790646110 0.2476149531070420 6 -3.9564138245774565 0.2440251405350864 0.2969311120382472 7 -1.5780575380587385 0.3718879239592277 0.3978149645802642 8 -2.0837094552574054 0.6204126221582444 0.5270854589440328 9 -0.7483334182761610 0.1524043173028741 0.6981269994175695 10 -0.7032861106563359 0.0760894927419266 0.8190890835352128 11 0.0013917096117681 0.0077604214040978 0.8527059887098624 12 -0.0932075369637460 0.0024647284755382 0.8604711817462826 13 -0.9514200470875948 0.0780348340049386 0.8627060376969976 14 -7.1151571693922548 5.5059777270269628 0.8734213127600976 Bibliography [1] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [2] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112,\n June 1994. [3] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and\n Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [4] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt\n Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. Used By module~~foodie_integrator_low_storage_runge_kutta~~UsedByGraph module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss registers supported_stages Derived Types ls_runge_kutta_integrator Functions is_supported max_stages min_stages used_registers Subroutines destroy init integrate Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 14 Maximum number of stages supported. integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of stages supported. integer(kind=I_P), private, parameter :: registers = 2 Registers used (2N schemes). character(len=99), private, parameter :: supported_stages = '1,5-7,12-14' List of supported stages number. Valid format is 1-2,4,9-23... . Derived Types type, public :: ls_runge_kutta_integrator FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), private, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), private, allocatable :: C (:) Low storage C coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. procedure, public, nopass :: max_stages Return the maximum number of stages supported. procedure, public, nopass :: min_stages Return the minimum number of stages supported. procedure, public, nopass :: used_registers Return the number of registers used. Functions private elemental function is_supported (stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . private pure function max_stages () Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. private pure function min_stages () Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. private pure function used_registers () Return the number of registers used. Arguments None Return Value integer(kind=I_P) Number of registers used. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. private elemental subroutine init (self, stages) Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. private subroutine integrate (self, U, stage, Dt, t) Integrate field with explicit low storage Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:registers) Runge-Kutta registers. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_low_storage_runge_kutta.html","title":"foodie_integrator_low_storage_runge_kutta – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_moulton foodie_integrator_backward_differentiation_formula foodie_integrator_emd_runge_kutta foodie_integrator_euler_explicit foodie_integrator_leapfrog foodie_integrator_low_storage_runge_kutta foodie_integrator_tvd_runge_kutta module~~foodie~~UsesGraph module~foodie foodie module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth var panmodulefoodieUsesGraph = svgPanZoom('#modulefoodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: explicit Adams-Bashforth class of schemes: 1 step, namely the explicit forward Euler scheme, 1st order accurate; 2 steps, 2nd order accurate; 3 steps, 3rd order accurate; 4 steps, 4th order accurate; forward explicit Euler scheme, a 1st order accurate; explicit Leapfrog : Unfiltered, 2nd order accurate, (mostly) unstable; Robert-Asselin filtered, 1st order accurate; Robert-Asselin-Williams filter, 2nd order accurate; explicit low storage Runge-Kutta 2N class schemes: LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; LS(5,4): 5 stages, 4th order accurate; explicit TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order accurate; SSP(3,3): 3 stages, 3rd order accurate; SSP(5,4): 5 stages, 4th order accurate; explicit embedded Runge-Kutta class schemes: DP(7,4): 7 stages, 4th order accurate, Dormand and Prince scheme; implicit Adams-Moulton class of schemes: 0 step, namely the implicit backward Euler scheme, 1st order accurate; 1 step, 2nd order accurate; 2 steps, 3rd order accurate; 3 steps, 4th order accurate; predictor-corrector Adams-Bashforth-Moulton class of schemes: P=AB(1)-C=AM(0) step, namely the explicit/implicit forward/backward Euler scheme, 1st order accurate; P=AB(2)-C=AM(1) step, 2nd order accurate; P=AB(3)-C=AM(2) steps, 3rd order accurate; P=AB(4)-C=AM(3) steps, 4th order accurate; Usage FOODIE schemes must be applied to only subclass extensions of the abstract class integrand . To use FOODIE you must: extend integrand abstract class provided by FOODIE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. ... endtype lorenz use one of the provided FOODIE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By module~~foodie~~UsedByGraph module~foodie foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/foodie.html","title":"foodie – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_utils module~~foodie_integrator_emd_runge_kutta~~UsesGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_emd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 6th order accurate. The integrators provided have the embedded pairs property allowing for automatic step size control.\n The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s \n  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  p is the lower accuracy order scheme and p+1 is the higher one; Ns is the number of stages used and K&#94;s is\n the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the extended Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: Bug Presently, the 2 stages Heun-Euler seems to not work, do not use it . 2 stages, 2th order This scheme is due to Heun-Euler. 0  | 0\n  1  | 1     0\n ----------------\n     | 1/2   1/2\n     | 1      0 6 stages, 5th order This scheme is due to Cash and Karp, see [3]. 0    | 0\n  1/5    | 1/5\n  3/10 | 3/40            9/40\n  3/5    | 3/10          -9/10        6/5\n  1    | -11/54        5/2          -70/27      35/27\n  7/8    | 1631/55296    175/512      575/13824   44275/110592     253/4096     0\n ----------------------------------------------------------------------------------------\n       | 37/378        0           250/621      125/594          0            512/1771\n       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 7 stages, 4th order This scheme is due to Dormand and Prince, see [1]. 0    | 0\n  1/5  | 1/5\n  3/10 | 3/40          9/40\n  4/5  | 44/45        -56/15        32/9\n  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729\n  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656\n  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0\n --------------------------------------------------------------------------------------------\n       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40\n       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 9 stages, 6th order This scheme is due to Calvo et al., see [2]. 0                 | 0\n  2/15              | 2/15\n  1/5               | 1/20                  3/20\n  3/10              | 3/40                  0                      9/40\n  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441\n  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461\n  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831\n  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713\n  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n --------------------------------------------------------------------------------------------------------------\n                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738\n ...continued...\n  0                 |\n  2/15              |\n  1/5               |\n  3/10              |\n  14/25             |\n  19/25             | 73139862/60170633\n  35226607/35688279 | -90453121/33722162     111179552/157155827\n  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625\n  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n -----------------------------------------------------------------------------------------------------------------------\n                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 17 stages, 10th order This scheme is due to Feagin, see [4]. 0                        |  0\n  0.1                      |  0.1\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052\n  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974\n  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068\n  0.981074190219795268254  |  0.087900734020668133731  0                        0\n  0.833333333333333333333  |  0.085970050490246030218  0                        0\n  0.354017365856802376329  |  0.120930449125333720660  0                        0\n  0.882527661964732346425  |  0.110854379580391483508  0                        0\n  0.642615758240322548157  |  0.112054414752879004829  0                        0\n  0.357384241759677451842  |  0.113976783964185986138  0                        0\n  0.117472338035267653574  |  0.079831452828019604635  0                        0\n  0.833333333333333333333  |  0.985115610164857280120  0                        0\n  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0\n  0.1                      |  0.1                      0                       -0.157178665799771163367\n  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942\n ------------------------------------------------------------------------------------------------------\n                           |  0.033333333333333333333  0.025                    0.033333333333333333333\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  | -0.072954784731363262918\n  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678\n  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015\n  0.882527661964732346425  |  0                        0                       -0.060576148825500558762\n  0.642615758240322548157  |  0                        0                       -0.144942775902865915672\n  0.357384241759677451842  |  0                        0                       -0.076881336420335693858\n  0.117472338035267653574  |  0                        0                       -0.052032968680060307651\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821\n  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739\n  0.539357840802981787532  |  0                       -0.777333643644968233538  0\n  0.1                      |  0                        0                        0\n  1                        |  0                        0.259111214548322744512 -0.358278966717952089048\n ------------------------------------------------------------------------------------------------------\n                           |  0                        0.05                     0\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  | -0.059578021181736100156\n  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577\n  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236\n  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555\n  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727\n  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904\n  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653\n  0.539357840802981787532  | -0.091089566215517606959  0                        0\n  0.1                      |  0                        0                        0\n  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461\n ------------------------------------------------------------------------------------------------------\n                           |  0.04                     0                        0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  | -0.327769124164018874147\n  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184\n  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539\n  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220\n  0.539357840802981787532  |  0                        0                        0\n  0.1                      |  0                        0                        0\n  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169\n ------------------------------------------------------------------------------------------------------\n                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  | -0.024403640575012745213\n  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538\n  0.1                      |  0                        0                        0.157178665799771163367\n  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675\n -------------------------------------------------------------------------------------------------------------\n                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  |\n  0.539357840802981787532  |\n  0.1                      |\n  1                        |\n ---------------------------------------------------\n                           | 0.033333333333333333333 Bibliography [1] A family of embedded Runge-Kutta formulae , Dormand, J. R., Prince, P. J. (1980), Journal of Computational and\n Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [2] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics\n with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [3] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash,\n A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [4] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific\n Computing. 2007. Used By module~~foodie_integrator_emd_runge_kutta~~UsedByGraph module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie foodie module~foodie_integrator_emd_runge_kutta->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_stages Derived Types emd_runge_kutta_integrator Functions is_supported max_stages min_stages Subroutines destroy init integrate new_Dt Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 17 Maximum number of stages supported. integer(kind=I_P), private, parameter :: min_ss = 6 Minimum number of stages supported. character(len=99), private, parameter :: supported_stages = '6,7,9,17' List of supported stages number. Valid format is 1-2,4,9-23... . Derived Types type, public :: emd_runge_kutta_integrator FOODIE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:,:) \\beta Butcher's coefficients. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. real(kind=R_P), private :: pp1_inv = 0._R_P 1/(p+1) where p is the accuracy order of the lower accurate scheme of the pair. integer(kind=I_P), private :: stages = 0 Number of stages. real(kind=R_P), private :: tolerance = 0._R_P Tolerance on the local truncation error. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of stages is supported or not. procedure, public, nopass :: max_stages Return the maximum number of stages supported. procedure, public, nopass :: min_stages Return the minimum number of stages supported. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. Functions private elemental function is_supported (stages) Check if the queried number of stages is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value logical Is true is the stages number is in supported_stages . private pure function max_stages () Return the maximum number of stages supported. Arguments None Return Value integer(kind=I_P) Maximum number of stages supported. private pure function min_stages () Return the minimum number of stages supported. Arguments None Return Value integer(kind=I_P) Minimum number of stages supported. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self Integrator. private elemental subroutine init (self, stages, tolerance) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). private subroutine integrate (self, U, stage, Dt, t) Integrate field with explicit embedded Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(inout) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private elemental subroutine new_Dt (self, error, Dt) Compute new estimation of the time step Dt. Arguments Type Intent Optional Attributes Name class( emd_runge_kutta_integrator ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step.","tags":"","loc":"module/foodie_integrator_emd_runge_kutta.html","title":"foodie_integrator_emd_runge_kutta – FORESEER"},{"text":"Uses: foodie_adt_integrand foodie_kinds foodie_integrator_adams_bashforth foodie_integrator_adams_moulton foodie_utils module~~foodie_integrator_adams_bashforth_moulton~~UsesGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_adt_integrand foodie_adt_integrand module~foodie_kinds->module~foodie_adt_integrand module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton var panmodulefoodie_integrator_adams_bashforth_moultonUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: predictor  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  corrector  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps\nconsidered for the corrector. Note The value of \\Delta t must be provided, it not being computed by the integrator. The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of steps used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1\n should hold. Currently, the following schemes are available: P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order.\n The b coefficient is:\n b&#94;p = \\left[b_1\\right] = \\left[1\\right]\n b&#94;c = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n}) \n  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  P=AB(2)-C=AM(1) steps This scheme is 2nd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  P=AB(3)-C=AM(2) steps This scheme is 3rd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  P=AB(4)-C=AM(3) steps This scheme is 4th order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right] \n  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3})\n -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth_moulton~~UsedByGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foreseer_euler_1d foreseer_euler_1d module~foodie->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foodie->program~foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables max_ss min_ss supported_steps Derived Types adams_bashforth_moulton_integrator Functions is_supported max_steps min_steps Subroutines destroy init integrate Variables Type Visibility Attributes Name Initial integer(kind=I_P), private, parameter :: max_ss = 16 Maximum number of steps supported. integer(kind=I_P), private, parameter :: min_ss = 1 Minimum number of steps supported. character(len=99), private, parameter :: supported_steps = '1-16' List of supported steps number. Valid format is 1-2,4,9-23... . Derived Types type, public :: adams_bashforth_moulton_integrator FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Components Type Visibility Attributes Name Initial type( adams_moulton_integrator ), private :: corrector Corrector solver. integer(kind=I_P), private :: error = 0 Error status flag: trap occurrences of errors. type( adams_bashforth_integrator ), private :: predictor Predictor solver. integer(kind=I_P), private :: steps = -1 Number of time steps. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, nopass :: is_supported Check if the queried number of steps is supported or not. procedure, public, nopass :: max_steps Return the maximum number of steps supported. procedure, public, nopass :: min_steps Return the minimum number of steps supported. Functions private elemental function is_supported (steps) Check if the queried number of steps is supported or not. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: steps Number of time steps used. Return Value logical Is true is the steps number is in supported_steps . private pure function max_steps () Return the maximum number of steps supported. Arguments None Return Value integer(kind=I_P) Maximum number of steps supported. private pure function min_steps () Return the minimum number of steps supported. Arguments None Return Value integer(kind=I_P) Minimum number of steps supported. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. private elemental subroutine init (self, steps) Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(inout) :: self ABM integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. private subroutine integrate (self, U, previous, Dt, t, iterations) Integrate field with Adams-Bashforth-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( adams_bashforth_moulton_integrator ), intent(in) :: self Actual ABM integrator. class( integrand ), intent(inout) :: U Field to be integrated. class( integrand ), intent(inout) :: previous (1:) Previous time steps solutions of integrand field. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. integer(kind=I_P), intent(in), optional :: iterations Fixed point iterations of AM scheme.","tags":"","loc":"module/foodie_integrator_adams_bashforth_moulton.html","title":"foodie_integrator_adams_bashforth_moulton – FORESEER"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf penf module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~penf->program~foreseer_test_conservative_compressible module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~foreseer_euler_1d foreseer_euler_1d module~penf->module~foreseer_euler_1d module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~penf->program~foreseer_test_riemann_solver_compressible_pvl module~wenoof_interpolator_js wenoof_interpolator_js module~penf->module~wenoof_interpolator_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js program~foreseer_test_shock_tube foreseer_test_shock_tube module~penf->program~foreseer_test_shock_tube module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof wenoof module~penf->module~wenoof program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~penf->program~foreseer_test_riemann_solver_compressible_llf module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~penf->program~foreseer_test_eos_compressible module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~penf_stringify->module~penf module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer foreseer module~foreseer_riemann_solver_object->module~foreseer module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_factory->module~wenoof_objects_factory module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap flap module~flap_command_line_argument_t->module~flap module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_objects_factory->module~wenoof module~flap_command_line_interface_t->module~flap module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof->module~foreseer_euler_1d module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_z module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_kappa_factory module~flap_utils_m->module~flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~foreseer->program~foreseer_test_conservative_compressible module~foreseer->module~foreseer_euler_1d module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_shock_tube module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_eos_compressible module~flap->program~foreseer_test_shock_tube var panmodulepenf_b_sizeUsedByGraph = svgPanZoom('#modulepenf_b_sizeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size byte_size Functions bit_size_R16P bit_size_R4P bit_size_R8P bit_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P byte_size_chr Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Functions private elemental function bit_size_R16P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R16P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – FORESEER"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Portability Environment for Fortran poor people. Used By module~~penf~~UsedByGraph module~penf penf module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~penf->program~foreseer_test_conservative_compressible module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~foreseer_euler_1d foreseer_euler_1d module~penf->module~foreseer_euler_1d module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~penf->program~foreseer_test_riemann_solver_compressible_pvl module~wenoof_interpolator_js wenoof_interpolator_js module~penf->module~wenoof_interpolator_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js program~foreseer_test_shock_tube foreseer_test_shock_tube module~penf->program~foreseer_test_shock_tube module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof wenoof module~penf->module~wenoof program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~penf->program~foreseer_test_riemann_solver_compressible_llf module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~penf->program~foreseer_test_eos_compressible module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer foreseer module~foreseer_riemann_solver_object->module~foreseer module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_factory->module~wenoof_objects_factory module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap flap module~flap_command_line_argument_t->module~flap module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_objects_factory->module~wenoof module~flap_command_line_interface_t->module~flap module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof->module~foreseer_euler_1d module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_z module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_kappa_factory module~flap_utils_m->module~flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~foreseer->program~foreseer_test_conservative_compressible module~foreseer->module~foreseer_euler_1d module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_shock_tube module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_eos_compressible module~flap->program~foreseer_test_shock_tube var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size digit Functions digit_I1 digit_I2 digit_I4 digit_I8 Subroutines check_endian penf_init penf_print Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Functions private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Subroutines public subroutine check_endian () Check the type of bit ordering (big or little endian) of the running architecture. Arguments None public subroutine penf_init () Initialize PENF's variables that are not initialized into the definition specification. Arguments None public subroutine penf_print (unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message.","tags":"","loc":"module/penf.html","title":"penf – FORESEER"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_b_size->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~penf->program~foreseer_test_conservative_compressible module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~foreseer_euler_1d foreseer_euler_1d module~penf->module~foreseer_euler_1d module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~penf->program~foreseer_test_riemann_solver_compressible_pvl module~wenoof_interpolator_js wenoof_interpolator_js module~penf->module~wenoof_interpolator_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js program~foreseer_test_shock_tube foreseer_test_shock_tube module~penf->program~foreseer_test_shock_tube module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof wenoof module~penf->module~wenoof program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~penf->program~foreseer_test_riemann_solver_compressible_llf module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~penf->program~foreseer_test_eos_compressible module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer foreseer module~foreseer_riemann_solver_object->module~foreseer module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_factory->module~wenoof_objects_factory module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap flap module~flap_command_line_argument_t->module~flap module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_objects_factory->module~wenoof module~flap_command_line_interface_t->module~flap module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof->module~foreseer_euler_1d module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_z module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_kappa_factory module~flap_utils_m->module~flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~foreseer->program~foreseer_test_conservative_compressible module~foreseer->module~foreseer_euler_1d module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_shock_tube module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_eos_compressible module~flap->program~foreseer_test_shock_tube var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bcton bstr cton str strz Functions bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bctor_R16P bctor_R4P bctor_R8P bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P ctor_R16P ctor_R4P ctor_R8P str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz_I1P strz_I2P strz_I4P strz_I8P Subroutines compact_real_string Interfaces public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Functions private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctor_R16P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R16P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctor_R16P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function str_R16P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R16P (n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function strf_R16P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Subroutines private pure subroutine compact_real_string (string) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – FORESEER"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf penf module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~penf->program~foreseer_test_conservative_compressible module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~foreseer_euler_1d foreseer_euler_1d module~penf->module~foreseer_euler_1d module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~penf->program~foreseer_test_riemann_solver_compressible_pvl module~wenoof_interpolator_js wenoof_interpolator_js module~penf->module~wenoof_interpolator_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js program~foreseer_test_shock_tube foreseer_test_shock_tube module~penf->program~foreseer_test_shock_tube module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof wenoof module~penf->module~wenoof program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~penf->program~foreseer_test_riemann_solver_compressible_llf module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~penf->program~foreseer_test_eos_compressible module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer foreseer module~foreseer_riemann_solver_object->module~foreseer module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_factory->module~wenoof_objects_factory module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap flap module~flap_command_line_argument_t->module~flap module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_objects_factory->module~wenoof module~flap_command_line_interface_t->module~flap module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof->module~foreseer_euler_1d module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_z module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_kappa_factory module~flap_utils_m->module~flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~foreseer->program~foreseer_test_conservative_compressible module~foreseer->module~foreseer_euler_1d module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_shock_tube module~foreseer->program~foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_eos_compressible module~flap->program~foreseer_test_shock_tube var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables BII1P BII2P BII4P BII8P BII_P BIR16P BIR4P BIR8P BIR_P BYI1P BYI2P BYI4P BYI8P BYI_P BYR16P BYR4P BYR8P BYR_P DI1P DI2P DI4P DI8P DI_P DR16P DR4P DR8P DR_P FI1P FI1PZP FI2P FI2PZP FI4P FI4PZP FI8P FI8PZP FI_P FI_PZP FR16P FR4P FR8P FR_P I1P I2P I4P I8P INTEGER_FORMATS_LIST INTEGER_KINDS_LIST I_P MaxI1P MaxI2P MaxI4P MaxI8P MaxI_P MaxR16P MaxR4P MaxR8P MaxR_P MinI1P MinI2P MinI4P MinI8P MinI_P MinR16P MinR4P MinR8P MinR_P R16P R4P R8P REAL_FORMATS_LIST REAL_KINDS_LIST R_P Zero ZeroR16 ZeroR4 ZeroR8 endian endianB endianL is_initialized smallR16P smallR4P smallR8P smallR_P Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. integer, public, parameter :: I_P = I4P Default integer precision. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. integer, public, parameter :: R_P = R8P Default real precision. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: endianB = 0 Big endian parameter. integer, public, parameter :: endianL = 1 Little endian parameter. logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – FORESEER"},{"text":"Uses: penf wenoof_interpolator_object wenoof_objects_factory module~~wenoof~~UsesGraph module~wenoof wenoof module~penf penf module~penf->module~wenoof module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_reconstructor_js->module~wenoof_interpolator_factory var panmodulewenoofUsesGraph = svgPanZoom('#modulewenoofUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. WenOOF, WENO interpolation Object Oriented Fortran library Used By module~~wenoof~~UsedByGraph module~wenoof wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Subroutines wenoof_create Subroutines public subroutine wenoof_create (interpolator_type, S, interpolator, face_left, face_right, eps) WenOOF creator, create a concrete WENO interpolator object. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencil dimension. class( interpolator_object ), intent(out), allocatable :: interpolator The concrete WENO interpolator. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero-div.","tags":"","loc":"module/wenoof.html","title":"wenoof – FORESEER"},{"text":"Uses: penf wenoof_base_object module~~wenoof_interpolations_object~~UsesGraph module~wenoof_interpolations_object wenoof_interpolations_object module~penf penf module~penf->module~wenoof_interpolations_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_base_object->module~wenoof_interpolations_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_interpolations_objectUsesGraph = svgPanZoom('#modulewenoof_interpolations_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract interpolations object. Used By module~~wenoof_interpolations_object~~UsedByGraph module~wenoof_interpolations_object wenoof_interpolations_object module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_interpolator_object wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_js wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulewenoof_interpolations_objectUsedByGraph = svgPanZoom('#modulewenoof_interpolations_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_interface Derived Types interpolations_object interpolations_object_constructor Abstract Interfaces abstract interface Abstract interfaces of interpolations_object . private pure subroutine compute_interface (self, stencil) Compute interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_object ), intent(inout) :: self Interpolations. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Derived Types type, public, abstract, extends( base_object ) :: interpolations_object Abstract interpolations object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Stencil interpolations values [1:2,0:S-1]. Type-Bound Procedures procedure(compute_interface), public, pass(self) :: compute Compute beta. procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, abstract, extends( base_object_constructor ) :: interpolations_object_constructor Abstract interpolations object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor","tags":"","loc":"module/wenoof_interpolations_object.html","title":"wenoof_interpolations_object – FORESEER"},{"text":"Uses: penf wenoof_base_object wenoof_interpolations_object wenoof_weights_object module~~wenoof_interpolator_object~~UsesGraph module~wenoof_interpolator_object wenoof_interpolator_object module~penf penf module~penf->module~wenoof_interpolator_object module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_interpolations_object->module~wenoof_interpolator_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_interpolator_objectUsesGraph = svgPanZoom('#modulewenoof_interpolator_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract interpolator object. Used By module~~wenoof_interpolator_object~~UsedByGraph module~wenoof_interpolator_object wenoof_interpolator_object module~wenoof wenoof module~wenoof_interpolator_object->module~wenoof module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_js wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulewenoof_interpolator_objectUsedByGraph = svgPanZoom('#modulewenoof_interpolator_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces interpolate_debug_interface interpolate_standard_interface Derived Types interpolator_object interpolator_object_constructor Abstract Interfaces abstract interface Abstract interfaces of interpolator_object . private pure subroutine interpolate_debug_interface (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( interpolator_object ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. abstract interface Abstract interfaces of interpolator_object . private pure subroutine interpolate_standard_interface (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( interpolator_object ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. Derived Types type, public, abstract, extends( base_object ) :: interpolator_object Abstract interpolator object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( interpolations_object ), public, allocatable :: interpolations Stencil interpolations. class( weights_object ), public, allocatable :: weights Weights of interpolations. Type-Bound Procedures procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. generic, public :: interpolate => interpolate_standard, interpolate_debug Interpolate values. procedure(interpolate_debug_interface), public, pass(self) :: interpolate_debug Interpolate values, debug mode. procedure(interpolate_standard_interface), public, pass(self) :: interpolate_standard Interpolate values, standard mode. type, public, abstract, extends( base_object_constructor ) :: interpolator_object_constructor Abstract interpolator object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( interpolations_object_constructor ), public, allocatable :: interpolations_constructor Stencil interpolations constructor. class( weights_object_constructor ), public, allocatable :: weights_constructor Weights of interpolations constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor","tags":"","loc":"module/wenoof_interpolator_object.html","title":"wenoof_interpolator_object – FORESEER"},{"text":"Uses: penf wenoof_base_object module~~wenoof_beta_object~~UsesGraph module~wenoof_beta_object wenoof_beta_object module~penf penf module~penf->module~wenoof_beta_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_base_object->module~wenoof_beta_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_beta_objectUsesGraph = svgPanZoom('#modulewenoof_beta_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. Used By module~~wenoof_beta_object~~UsedByGraph module~wenoof_beta_object wenoof_beta_object module~wenoof_objects_factory wenoof_objects_factory module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_alpha_object wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_weights_js wenoof_weights_js module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_weights_factory wenoof_weights_factory module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_factory wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_rec_js wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_beta_objectUsedByGraph = svgPanZoom('#modulewenoof_beta_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_interface Derived Types beta_object beta_object_constructor Abstract Interfaces abstract interface Abstract interfaces of beta_object . private pure subroutine compute_interface (self, stencil) Compute beta. Arguments Type Intent Optional Attributes Name class( beta_object ), intent(inout) :: self Beta. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. Derived Types type, public, abstract, extends( base_object ) :: beta_object Abstract Beta coefficients (smoothness indicators of stencil interpolations) object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Beta values [1:2,0:S-1]. Type-Bound Procedures procedure(compute_interface), public, pass(self) :: compute Compute beta. procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, abstract, extends( base_object_constructor ) :: beta_object_constructor Abstract Beta coefficients object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor","tags":"","loc":"module/wenoof_beta_object.html","title":"wenoof_beta_object – FORESEER"},{"text":"Uses: penf wenoof_base_object module~~wenoof_weights_object~~UsesGraph module~wenoof_weights_object wenoof_weights_object module~penf penf module~penf->module~wenoof_weights_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_base_object->module~wenoof_weights_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_weights_objectUsesGraph = svgPanZoom('#modulewenoof_weights_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract weights object. Used By module~~wenoof_weights_object~~UsedByGraph module~wenoof_weights_object wenoof_weights_object module~wenoof_objects_factory wenoof_objects_factory module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_interpolator_object wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_js wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_js module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulewenoof_weights_objectUsedByGraph = svgPanZoom('#modulewenoof_weights_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_interface smoothness_indicators_interface Derived Types weights_object weights_object_constructor Abstract Interfaces abstract interface Abstract interfaces of weights_object . private pure subroutine compute_interface (self, stencil) Compute beta. Arguments Type Intent Optional Attributes Name class( weights_object ), intent(inout) :: self Weights. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. abstract interface Abstract interfaces of weights_object . private pure function smoothness_indicators_interface (self) result(si) Return smoothness indicators. Arguments Type Intent Optional Attributes Name class( weights_object ), intent(in) :: self Weights. Return Value real(kind=RPP),\n  allocatable, (:,:) Smoothness indicators. Derived Types type, public, abstract, extends( base_object ) :: weights_object Weights of stencil interpolations object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Weights values of stencil interpolations [1:2,0:S-1]. Type-Bound Procedures procedure(compute_interface), public, pass(self) :: compute Compute weights. procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. procedure(smoothness_indicators_interface), public, pass(self) :: smoothness_indicators Return smoothness indicators. type, public, extends( base_object_constructor ) :: weights_object_constructor Abstract weights object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor","tags":"","loc":"module/wenoof_weights_object.html","title":"wenoof_weights_object – FORESEER"},{"text":"Uses: penf wenoof_base_object wenoof_beta_object wenoof_kappa_object module~~wenoof_alpha_object~~UsesGraph module~wenoof_alpha_object wenoof_alpha_object module~penf penf module~penf->module~wenoof_alpha_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_alpha_objectUsesGraph = svgPanZoom('#modulewenoof_alpha_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract alpha (non linear weights) object. Used By module~~wenoof_alpha_object~~UsedByGraph module~wenoof_alpha_object wenoof_alpha_object module~wenoof_objects_factory wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_weights_js wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_weights_factory wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_alpha_objectUsedByGraph = svgPanZoom('#modulewenoof_alpha_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_interface Derived Types alpha_object alpha_object_constructor Abstract Interfaces abstract interface Abstract interfaces of alpha_object . private pure subroutine compute_interface (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_object ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. Derived Types type, public, abstract, extends( base_object ) :: alpha_object Abstract alpha (non linear weights) object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure(compute_interface), public, pass(self) :: compute Compute alpha. procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, abstract, extends( base_object_constructor ) :: alpha_object_constructor Abstract alpha (non linear weights) object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor","tags":"","loc":"module/wenoof_alpha_object.html","title":"wenoof_alpha_object – FORESEER"},{"text":"Uses: penf module~~wenoof_base_object~~UsesGraph module~wenoof_base_object wenoof_base_object module~penf penf module~penf->module~wenoof_base_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_base_objectUsesGraph = svgPanZoom('#modulewenoof_base_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract base object, the ancestor of all. Define a minimal, base, object that is used as ancestor of all objects, e.g. smoothness indicator, optimal weights, etc… Used By module~~wenoof_base_object~~UsedByGraph module~wenoof_base_object wenoof_base_object module~wenoof_weights_js wenoof_weights_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_weights_object wenoof_weights_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_alpha_object wenoof_alpha_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_interpolator_object wenoof_interpolator_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object wenoof_interpolations_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_beta_object wenoof_beta_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_beta_rec_js wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object wenoof_kappa_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof wenoof module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_js wenoof_interpolator_js module~wenoof_interpolator_object->module~wenoof_interpolator_js module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_factory wenoof_kappa_factory module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_factory wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_objects_factory->module~wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_factory->module~wenoof_objects_factory var panmodulewenoof_base_objectUsedByGraph = svgPanZoom('#modulewenoof_base_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables EPS_DEF Abstract Interfaces create_interface description_interface destroy_interface Derived Types base_object base_object_constructor Subroutines create_ create_base_object_constructor destroy_ Variables Type Visibility Attributes Name Initial real(kind=RPP), private, parameter :: EPS_DEF = 10._RPP**(-6) Small epsilon to avoid division by zero, default value. Abstract Interfaces abstract interface Abstract interfaces of base_object . private subroutine create_interface (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. abstract interface Abstract interfaces of base_object . private pure function description_interface (self) result(string) Return object string-description. Arguments Type Intent Optional Attributes Name class( base_object ), intent(in) :: self Object. Return Value character(len=:),\n  allocatable String-description. abstract interface Abstract interfaces of base_object . private elemental subroutine destroy_interface (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. Derived Types type, public, abstract :: base_object Abstract base object, the ancestor of all. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. Type-Bound Procedures procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, abstract :: base_object_constructor Abstract base object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Subroutines private subroutine create_ (self, constructor) Create object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object. class( base_object_constructor ), intent(in) :: constructor Object constructor. private subroutine create_base_object_constructor (self, S, face_left, face_right, eps) Create alpha constructor. Arguments Type Intent Optional Attributes Name class( base_object_constructor ), intent(inout) :: self Constructor. integer(kind=I_P), intent(in) :: S Stencils dimension. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid division by zero. private elemental subroutine destroy_ (self) Destroy object. Arguments Type Intent Optional Attributes Name class( base_object ), intent(inout) :: self Object.","tags":"","loc":"module/wenoof_base_object.html","title":"wenoof_base_object – FORESEER"},{"text":"Uses: penf wenoof_base_object module~~wenoof_kappa_object~~UsesGraph module~wenoof_kappa_object wenoof_kappa_object module~penf penf module~penf->module~wenoof_kappa_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_base_object->module~wenoof_kappa_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_kappa_objectUsesGraph = svgPanZoom('#modulewenoof_kappa_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Kappa (optimal, linear weights of stencil interpolations) object. Used By module~~wenoof_kappa_object~~UsedByGraph module~wenoof_kappa_object wenoof_kappa_object module~wenoof_objects_factory wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_alpha_object wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_weights_js wenoof_weights_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_factory wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_weights_factory wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_kappa_objectUsedByGraph = svgPanZoom('#modulewenoof_kappa_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_interface Derived Types kappa_object kappa_object_constructor Abstract Interfaces abstract interface Abstract interfaces of kappa_object . private pure subroutine compute_interface (self) Compute kappa. Arguments Type Intent Optional Attributes Name class( kappa_object ), intent(inout) :: self Kappa. Derived Types type, public, abstract, extends( base_object ) :: kappa_object Kappa (optimal, linear weights of stencil interpolations) object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Kappa coefficients values [1:2,0:S-1]. Type-Bound Procedures procedure(compute_interface), public, pass(self) :: compute Compute kappa. procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure(description_interface), public, pass(self) :: description Return object string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, abstract, extends( base_object_constructor ) :: kappa_object_constructor Abstract kappa object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor","tags":"","loc":"module/wenoof_kappa_object.html","title":"wenoof_kappa_object – FORESEER"},{"text":"Uses: penf wenoof_base_object wenoof_beta_object module~~wenoof_beta_rec_js~~UsesGraph module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf penf module~penf->module~wenoof_beta_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_beta_object module~wenoof_beta_object->module~wenoof_beta_rec_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_beta_rec_jsUsesGraph = svgPanZoom('#modulewenoof_beta_rec_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. Note The provided beta object implements the smoothness indicators defined in Efficient Implementation\n of Weighted ENO Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Used By module~~wenoof_beta_rec_js~~UsedByGraph module~wenoof_beta_rec_js wenoof_beta_rec_js module~wenoof_beta_factory wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_objects_factory wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_beta_rec_jsUsedByGraph = svgPanZoom('#modulewenoof_beta_rec_jsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types beta_rec_js beta_rec_js_constructor Functions description Subroutines compute create destroy Derived Types type, public, extends( beta_object ) :: beta_rec_js Jiang-Shu and Gerolymos-Senechal-Vallet Beta coefficients (smoothness indicators of stencil interpolations) object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), private, allocatable :: coef (:,:,:) Beta coefficients [1:2,0:S-1,0:S-1]. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Beta values [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute beta. procedure, public, pass(self) :: create Create beta. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return beta string-description. procedure, public, pass(self) :: destroy Destroy beta. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, extends( beta_object_constructor ) :: beta_rec_js_constructor Jiang-Shu and Gerolymos-Senechal-Vallet beta object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return beta string-description. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(in) :: self Beta. Return Value character(len=:),\n  allocatable String-description. Subroutines private pure subroutine compute (self, stencil) Compute beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. private subroutine create (self, constructor) Create beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta. class( base_object_constructor ), intent(in) :: constructor Beta constructor. private elemental subroutine destroy (self) Destroy beta. Arguments Type Intent Optional Attributes Name class( beta_rec_js ), intent(inout) :: self Beta.","tags":"","loc":"module/wenoof_beta_rec_js.html","title":"wenoof_beta_rec_js – FORESEER"},{"text":"Uses: iso_fortran_env penf wenoof_base_object wenoof_interpolations_factory wenoof_interpolations_object wenoof_interpolator_object wenoof_weights_factory wenoof_weights_object module~~wenoof_reconstructor_js~~UsesGraph module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_weights_object wenoof_weights_object module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_interpolator_object wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_js iso_fortran_env iso_fortran_env iso_fortran_env->module~wenoof_reconstructor_js module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolations_object wenoof_interpolations_object module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~penf penf module~penf->module~wenoof_reconstructor_js module~penf->module~wenoof_interpolations_factory module~penf->module~wenoof_weights_object module~penf->module~wenoof_interpolator_object module~penf->module~wenoof_interpolations_object module~penf->module~wenoof_weights_factory module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~penf->module~wenoof_interpolations_rec_js module~penf->module~wenoof_weights_js module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmodulewenoof_reconstructor_jsUsesGraph = svgPanZoom('#modulewenoof_reconstructor_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu (upwind) reconstructor object. Used By module~~wenoof_reconstructor_js~~UsedByGraph module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulewenoof_reconstructor_jsUsedByGraph = svgPanZoom('#modulewenoof_reconstructor_jsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types reconstructor_js reconstructor_js_constructor Functions description Subroutines create destroy interpolate_debug interpolate_standard Derived Types type, public, extends( interpolator_object ) :: reconstructor_js Jiang-Shu (upwind) reconstructor object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( interpolations_object ), public, allocatable :: interpolations Stencil interpolations. class( weights_object ), public, allocatable :: weights Weights of interpolations. Type-Bound Procedures procedure, public, pass(self) :: create Create reconstructor. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return reconstructor string-description. procedure, public, pass(self) :: destroy Destroy reconstructor. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. generic, public :: interpolate => interpolate_standard, interpolate_debug Interpolate values. procedure, public, pass(self) :: interpolate_debug Interpolate values (providing also debug values). procedure, public, pass(self) :: interpolate_standard Interpolate values (without providing debug values). type, public, extends( interpolator_object_constructor ) :: reconstructor_js_constructor Jiang-Shu (upwind) reconstructor object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( interpolations_object_constructor ), public, allocatable :: interpolations_constructor Stencil interpolations constructor. class( weights_object_constructor ), public, allocatable :: weights_constructor Weights of interpolations constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return reconstructor string-descripition. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(in) :: self Reconstructor. Return Value character(len=:),\n  allocatable String-description. Subroutines private subroutine create (self, constructor) Create interpolator. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Interpolator. class( base_object_constructor ), intent(in) :: constructor Constructor. private elemental subroutine destroy (self) Destroy reconstructor. Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( reconstructor_js ), intent(inout) :: self Reconstructor. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2].","tags":"","loc":"module/wenoof_reconstructor_js.html","title":"wenoof_reconstructor_js – FORESEER"},{"text":"Uses: penf wenoof_alpha_object wenoof_base_object wenoof_beta_object wenoof_kappa_object module~~wenoof_alpha_rec_js~~UsesGraph module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_beta_object wenoof_beta_object module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_object module~penf penf module~penf->module~wenoof_alpha_rec_js module~penf->module~wenoof_beta_object module~penf->module~wenoof_alpha_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_kappa_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_alpha_rec_jsUsesGraph = svgPanZoom('#modulewenoof_alpha_rec_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu alpha (non linear weights) object. Note The provided alpha implements the alpha coefficients defined in Efficient Implementation of Weighted ENO\n Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130. Used By module~~wenoof_alpha_rec_js~~UsedByGraph module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_weights_js wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_objects_factory wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_alpha_rec_jsUsedByGraph = svgPanZoom('#modulewenoof_alpha_rec_jsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types alpha_rec_js alpha_rec_js_constructor Functions description Subroutines compute create destroy Derived Types type, public, extends( alpha_object ) :: alpha_rec_js Jiang-Shu alpha object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute alpha. procedure, public, pass(self) :: create Create alpha. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return alpha string-description. procedure, public, pass(self) :: destroy Destroy alpha. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, extends( alpha_object_constructor ) :: alpha_rec_js_constructor Jiang-Shu alpha object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(in) :: self Alpha coefficient. Return Value character(len=:),\n  allocatable String-description. Subroutines private pure subroutine compute (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha coefficient. class( beta_object ), intent(in) :: beta Beta coefficients. class( kappa_object ), intent(in) :: kappa Kappa coefficients. private subroutine create (self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. private elemental subroutine destroy (self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_js ), intent(inout) :: self Alpha.","tags":"","loc":"module/wenoof_alpha_rec_js.html","title":"wenoof_alpha_rec_js – FORESEER"},{"text":"Uses: penf wenoof_base_object wenoof_kappa_object module~~wenoof_kappa_rec_js~~UsesGraph module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf penf module~penf->module~wenoof_kappa_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_kappa_rec_jsUsesGraph = svgPanZoom('#modulewenoof_kappa_rec_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu and Gerolymos-Senechal-Vallet kappa coefficients for reconstruction. Note The provided WENO kappa implements the linear weights defined in Efficient Implementation of Weighted ENO\n Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Used By module~~wenoof_kappa_rec_js~~UsedByGraph module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~wenoof_kappa_factory wenoof_kappa_factory module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_objects_factory wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_kappa_rec_jsUsedByGraph = svgPanZoom('#modulewenoof_kappa_rec_jsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types kappa_rec_js kappa_rec_js_constructor Functions description Subroutines compute create destroy Derived Types type, public, extends( kappa_object ) :: kappa_rec_js Jiang-Shu and Gerolymos-Senechal-Vallet kappa object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Kappa coefficients values [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute kappa. procedure, public, pass(self) :: create Create kappa. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return kappa string-description. procedure, public, pass(self) :: destroy Destroy kappa. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, extends( kappa_object_constructor ) :: kappa_rec_js_constructor Jiang-Shu and Gerolymos-Senechal-Vallet optimal kappa object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return string-description of kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(in) :: self Kappa. Return Value character(len=:),\n  allocatable String-description. Subroutines private pure subroutine compute (self) Compute kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. private subroutine create (self, constructor) Create kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa. class( base_object_constructor ), intent(in) :: constructor Kappa constructor. private elemental subroutine destroy (self) Destroy kappa. Arguments Type Intent Optional Attributes Name class( kappa_rec_js ), intent(inout) :: self Kappa.","tags":"","loc":"module/wenoof_kappa_rec_js.html","title":"wenoof_kappa_rec_js – FORESEER"},{"text":"Uses: penf wenoof_alpha_factory wenoof_alpha_object wenoof_alpha_rec_js wenoof_alpha_rec_m wenoof_alpha_rec_z wenoof_base_object wenoof_beta_factory wenoof_beta_object wenoof_beta_rec_js wenoof_kappa_factory wenoof_kappa_object wenoof_kappa_rec_js wenoof_weights_object module~~wenoof_weights_js~~UsesGraph module~wenoof_weights_js wenoof_weights_js module~wenoof_weights_object wenoof_weights_object module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_beta_factory wenoof_beta_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_beta_object wenoof_beta_object module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_rec_js wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_kappa_factory wenoof_kappa_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~penf penf module~penf->module~wenoof_weights_js module~penf->module~wenoof_weights_object module~penf->module~wenoof_alpha_rec_z module~penf->module~wenoof_beta_factory module~penf->module~wenoof_beta_object module~penf->module~wenoof_kappa_factory module~penf->module~wenoof_alpha_factory module~penf->module~wenoof_kappa_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~penf->module~wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_m module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~penf->module~wenoof_alpha_object module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_weights_jsUsesGraph = svgPanZoom('#modulewenoof_weights_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu and Gerolymos-Senechal-Vallet weights. Note The provided WENO weights implements the weights defined in Efficient Implementation of Weighted ENO\n Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Used By module~~wenoof_weights_js~~UsedByGraph module~wenoof_weights_js wenoof_weights_js module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_weights_jsUsedByGraph = svgPanZoom('#modulewenoof_weights_jsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types weights_js weights_js_constructor Functions description smoothness_indicators Subroutines compute create destroy Derived Types type, public, extends( weights_object ) :: weights_js Jiang-Shu and Gerolymos-Senechal-Vallet weights object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. class( alpha_object ), public, allocatable :: alpha Alpha coefficients (non linear weights). class( beta_object ), public, allocatable :: beta Beta coefficients (smoothness indicators). real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( kappa_object ), public, allocatable :: kappa kappa coefficients (optimal, linear weights). real(kind=RPP), public, allocatable :: values (:,:) Weights values of stencil interpolations [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute weights. procedure, public, pass(self) :: create Create weights. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return weights string-description. procedure, public, pass(self) :: destroy Destroy weights. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. procedure, public, pass(self) :: smoothness_indicators Return smoothness indicators. type, public, extends( weights_object_constructor ) :: weights_js_constructor Jiang-Shu and Gerolymos-Senechal-Vallet optimal weights object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. class( alpha_object_constructor ), public, allocatable :: alpha_constructor Alpha coefficients (non linear weights) constructor. class( beta_object_constructor ), public, allocatable :: beta_constructor Beta coefficients (smoothness indicators) constructor. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( kappa_object_constructor ), public, allocatable :: kappa_constructor kappa coefficients (optimal, linear weights) constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return string-description of weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(in) :: self Weights. Return Value character(len=:),\n  allocatable String-description. private pure function smoothness_indicators (self) result(si) Return smoothness indicators.. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(in) :: self Weights. Return Value real(kind=RPP),\n  allocatable, (:,:) Smoothness indicators. Subroutines private pure subroutine compute (self, stencil) Compute weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. private subroutine create (self, constructor) Create reconstructor. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights. class( base_object_constructor ), intent(in) :: constructor Constructor. private elemental subroutine destroy (self) Destroy weights. Arguments Type Intent Optional Attributes Name class( weights_js ), intent(inout) :: self Weights.","tags":"","loc":"module/wenoof_weights_js.html","title":"wenoof_weights_js – FORESEER"},{"text":"Uses: iso_fortran_env penf wenoof_interpolator_object module~~wenoof_interpolator_js~~UsesGraph module~wenoof_interpolator_js wenoof_interpolator_js module~penf penf module~penf->module~wenoof_interpolator_js module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object iso_fortran_env iso_fortran_env iso_fortran_env->module~wenoof_interpolator_js module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~wenoof_interpolator_object->module~wenoof_interpolator_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_interpolations_object->module~wenoof_interpolator_object var panmodulewenoof_interpolator_jsUsesGraph = svgPanZoom('#modulewenoof_interpolator_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu (upwind) interpolator object. Derived Types interpolator_js interpolator_js_constructor Functions description Subroutines interpolate_debug interpolate_standard Derived Types type, public, extends( interpolator_object ) :: interpolator_js Jiang-Shu (upwind) interpolator object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. class( interpolations_object ), public, allocatable :: interpolations Stencil interpolations. class( weights_object ), public, allocatable :: weights Weights of interpolations. Type-Bound Procedures procedure(create_interface), public, pass(self) :: create Create object. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return interpolator string-description. procedure(destroy_interface), public, pass(self) :: destroy Destroy object. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. generic, public :: interpolate => interpolate_standard, interpolate_debug Interpolate values. procedure, public, pass(self) :: interpolate_debug Interpolate values (providing also debug values). procedure, public, pass(self) :: interpolate_standard Interpolate values (without providing debug values). type, public, extends( interpolator_object_constructor ) :: interpolator_js_constructor Jiang-Shu (upwind) interpolator object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. class( interpolations_object_constructor ), public, allocatable :: interpolations_constructor Stencil interpolations constructor. class( weights_object_constructor ), public, allocatable :: weights_constructor Weights of interpolations constructor. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return interpolator string-descripition. Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(in) :: self Interpolator. Return Value character(len=:),\n  allocatable String-description. Subroutines private pure subroutine interpolate_debug (self, stencil, interpolation, si, weights) Interpolate values (providing also debug values). Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2]. real(kind=RPP), intent(out) :: si (1:,0:) Computed values of smoothness indicators [1:2, 0:S-1]. real(kind=RPP), intent(out) :: weights (1:,0:) Weights of the stencils, [1:2, 0:S-1]. private pure subroutine interpolate_standard (self, stencil, interpolation) Interpolate values (without providing debug values). Arguments Type Intent Optional Attributes Name class( interpolator_js ), intent(inout) :: self Interpolator. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil of the interpolation [1:2, 1-S:-1+S]. real(kind=RPP), intent(out) :: interpolation (1:) Result of the interpolation, [1:2].","tags":"","loc":"module/wenoof_interpolator_js.html","title":"wenoof_interpolator_js – FORESEER"},{"text":"Uses: penf wenoof_alpha_object wenoof_base_object wenoof_beta_object wenoof_kappa_object module~~wenoof_alpha_rec_z~~UsesGraph module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_beta_object wenoof_beta_object module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_object module~penf penf module~penf->module~wenoof_alpha_rec_z module~penf->module~wenoof_beta_object module~penf->module~wenoof_alpha_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_kappa_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_alpha_rec_zUsesGraph = svgPanZoom('#modulewenoof_alpha_rec_zUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Borges alpha (non linear weights) object. Note The provided WENO alpha implements the alpha coefficients defined in An improved weighted essentially non-oscillatory\n scheme for hyperbolic conservation laws , Rafael Borges, Monique Carmona, Bruno Costa and Wai Sun Don, JCP, 2008,\n vol. 227, pp. 3191-3211, doi: 10.1016/j.jcp.2007.11.038. Used By module~~wenoof_alpha_rec_z~~UsedByGraph module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_weights_js wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_objects_factory wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_alpha_rec_zUsedByGraph = svgPanZoom('#modulewenoof_alpha_rec_zUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types alpha_rec_z alpha_rec_z_constructor Functions description tau weno_exp weno_odd Subroutines compute create destroy Derived Types type, public, extends( alpha_object ) :: alpha_rec_z Borges alpha (non linear weights) object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute alpha. procedure, public, pass(self) :: create Create alpha. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return alpha string-description. procedure, public, pass(self) :: destroy Destroy alpha. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, extends( alpha_object_constructor ) :: alpha_rec_z_constructor Borges alpha (non linear weights) object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(in) :: self Alpha coefficients. Return Value character(len=:),\n  allocatable String-description. private pure function tau (S, beta) result(w_tau) Compute the tau coefficient used in the WENO-Z alpha coefficients. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Number of stencils used. real(kind=RPP), intent(in) :: beta (0:S-1) Smoothness indicators. Return Value real(kind=RPP) Tau coefficient. private pure function weno_exp (S) result(w_exp) Compute the exponent used in the alpha function. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Number of stencils used. Return Value integer(kind=I_P) Exponent used in the alpha function. private pure function weno_odd (S) result(w_odd) Compute the distinguisher between odd and even number of stencils. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: S Number of stencils used. Return Value integer(kind=I_P) Distinguishing between odd and even number of stencils. Subroutines private pure subroutine compute (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. private subroutine create (self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. private elemental subroutine destroy (self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_z ), intent(inout) :: self Alpha.","tags":"","loc":"module/wenoof_alpha_rec_z.html","title":"wenoof_alpha_rec_z – FORESEER"},{"text":"Uses: penf wenoof_base_object wenoof_interpolations_object module~~wenoof_interpolations_rec_js~~UsesGraph module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf penf module~penf->module~wenoof_interpolations_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_interpolations_rec_jsUsesGraph = svgPanZoom('#modulewenoof_interpolations_rec_jsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. Note The provided interpolations implement the Lagrange interpolations defined in Efficient Implementation\n of Weighted ENO Schemes , Guang-Shan Jiang, Chi-Wang Shu, JCP, 1996, vol. 126, pp. 202–228, doi:10.1006/jcph.1996.0130 and Very-high-order weno schemes , G. A. Gerolymos, D. Senechal, I. Vallet, JCP, 2009, vol. 228, pp. 8481-8524,\n doi:10.1016/j.jcp.2009.07.039 Used By module~~wenoof_interpolations_rec_js~~UsedByGraph module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_interpolations_rec_jsUsedByGraph = svgPanZoom('#modulewenoof_interpolations_rec_jsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types interpolations_rec_js interpolations_rec_js_constructor Functions description Subroutines compute create destroy Derived Types type, public, extends( interpolations_object ) :: interpolations_rec_js Jiang-Shu (Lagrange) interpolations object for derivative reconstruction. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), private, allocatable :: coef (:,:,:) Polynomial coefficients [1:2,0:S-1,0:S-1]. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Stencil interpolations values [1:2,0:S-1]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute interpolations. procedure, public, pass(self) :: create Create interpolations. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return interpolations string-description. procedure, public, pass(self) :: destroy Destroy interpolations. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, extends( interpolations_object_constructor ) :: interpolations_rec_js_constructor Jiang-Shu (Lagrange) interpolations object for derivative reconstruction constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return interpolations string-description. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(in) :: self Interpolations. Return Value character(len=:),\n  allocatable String-description. Subroutines private pure subroutine compute (self, stencil) Compute interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. real(kind=RPP), intent(in) :: stencil (1:,1-self%S:) Stencil used for the interpolation, [1:2, 1-S:-1+S]. private subroutine create (self, constructor) Create interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations. class( base_object_constructor ), intent(in) :: constructor Interpolations constructor. private elemental subroutine destroy (self) Destroy interpolations. Arguments Type Intent Optional Attributes Name class( interpolations_rec_js ), intent(inout) :: self Interpolations.","tags":"","loc":"module/wenoof_interpolations_rec_js.html","title":"wenoof_interpolations_rec_js – FORESEER"},{"text":"Uses: penf wenoof_alpha_object wenoof_alpha_rec_js wenoof_alpha_rec_z wenoof_base_object wenoof_beta_object wenoof_kappa_object module~~wenoof_alpha_rec_m~~UsesGraph module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_base_object wenoof_base_object module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_beta_object wenoof_beta_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_kappa_object wenoof_kappa_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object wenoof_alpha_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_object module~penf penf module~penf->module~wenoof_alpha_rec_m module~penf->module~wenoof_base_object module~penf->module~wenoof_beta_object module~penf->module~wenoof_kappa_object module~penf->module~wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_z module~penf->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_alpha_rec_mUsesGraph = svgPanZoom('#modulewenoof_alpha_rec_mUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Henrick alpha (non linear weights) object. Note The provided alpha implements the alpha coefficients defined in Mapped weighted essentially non-oscillatory schemes:\n Achieving optimal order near critical points , Andrew K. Henrick, Tariq D. Aslam, Joseph M. Powers, JCP,\n 2005, vol. 207, pp. 542-567, doi:10.1016/j.jcp.2005.01.023 Used By module~~wenoof_alpha_rec_m~~UsedByGraph module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_weights_js wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_objects_factory wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_alpha_rec_mUsedByGraph = svgPanZoom('#modulewenoof_alpha_rec_mUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types alpha_rec_m alpha_rec_m_constructor Functions description Subroutines compute create destroy Derived Types type, public, extends( alpha_object ) :: alpha_rec_m Henrick alpha (non linear weights) object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. class( alpha_object ), public, allocatable :: alpha_base Base alpha to be re-mapped. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. integer(kind=I_P), public :: f1 = 1_I_P Lower bound of faces index. integer(kind=I_P), public :: f2 = 2_I_P Upper bound of faces index. integer(kind=I_P), public :: ff = 0_I_P Offset (step) of faces index. real(kind=RPP), public, allocatable :: values (:,:) Alpha coefficients [1:2,0:S-1]. real(kind=RPP), public, allocatable :: values_sum (:) Sum of alpha coefficients [1:2]. Type-Bound Procedures procedure, public, pass(self) :: compute Compute alpha. procedure, public, pass(self) :: create Create alpha. procedure, public, pass(self), non_overridable :: create_ Create object. procedure, public, pass(self) :: description Return alpha string-description. procedure, public, pass(self) :: destroy Destroy alpha. procedure, public, pass(self), non_overridable :: destroy_ Destroy object. type, public, extends( alpha_object_constructor ) :: alpha_rec_m_constructor Henrick alpha (non linear weights) object constructor. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: S = 0_I_P Stencils dimension. character(len=:), public, allocatable :: base_type Base alpha coefficient type. real(kind=RPP), public :: eps = EPS_DEF Small epsilon to avoid division by zero. logical, public :: face_left = .true. Activate left-face interpolation computation. logical, public :: face_right = .true. Activate right-face interpolation computation. Type-Bound Procedures procedure, public, pass(self) :: create => create_base_object_constructor Functions private pure function description (self) result(string) Return alpha string-descripition. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(in) :: self Alpha. Return Value character(len=:),\n  allocatable String-description. Subroutines private pure subroutine compute (self, beta, kappa) Compute alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. class( beta_object ), intent(in) :: beta Beta. class( kappa_object ), intent(in) :: kappa Kappa. private subroutine create (self, constructor) Create alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha. class( base_object_constructor ), intent(in) :: constructor Alpha constructor. private elemental subroutine destroy (self) Destroy alpha. Arguments Type Intent Optional Attributes Name class( alpha_rec_m ), intent(inout) :: self Alpha.","tags":"","loc":"module/wenoof_alpha_rec_m.html","title":"wenoof_alpha_rec_m – FORESEER"},{"text":"Uses: penf wenoof_kappa_object wenoof_kappa_rec_js module~~wenoof_kappa_factory~~UsesGraph module~wenoof_kappa_factory wenoof_kappa_factory module~penf penf module~penf->module~wenoof_kappa_factory module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_kappa_object var panmodulewenoof_kappa_factoryUsesGraph = svgPanZoom('#modulewenoof_kappa_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof kappa factory. Used By module~~wenoof_kappa_factory~~UsedByGraph module~wenoof_kappa_factory wenoof_kappa_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_kappa_factoryUsedByGraph = svgPanZoom('#modulewenoof_kappa_factoryUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types kappa_factory Subroutines create create_constructor Derived Types type, public :: kappa_factory Factory, create an instance of concrete extension of kappa_object given its constructor. Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of kappa_object . procedure, public, nopass :: create_constructor Create a concrete instance of kappa_object_constructor . Subroutines private subroutine create (constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. private subroutine create_constructor (interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor.","tags":"","loc":"module/wenoof_kappa_factory.html","title":"wenoof_kappa_factory – FORESEER"},{"text":"Uses: penf wenoof_alpha_object wenoof_beta_object wenoof_kappa_object wenoof_weights_object wenoof_weights_js module~~wenoof_weights_factory~~UsesGraph module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_alpha_object wenoof_alpha_object module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_weights_object wenoof_weights_object module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_beta_object wenoof_beta_object module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_factory wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_rec_js wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_m module~penf penf module~penf->module~wenoof_weights_factory module~penf->module~wenoof_weights_js module~penf->module~wenoof_alpha_object module~penf->module~wenoof_weights_object module~penf->module~wenoof_beta_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~penf->module~wenoof_alpha_rec_z module~penf->module~wenoof_beta_factory module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~penf->module~wenoof_alpha_factory module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~penf->module~wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_weights_factoryUsesGraph = svgPanZoom('#modulewenoof_weights_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof weights factory. Used By module~~wenoof_weights_factory~~UsedByGraph module~wenoof_weights_factory wenoof_weights_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_weights_factoryUsedByGraph = svgPanZoom('#modulewenoof_weights_factoryUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types weights_factory Subroutines create create_constructor Derived Types type, public :: weights_factory Factory, create an instance of concrete extension of weights_object given its constructor. Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of weights_object . procedure, public, nopass :: create_constructor Create a concrete instance of weights_object_constructor . Subroutines private subroutine create (constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. private subroutine create_constructor (interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations.","tags":"","loc":"module/wenoof_weights_factory.html","title":"wenoof_weights_factory – FORESEER"},{"text":"Uses: penf wenoof_interpolations_object wenoof_interpolator_object wenoof_reconstructor_js wenoof_weights_object module~~wenoof_interpolator_factory~~UsesGraph module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf penf module~penf->module~wenoof_interpolator_factory module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~wenoof_reconstructor_js iso_fortran_env->module~penf_stringify module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory var panmodulewenoof_interpolator_factoryUsesGraph = svgPanZoom('#modulewenoof_interpolator_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof interpolator factory. Used By module~~wenoof_interpolator_factory~~UsedByGraph module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmodulewenoof_interpolator_factoryUsedByGraph = svgPanZoom('#modulewenoof_interpolator_factoryUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types interpolator_factory Subroutines create create_constructor Derived Types type, public :: interpolator_factory Factory, create an instance of concrete extension of interpolator_object given its constructor. Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of interpolator_object . procedure, public, nopass :: create_constructor Create a concrete instance of interpolator_object_constructor . Subroutines private subroutine create (constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. private subroutine create_constructor (interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp.","tags":"","loc":"module/wenoof_interpolator_factory.html","title":"wenoof_interpolator_factory – FORESEER"},{"text":"Uses: penf wenoof_interpolations_object wenoof_interpolations_rec_js module~~wenoof_interpolations_factory~~UsesGraph module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~penf penf module~penf->module~wenoof_interpolations_factory module~penf->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_interpolations_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulewenoof_interpolations_factoryUsesGraph = svgPanZoom('#modulewenoof_interpolations_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof interpolations factory. Used By module~~wenoof_interpolations_factory~~UsedByGraph module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_interpolations_factoryUsedByGraph = svgPanZoom('#modulewenoof_interpolations_factoryUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types interpolations_factory Subroutines create create_constructor Derived Types type, public :: interpolations_factory Factory, create an instance of concrete extension of interpolations_object given its constructor. Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of interpolations_object . procedure, public, nopass :: create_constructor Create a concrete instance of interpolations_object_constructor . Subroutines private subroutine create (constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. private subroutine create_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp.","tags":"","loc":"module/wenoof_interpolations_factory.html","title":"wenoof_interpolations_factory – FORESEER"},{"text":"Uses: penf penf wenoof_alpha_factory wenoof_alpha_object wenoof_beta_factory wenoof_beta_object wenoof_kappa_factory wenoof_kappa_object wenoof_interpolations_factory wenoof_interpolations_object wenoof_interpolator_factory wenoof_interpolator_object wenoof_weights_factory wenoof_weights_object module~~wenoof_objects_factory~~UsesGraph module~wenoof_objects_factory wenoof_objects_factory module~wenoof_interpolations_factory wenoof_interpolations_factory module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_weights_object wenoof_weights_object module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_interpolator_object wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_alpha_object wenoof_alpha_object module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_weights_js module~penf penf module~penf->module~wenoof_objects_factory module~penf->module~wenoof_interpolations_factory module~penf->module~wenoof_weights_object module~penf->module~wenoof_alpha_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~penf->module~wenoof_alpha_factory module~penf->module~wenoof_weights_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~penf->module~wenoof_interpolator_object module~penf->module~wenoof_interpolator_factory module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~penf->module~wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_js module~penf->module~wenoof_weights_js module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~penf->module~wenoof_reconstructor_js module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_reconstructor_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_reconstructor_js->module~wenoof_interpolator_factory var panmodulewenoof_objects_factoryUsesGraph = svgPanZoom('#modulewenoof_objects_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof factory. Used By module~~wenoof_objects_factory~~UsedByGraph module~wenoof_objects_factory wenoof_objects_factory module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types objects_factory Subroutines create_alpha_object create_alpha_object_constructor create_beta_object create_beta_object_constructor create_interpolations_object create_interpolations_object_constructor create_interpolator create_interpolator_object create_interpolator_object_constructor create_kappa_object create_kappa_object_constructor create_weights_object create_weights_object_constructor Derived Types type, public :: objects_factory Factory, create an instance of concrete extension of base_object given its constructor. Type-Bound Procedures generic, public :: create => create_alpha_object, create_beta_object, create_kappa_object, create_interpolations_object, create_interpolator, create_interpolator_object, create_weights_object Create a concrete instance of alpha_object , beta_object , kappa_object , interpolations_object , interpolator_object or weights_object . procedure, private, nopass :: create_alpha_object Create alpha_object instance procedure, private, nopass :: create_alpha_object_constructor Create alpha_object_constructor instance. procedure, private, nopass :: create_beta_object Create beta_object instance. procedure, private, nopass :: create_beta_object_constructor Create beta_object_constructor instance. generic, public :: create_constructor => create_alpha_object_constructor, create_beta_object_constructor, create_kappa_object_constructor, create_interpolations_object_constructor, create_interpolator_object_constructor, create_weights_object_constructor Create a concrete instance of alpha_object_constructor , beta_object_constructor , kappa_object_constructor , interpolations_object_constructor , interpolator_object_constructor or weights_object_constructor . procedure, private, nopass :: create_interpolations_object Create interpolations_object instance. procedure, private, nopass :: create_interpolations_object_constructor Create interpolations_object_constructor inst. procedure, private, pass(self) :: create_interpolator Create interpolator_object instance. procedure, private, nopass :: create_interpolator_object Create interpolator_object instance. procedure, private, nopass :: create_interpolator_object_constructor Create interpolator_object_constructor inst. procedure, private, nopass :: create_kappa_object Create kappa_object instance. procedure, private, nopass :: create_kappa_object_constructor Create kappa_object_constructor instance. procedure, private, nopass :: create_weights_object Create weights_object instance. procedure, private, nopass :: create_weights_object_constructor Create weights_object_constructor instance. Subroutines private subroutine create_alpha_object (constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. private subroutine create_alpha_object_constructor (interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division. private subroutine create_beta_object (constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. private subroutine create_beta_object_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. private subroutine create_interpolations_object (constructor, object) Create an instance of concrete extension of interpolations_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolations_object_constructor ), intent(in) :: constructor Constructor. class( interpolations_object ), intent(out), allocatable :: object Object. private subroutine create_interpolations_object_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of interpolations_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp. private subroutine create_interpolator (self, interpolator_type, S, interpolator, face_left, face_right, eps) Create an instance of concrete extension of interpolator_object given user options. Arguments Type Intent Optional Attributes Name class( objects_factory ), intent(in) :: self The factory. character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolator_object ), intent(out), allocatable :: interpolator Interpolator. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/div. private subroutine create_interpolator_object (constructor, object) Create an instance of concrete extension of interpolator_object given its constructor. Arguments Type Intent Optional Attributes Name class( interpolator_object_constructor ), intent(in) :: constructor Constructor. class( interpolator_object ), intent(out), allocatable :: object Object. private subroutine create_interpolator_object_constructor (interpolator_type, S, interpolations_constructor, weights_constructor, constructor, face_left, face_right) Create an instance of concrete extension of interpolator_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( interpolations_object_constructor ), intent(in) :: interpolations_constructor Interpolations const. class( weights_object_constructor ), intent(in) :: weights_constructor Weights constructor. class( interpolator_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left interp. logical, intent(in), optional :: face_right Activate right interp. private subroutine create_kappa_object (constructor, object) Create an instance of concrete extension of kappa_object given its constructor. Arguments Type Intent Optional Attributes Name class( kappa_object_constructor ), intent(in) :: constructor Constructor. class( kappa_object ), intent(out), allocatable :: object Object. private subroutine create_kappa_object_constructor (interpolator_type, S, constructor) Create an instance of concrete extension of kappa_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( kappa_object_constructor ), intent(out), allocatable :: constructor Constructor. private subroutine create_weights_object (constructor, object) Create an instance of concrete extension of weights_object given its constructor. Arguments Type Intent Optional Attributes Name class( weights_object_constructor ), intent(in) :: constructor Constructor. class( weights_object ), intent(out), allocatable :: object Object. private subroutine create_weights_object_constructor (interpolator_type, S, alpha_constructor, beta_constructor, kappa_constructor, constructor, face_left, face_right) Create an instance of concrete extension of weights_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(in) :: alpha_constructor Alpha constructor. class( beta_object_constructor ), intent(in) :: beta_constructor Beta constructor. class( kappa_object_constructor ), intent(in) :: kappa_constructor kappa constructor. class( weights_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interp. logical, intent(in), optional :: face_right Activate right-face interp.","tags":"","loc":"module/wenoof_objects_factory.html","title":"wenoof_objects_factory – FORESEER"},{"text":"Uses: penf penf wenoof_alpha_object wenoof_alpha_rec_js wenoof_alpha_rec_m wenoof_alpha_rec_z module~~wenoof_alpha_factory~~UsesGraph module~wenoof_alpha_factory wenoof_alpha_factory module~penf penf module~penf->module~wenoof_alpha_factory module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_kappa_object var panmodulewenoof_alpha_factoryUsesGraph = svgPanZoom('#modulewenoof_alpha_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof alpha factory. Used By module~~wenoof_alpha_factory~~UsedByGraph module~wenoof_alpha_factory wenoof_alpha_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_alpha_factoryUsedByGraph = svgPanZoom('#modulewenoof_alpha_factoryUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types alpha_factory Subroutines create create_constructor Derived Types type, public :: alpha_factory Factory, create an instance of concrete extension of alpha_object given its constructor. Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of alpha_object . procedure, public, nopass :: create_constructor Create a concrete instance of alpha_object_constructor . Subroutines private subroutine create (constructor, object) Create an instance of concrete extension of alpha_object given its constructor. Arguments Type Intent Optional Attributes Name class( alpha_object_constructor ), intent(in) :: constructor Constructor. class( alpha_object ), intent(out), allocatable :: object Object. private subroutine create_constructor (interpolator_type, S, constructor, face_left, face_right, eps) Create an instance of concrete extension of alpha_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( alpha_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations. real(kind=RPP), intent(in), optional :: eps Small epsilon to avoid zero/division.","tags":"","loc":"module/wenoof_alpha_factory.html","title":"wenoof_alpha_factory – FORESEER"},{"text":"Uses: penf wenoof_beta_object wenoof_beta_rec_js module~~wenoof_beta_factory~~UsesGraph module~wenoof_beta_factory wenoof_beta_factory module~penf penf module~penf->module~wenoof_beta_factory module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_beta_rec_js module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_beta_object var panmodulewenoof_beta_factoryUsesGraph = svgPanZoom('#modulewenoof_beta_factoryUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Wenoof beta factory. Used By module~~wenoof_beta_factory~~UsedByGraph module~wenoof_beta_factory wenoof_beta_factory module~wenoof_objects_factory wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_weights_js wenoof_weights_js module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof wenoof module~wenoof_objects_factory->module~wenoof module~wenoof_weights_factory wenoof_weights_factory module~wenoof_weights_js->module~wenoof_weights_factory module~foreseer_euler_1d foreseer_euler_1d module~wenoof->module~foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_reconstructor_js wenoof_reconstructor_js module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_interpolator_factory wenoof_interpolator_factory module~wenoof_reconstructor_js->module~wenoof_interpolator_factory module~wenoof_interpolator_factory->module~wenoof_objects_factory var panmodulewenoof_beta_factoryUsedByGraph = svgPanZoom('#modulewenoof_beta_factoryUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types beta_factory Subroutines create create_constructor Derived Types type, public :: beta_factory Factory, create an instance of concrete extension of beta_object given its constructor. Type-Bound Procedures procedure, public, nopass :: create Create a concrete instance of beta_object . procedure, public, nopass :: create_constructor Create a concrete instance of beta_object_constructor . Subroutines private subroutine create (constructor, object) Create an instance of concrete extension of beta_object given its constructor. Arguments Type Intent Optional Attributes Name class( beta_object_constructor ), intent(in) :: constructor Constructor. class( beta_object ), intent(out), allocatable :: object Object. private subroutine create_constructor (interpolator_type, S, constructor, face_left, face_right) Create an instance of concrete extension of beta_object_constructor . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolator_type Type of the interpolator. integer(kind=I_P), intent(in) :: S Stencils dimension. class( beta_object_constructor ), intent(out), allocatable :: constructor Constructor. logical, intent(in), optional :: face_left Activate left-face interpolations. logical, intent(in), optional :: face_right Activate right-face interpolations.","tags":"","loc":"module/wenoof_beta_factory.html","title":"wenoof_beta_factory – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_pvl~~UsesGraph program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~penf penf module~penf->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_pvl vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_primitive_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_llf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer var panprogramforeseer_test_riemann_solver_compressible_pvlUsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_pvlUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible PVL class test. Calls program~~foreseer_test_riemann_solver_compressible_pvl~~CallsGraph program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl interface~str str program~foreseer_test_riemann_solver_compressible_pvl->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string var panprogramforeseer_test_riemann_solver_compressible_pvlCallsGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_pvlCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 Source Code foreseer_test_riemann_solver_compressible_pvl Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_pvl ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. Source Code program foreseer_test_riemann_solver_compressible_pvl !< FORESEER test: Riemann solver compressible PVL class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_pvl use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_pvl","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_pvl.html","title":"foreseer_test_riemann_solver_compressible_pvl – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_conservative_compressible~~UsesGraph program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~penf penf module~penf->program~foreseer_test_conservative_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer->program~foreseer_test_conservative_compressible vecfor vecfor vecfor->program~foreseer_test_conservative_compressible vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_primitive_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_llf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer var panprogramforeseer_test_conservative_compressibleUsesGraph = svgPanZoom('#programforeseer_test_conservative_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: conservative compressible class test. Calls program~~foreseer_test_conservative_compressible~~CallsGraph program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible proc~conservative_compressible_pointer conservative_compressible_pointer program~foreseer_test_conservative_compressible->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos f u u_pointer u_serialized velocity Source Code foreseer_test_conservative_compressible Variables Type Attributes Name Initial logical :: are_tests_passed (11) List of passed tests. type( eos_compressible ) :: eos An equation of state. type( conservative_compressible ) :: f Conservative fluxes. type( conservative_compressible ) :: u A conservative compressible instance. type( conservative_compressible ), pointer :: u_pointer A conservative compressible pointer. real(kind=R8P), allocatable :: u_serialized (:) Conservative variable serialized. type(vector) :: velocity Velocity vector. Source Code program foreseer_test_conservative_compressible !< FORESEER test: conservative compressible class test. use foreseer , only : eos_compressible , conservative_compressible , conservative_compressible_pointer use penf , only : R8P , ZeroR8 use vecfor , only : ex , vector implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( conservative_compressible ) :: u !< A conservative compressible instance. type ( conservative_compressible ), pointer :: u_pointer !< A conservative compressible pointer. type ( conservative_compressible ) :: f !< Conservative fluxes. type ( vector ) :: velocity !< Velocity vector. real ( R8P ), allocatable :: u_serialized (:) !< Conservative variable serialized. #ifdef __GFORTRAN__ logical :: are_tests_passed ( 11 ) !< List of passed tests. #else logical :: are_tests_passed ( 7 ) !< List of passed tests. #endif are_tests_passed = . false . call u % initialize are_tests_passed ( 1 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'u = 0, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) are_tests_passed ( 1 ) = ( u % pressure ( eos = eos ) >= 1._R8P - ZeroR8 ). and .( u % pressure ( eos = eos ) <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%pressure() = 1, is right? ' , are_tests_passed ( 1 ) velocity = u % velocity () are_tests_passed ( 2 ) = ( u % velocity () >= 0._R8P - ZeroR8 ). and .( u % velocity () <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%velocity() = 0, is right? ' , are_tests_passed ( 2 ) u_serialized = u % array () are_tests_passed ( 3 ) = ( size ( u_serialized , dim = 1 ) == 5 ). and . & ( u_serialized ( 1 ) == 1._R8P ). and . & ( u_serialized ( 2 ) == 0._R8P ). and . & ( u_serialized ( 3 ) == 0._R8P ). and . & ( u_serialized ( 4 ) == 0._R8P ). and . & ( u_serialized ( 5 ) == 2.5_R8P ) print \"(A,L1)\" , 'u => serialized, is done right? ' , are_tests_passed ( 3 ) call u % destroy are_tests_passed ( 4 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'u destroyed, is right? ' , are_tests_passed ( 4 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) call u % compute_fluxes ( eos = eos , normal = ex , fluxes = f ) are_tests_passed ( 5 ) = ( f % density >= 1._R8P - ZeroR8 ). and .( f % density <= 1._R8P + ZeroR8 ). and . & ( f % momentum >= 1.8_R8P - ZeroR8 ). and .( f % momentum <= 1.8_R8P + ZeroR8 ). and . & ( f % energy >= 3.3_R8P - ZeroR8 ). and .( f % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'compute fluxes along X, is done right? ' , are_tests_passed ( 5 ) u = f are_tests_passed ( 6 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 1.8_R8P - ZeroR8 ). and .( u % momentum <= 1.8_R8P + ZeroR8 ). and . & ( u % energy >= 3.3_R8P - ZeroR8 ). and .( u % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = f, is done right? ' , are_tests_passed ( 6 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u_pointer => conservative_compressible_pointer ( to = u ) are_tests_passed ( 7 ) = ( u_pointer % density >= 1._R8P - ZeroR8 ). and .( u_pointer % density <= 1._R8P + ZeroR8 ). and . & ( u_pointer % momentum >= 1._R8P - ZeroR8 ). and .( u_pointer % momentum <= 1._R8P + ZeroR8 ). and . & ( u_pointer % energy >= 2.5_R8P - ZeroR8 ). and .( u_pointer % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u => u, is done right? ' , are_tests_passed ( 7 ) #ifdef __GFORTRAN__ u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u = 2._R8P * u are_tests_passed ( 8 ) = ( u % density >= 2._R8P - ZeroR8 ). and .( u % density <= 2._R8P + ZeroR8 ). and . & ( u % momentum >= 2._R8P - ZeroR8 ). and .( u % momentum <= 2._R8P + ZeroR8 ). and . & ( u % energy >= 5._R8P - ZeroR8 ). and .( u % energy <= 5._R8P + ZeroR8 ) print \"(A,L1)\" , '2 * u, is done right? ' , are_tests_passed ( 8 ) u = u * u are_tests_passed ( 9 ) = ( u % density >= 4._R8P - ZeroR8 ). and .( u % density <= 4._R8P + ZeroR8 ). and . & ( u % momentum >= 4._R8P - ZeroR8 ). and .( u % momentum <= 4._R8P + ZeroR8 ). and . & ( u % energy >= 2 5._R8P - ZeroR8 ). and .( u % energy <= 2 5._R8P + ZeroR8 ) print \"(A,L1)\" , 'u * u, is done right? ' , are_tests_passed ( 9 ) u = u + u are_tests_passed ( 10 ) = ( u % density >= 8._R8P - ZeroR8 ). and .( u % density <= 8._R8P + ZeroR8 ). and . & ( u % momentum >= 8._R8P - ZeroR8 ). and .( u % momentum <= 8._R8P + ZeroR8 ). and . & ( u % energy >= 5 0._R8P - ZeroR8 ). and .( u % energy <= 5 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u + u, is done right? ' , are_tests_passed ( 10 ) u = u - u are_tests_passed ( 11 ) = ( u % density >= 0._R8P - ZeroR8 ). and .( u % density <= 0._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 0._R8P - ZeroR8 ). and .( u % energy <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u - u, is done right? ' , are_tests_passed ( 11 ) #endif print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_conservative_compressible","tags":"","loc":"program/foreseer_test_conservative_compressible.html","title":"foreseer_test_conservative_compressible – FORESEER"},{"text":"Uses: flap foodie foreseer foreseer_euler_1d penf vecfor program~~foreseer_test_shock_tube~~UsesGraph program~foreseer_test_shock_tube foreseer_test_shock_tube vecfor vecfor vecfor->program~foreseer_test_shock_tube module~foreseer_euler_1d foreseer_euler_1d vecfor->module~foreseer_euler_1d module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~penf penf module~penf->program~foreseer_test_shock_tube module~penf->module~foreseer_euler_1d module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~penf->module~foreseer_conservative_object module~penf->module~foreseer_riemann_solver_object module~penf->module~foreseer_primitive_object module~penf->module~foreseer_riemann_solver_compressible_object module~penf->module~foreseer_conservative_compressible module~penf->module~foreseer_primitive_compressible module~penf->module~foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_compressible_transformations module~penf->module~foreseer_riemann_solver_compressible_llf module~wenoof wenoof module~penf->module~wenoof module~wenoof_objects_factory wenoof_objects_factory module~penf->module~wenoof_objects_factory module~wenoof_interpolator_object wenoof_interpolator_object module~penf->module~wenoof_interpolator_object module~wenoof_interpolations_factory wenoof_interpolations_factory module~penf->module~wenoof_interpolations_factory module~wenoof_weights_object wenoof_weights_object module~penf->module~wenoof_weights_object module~wenoof_alpha_object wenoof_alpha_object module~penf->module~wenoof_alpha_object module~wenoof_beta_object wenoof_beta_object module~penf->module~wenoof_beta_object module~wenoof_kappa_factory wenoof_kappa_factory module~penf->module~wenoof_kappa_factory module~wenoof_alpha_factory wenoof_alpha_factory module~penf->module~wenoof_alpha_factory module~wenoof_weights_factory wenoof_weights_factory module~penf->module~wenoof_weights_factory module~wenoof_beta_factory wenoof_beta_factory module~penf->module~wenoof_beta_factory module~wenoof_interpolations_object wenoof_interpolations_object module~penf->module~wenoof_interpolations_object module~wenoof_kappa_object wenoof_kappa_object module~penf->module~wenoof_kappa_object module~wenoof_interpolator_factory wenoof_interpolator_factory module~penf->module~wenoof_interpolator_factory module~wenoof_interpolations_rec_js wenoof_interpolations_rec_js module~penf->module~wenoof_interpolations_rec_js module~wenoof_base_object wenoof_base_object module~penf->module~wenoof_base_object module~wenoof_kappa_rec_js wenoof_kappa_rec_js module~penf->module~wenoof_kappa_rec_js module~wenoof_alpha_rec_z wenoof_alpha_rec_z module~penf->module~wenoof_alpha_rec_z module~wenoof_alpha_rec_m wenoof_alpha_rec_m module~penf->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js wenoof_alpha_rec_js module~penf->module~wenoof_alpha_rec_js module~wenoof_weights_js wenoof_weights_js module~penf->module~wenoof_weights_js module~wenoof_beta_rec_js wenoof_beta_rec_js module~penf->module~wenoof_beta_rec_js module~wenoof_reconstructor_js wenoof_reconstructor_js module~penf->module~wenoof_reconstructor_js module~flap flap module~flap->program~foreseer_test_shock_tube module~foreseer foreseer module~foreseer->program~foreseer_test_shock_tube module~foreseer->module~foreseer_euler_1d module~foodie foodie module~foodie->program~foreseer_test_shock_tube module~foodie->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~face face iso_fortran_env->module~face iso_fortran_env->module~flap_object_t iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~wenoof_reconstructor_js module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~face->module~flap_command_line_interface_t module~face->module~flap_command_line_argument_t module~face->module~flap_command_line_arguments_group_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_emd_runge_kutta foodie_integrator_emd_runge_kutta module~foodie_integrator_emd_runge_kutta->module~foodie module~foodie_adt_integrand foodie_adt_integrand module~foodie_adt_integrand->module~foodie module~foodie_adt_integrand->module~foodie_integrator_euler_explicit module~foodie_adt_integrand->module~foodie_integrator_emd_runge_kutta module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_adt_integrand->module~foodie_integrator_leapfrog module~foodie_integrator_low_storage_runge_kutta foodie_integrator_low_storage_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_low_storage_runge_kutta module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_tvd_runge_kutta foodie_integrator_tvd_runge_kutta module~foodie_adt_integrand->module~foodie_integrator_tvd_runge_kutta module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_adt_integrand->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_adt_integrand->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_adt_integrand->module~foodie_integrator_adams_bashforth module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_low_storage_runge_kutta->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_tvd_runge_kutta->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds foodie_kinds module~foodie_kinds->module~foodie_integrator_euler_explicit module~foodie_kinds->module~foodie_integrator_emd_runge_kutta module~foodie_kinds->module~foodie_adt_integrand module~foodie_kinds->module~foodie_integrator_leapfrog module~foodie_kinds->module~foodie_integrator_low_storage_runge_kutta module~foodie_kinds->module~foodie_integrator_adams_bashforth_moulton module~foodie_kinds->module~foodie_integrator_tvd_runge_kutta module~foodie_kinds->module~foodie_integrator_backward_differentiation_formula module~foodie_kinds->module~foodie_integrator_adams_moulton module~foodie_kinds->module~foodie_integrator_adams_bashforth module~foodie_utils foodie_utils module~foodie_kinds->module~foodie_utils module~foodie_utils->module~foodie_integrator_euler_explicit module~foodie_utils->module~foodie_integrator_emd_runge_kutta module~foodie_utils->module~foodie_integrator_leapfrog module~foodie_utils->module~foodie_integrator_low_storage_runge_kutta module~foodie_utils->module~foodie_integrator_adams_bashforth_moulton module~foodie_utils->module~foodie_integrator_tvd_runge_kutta module~foodie_utils->module~foodie_integrator_backward_differentiation_formula module~foodie_utils->module~foodie_integrator_adams_moulton module~foodie_utils->module~foodie_integrator_adams_bashforth module~wenoof->module~foreseer_euler_1d module~wenoof_objects_factory->module~wenoof module~wenoof_interpolator_object->module~wenoof module~wenoof_interpolator_object->module~wenoof_objects_factory module~wenoof_interpolator_object->module~wenoof_interpolator_factory module~wenoof_interpolator_object->module~wenoof_reconstructor_js module~wenoof_interpolations_factory->module~wenoof_objects_factory module~wenoof_interpolations_factory->module~wenoof_reconstructor_js module~wenoof_weights_object->module~wenoof_objects_factory module~wenoof_weights_object->module~wenoof_interpolator_object module~wenoof_weights_object->module~wenoof_weights_factory module~wenoof_weights_object->module~wenoof_interpolator_factory module~wenoof_weights_object->module~wenoof_weights_js module~wenoof_weights_object->module~wenoof_reconstructor_js module~wenoof_alpha_object->module~wenoof_objects_factory module~wenoof_alpha_object->module~wenoof_alpha_factory module~wenoof_alpha_object->module~wenoof_weights_factory module~wenoof_alpha_object->module~wenoof_alpha_rec_z module~wenoof_alpha_object->module~wenoof_alpha_rec_m module~wenoof_alpha_object->module~wenoof_alpha_rec_js module~wenoof_alpha_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_objects_factory module~wenoof_beta_object->module~wenoof_alpha_object module~wenoof_beta_object->module~wenoof_weights_factory module~wenoof_beta_object->module~wenoof_beta_factory module~wenoof_beta_object->module~wenoof_alpha_rec_z module~wenoof_beta_object->module~wenoof_alpha_rec_m module~wenoof_beta_object->module~wenoof_alpha_rec_js module~wenoof_beta_object->module~wenoof_weights_js module~wenoof_beta_object->module~wenoof_beta_rec_js module~wenoof_kappa_factory->module~wenoof_objects_factory module~wenoof_kappa_factory->module~wenoof_weights_js module~wenoof_alpha_factory->module~wenoof_objects_factory module~wenoof_alpha_factory->module~wenoof_weights_js module~wenoof_weights_factory->module~wenoof_objects_factory module~wenoof_weights_factory->module~wenoof_reconstructor_js module~wenoof_beta_factory->module~wenoof_objects_factory module~wenoof_beta_factory->module~wenoof_weights_js module~wenoof_interpolations_object->module~wenoof_objects_factory module~wenoof_interpolations_object->module~wenoof_interpolator_object module~wenoof_interpolations_object->module~wenoof_interpolations_factory module~wenoof_interpolations_object->module~wenoof_interpolator_factory module~wenoof_interpolations_object->module~wenoof_interpolations_rec_js module~wenoof_interpolations_object->module~wenoof_reconstructor_js module~wenoof_kappa_object->module~wenoof_objects_factory module~wenoof_kappa_object->module~wenoof_alpha_object module~wenoof_kappa_object->module~wenoof_kappa_factory module~wenoof_kappa_object->module~wenoof_weights_factory module~wenoof_kappa_object->module~wenoof_kappa_rec_js module~wenoof_kappa_object->module~wenoof_alpha_rec_z module~wenoof_kappa_object->module~wenoof_alpha_rec_m module~wenoof_kappa_object->module~wenoof_alpha_rec_js module~wenoof_kappa_object->module~wenoof_weights_js module~wenoof_interpolator_factory->module~wenoof_objects_factory module~wenoof_interpolations_rec_js->module~wenoof_interpolations_factory module~wenoof_base_object->module~wenoof_interpolator_object module~wenoof_base_object->module~wenoof_weights_object module~wenoof_base_object->module~wenoof_alpha_object module~wenoof_base_object->module~wenoof_beta_object module~wenoof_base_object->module~wenoof_interpolations_object module~wenoof_base_object->module~wenoof_kappa_object module~wenoof_base_object->module~wenoof_interpolations_rec_js module~wenoof_base_object->module~wenoof_kappa_rec_js module~wenoof_base_object->module~wenoof_alpha_rec_z module~wenoof_base_object->module~wenoof_alpha_rec_m module~wenoof_base_object->module~wenoof_alpha_rec_js module~wenoof_base_object->module~wenoof_weights_js module~wenoof_base_object->module~wenoof_beta_rec_js module~wenoof_base_object->module~wenoof_reconstructor_js module~wenoof_kappa_rec_js->module~wenoof_kappa_factory module~wenoof_kappa_rec_js->module~wenoof_weights_js module~wenoof_alpha_rec_z->module~wenoof_alpha_factory module~wenoof_alpha_rec_z->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_z->module~wenoof_weights_js module~wenoof_alpha_rec_m->module~wenoof_alpha_factory module~wenoof_alpha_rec_m->module~wenoof_weights_js module~wenoof_alpha_rec_js->module~wenoof_alpha_factory module~wenoof_alpha_rec_js->module~wenoof_alpha_rec_m module~wenoof_alpha_rec_js->module~wenoof_weights_js module~wenoof_weights_js->module~wenoof_weights_factory module~wenoof_beta_rec_js->module~wenoof_beta_factory module~wenoof_beta_rec_js->module~wenoof_weights_js module~wenoof_reconstructor_js->module~wenoof_interpolator_factory var panprogramforeseer_test_shock_tubeUsesGraph = svgPanZoom('#programforeseer_test_shock_tubeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: shock tube tester, 1D Euler equation. Calls program~~foreseer_test_shock_tube~~CallsGraph program~foreseer_test_shock_tube foreseer_test_shock_tube interface~str str program~foreseer_test_shock_tube->interface~str proc~initialize~6 initialize program~foreseer_test_shock_tube->proc~initialize~6 proc~save_time_serie save_time_serie program~foreseer_test_shock_tube->proc~save_time_serie proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~parse_command_line_interface parse_command_line_interface proc~initialize~6->proc~parse_command_line_interface proc~save_time_serie->interface~str proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~save_time_serie->proc~conservative_to_primitive_compressible proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string interface~cton cton proc~parse_command_line_interface->interface~cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p var panprogramforeseer_test_shock_tubeCallsGraph = svgPanZoom('#programforeseer_test_shock_tubeCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dx Ni domain dt results riemann_solver_scheme rk_integrator rk_stage rk_stages_number s_scheme step steps_max t t_max t_scheme time_serie verbose weno_order weno_variables x Subroutines initialize parse_command_line_interface save_time_serie Source Code foreseer_test_shock_tube Variables Type Attributes Name Initial character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R8P) :: CFL CFL value. real(kind=R8P) :: Dx Space step discretization. integer(kind=I4P) :: Ni Number of grid cells. type( euler_1d ) :: domain Domain of Euler equations. real(kind=R8P) :: dt Time step. logical :: results Flag for activating results saving. character(len=99) :: riemann_solver_scheme Riemann Problem solver scheme. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. type( euler_1d ), allocatable :: rk_stage (:) Runge-Kutta stages. integer(kind=I4P) :: rk_stages_number Runge-Kutta stages number. character(len=99) :: s_scheme Space integration scheme. integer(kind=I4P) :: step Time steps counter. integer(kind=I4P) :: steps_max Maximum number of time steps. real(kind=R8P) :: t Time. real(kind=R8P) :: t_max Maximum integration time. character(len=99) :: t_scheme Time integration scheme. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I4P) :: weno_order WENO reconstruction order. character(len=:), allocatable :: weno_variables Variables set on which WENO reconstruction is done. real(kind=R8P), allocatable :: x (:) Cell center x-abscissa values. Subroutines subroutine initialize () Initialize the test. Arguments None subroutine parse_command_line_interface () Parse Command Line Interface (CLI). Arguments None subroutine save_time_serie (filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R8P), intent(in) :: t Current integration time. Source Code program foreseer_test_shock_tube !< FORESEER test: shock tube tester, 1D Euler equation. use flap , only : command_line_interface use foodie , only : tvd_runge_kutta_integrator use foreseer , only : conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible , & eos_compressible use foreseer_euler_1d , only : euler_1d use penf , only : cton , FR8P , I4P , R8P , str use vecfor , only : ex , vector implicit none integer ( I4P ) :: weno_order !< WENO reconstruction order. character ( len = :), allocatable :: weno_variables !< Variables set on which WENO reconstruction is done. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer ( I4P ) :: rk_stages_number !< Runge-Kutta stages number. type ( euler_1d ), allocatable :: rk_stage (:) !< Runge-Kutta stages. real ( R8P ) :: dt !< Time step. real ( R8P ) :: t !< Time. integer ( I4P ) :: step !< Time steps counter. type ( euler_1d ) :: domain !< Domain of Euler equations. real ( R8P ) :: CFL !< CFL value. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I4P ) :: Ni !< Number of grid cells. real ( R8P ) :: Dx !< Space step discretization. real ( R8P ), allocatable :: x (:) !< Cell center x-abscissa values. integer ( I4P ) :: steps_max !< Maximum number of time steps. real ( R8P ) :: t_max !< Maximum integration time. character ( 99 ) :: riemann_solver_scheme !< Riemann Problem solver scheme. character ( 99 ) :: s_scheme !< Space integration scheme. character ( 99 ) :: t_scheme !< Time integration scheme. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. call initialize call save_time_serie ( filename = 'euler_1D-' // trim ( adjustl ( s_scheme )) // '-' // trim ( adjustl ( t_scheme )) // '.dat' , t = t ) step = 0 time_loop : do step = step + 1 dt = domain % dt ( steps_max = steps_max , t_max = t_max , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) if ( verbose ) print \"(A)\" , 'step = ' // str ( n = step ) // ', time step = ' // str ( n = dt ) // ', time = ' // str ( n = t ) if (( t == t_max ). or .( step == steps_max )) exit time_loop enddo time_loop contains subroutine initialize () !< Initialize the test. type ( primitive_compressible ), allocatable :: initial_state (:) !< Initial state of primitive variables. integer ( I4P ) :: i !< Space counter. call parse_command_line_interface allocate ( rk_stage ( 1 : rk_stages_number )) call rk_integrator % init ( stages = rk_stages_number ) t = 0._R8P allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Ni )) Dx = 1._R8P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 1._R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 1._R8P enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 0.125_R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 0.1_R8P enddo call domain % initialize ( Ni = Ni , Dx = Dx , & BC_L = BC_L , BC_R = BC_R , & initial_state = initial_state , & eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ), & weno_order = weno_order , & weno_variables = weno_variables , & riemann_solver_scheme = riemann_solver_scheme ) endsubroutine initialize subroutine parse_command_line_interface () !< Parse Command Line Interface (CLI). type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I4P ) :: error !< Error handler. character ( len = :), allocatable :: buffer !< String buffer. call cli % init ( description = 'FORESEER test: shock tube tester, 1D Euler equations' , & examples = [ \"foreseer_test_shock_tube         \" , & \"foreseer_test_shock_tube --tserie\" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '60' ) call cli % add ( switch = '--t-max' , help = 'Maximum integration time' , required = . false ., act = 'store' , def = '0.' ) call cli % add ( switch = '--riemann' , help = 'Riemann Problem solver' , required = . false ., act = 'store' , def = 'llf' , choices = 'llf,pvl' ) call cli % add ( switch = '--s-scheme' , help = 'Space intergation scheme' , required = . false ., act = 'store' , def = 'weno-char-1' , & choices = 'weno-char-1,weno-char-3,weno-char-5,weno-char-7,weno-char-9,weno-char-11,weno-char-13,weno-char-15,weno-char-17,' // & 'weno-cons-1,weno-cons-3,weno-cons-5,weno-cons-7,weno-cons-9,weno-cons-11,weno-cons-13,weno-cons-15,weno-cons-17,' // & 'weno-prim-1,weno-prim-3,weno-prim-5,weno-prim-7,weno-prim-9,weno-prim-11,weno-prim-13,weno-prim-15,weno-prim-17' ) call cli % add ( switch = '--t-scheme' , help = 'Time intergation scheme' , required = . false ., act = 'store' , def = 'tvd-rk-1' , & choices = 'tvd-rk-1,tvd-rk-2,tvd-rk-3,tvd-rk-5' ) call cli % add ( switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.7' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-max' , val = t_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--riemann' , val = riemann_solver_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--s-scheme' , val = s_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-scheme' , val = t_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--cfl' , val = CFL , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop if ( t_max > 0._R8P ) steps_max = 0 buffer = trim ( adjustl ( s_scheme )) select case ( buffer ( 6 : 9 )) case ( 'char' ) weno_variables = 'characteristic' case ( 'cons' ) weno_variables = 'conservative' case ( 'prim' ) weno_variables = 'primitive' endselect weno_order = cton ( buffer ( 11 :), knd = 1_I4P ) select case ( trim ( adjustl ( t_scheme ))) case ( 'tvd-rk-1' ) rk_stages_number = 1 case ( 'tvd-rk-2' ) rk_stages_number = 2 case ( 'tvd-rk-3' ) rk_stages_number = 3 case ( 'tvd-rk-5' ) rk_stages_number = 5 endselect endsubroutine parse_command_line_interface subroutine save_time_serie ( filename , finish , t ) !< Save time-serie results. character ( * ), intent ( in ), optional :: filename !< Output filename. logical , intent ( in ), optional :: finish !< Flag for triggering the file closing. real ( R8P ), intent ( in ) :: t !< Current integration time. integer ( I4P ), save :: tsfile !< File unit for saving time serie results. type ( primitive_compressible ) :: primitive !< Primitive variables. integer ( I4P ) :: i !< Counter. if ( time_serie ) then if ( present ( filename )) then open ( newunit = tsfile , file = filename ) endif write ( tsfile , '(A)' ) 'VARIABLES = \"x\" \"rho\" \"u\" \"p\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni primitive = conservative_to_primitive_compressible ( conservative = domain % U ( i ), eos = domain % eos ) write ( tsfile , '(4' // '(' // FR8P // ',1X))' ) x ( i ), primitive % density , primitive % velocity % x , primitive % pressure enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif endsubroutine save_time_serie endprogram foreseer_test_shock_tube","tags":"","loc":"program/foreseer_test_shock_tube.html","title":"foreseer_test_shock_tube – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_llf~~UsesGraph program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~penf penf module~penf->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_llf vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_llf vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_primitive_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_llf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer var panprogramforeseer_test_riemann_solver_compressible_llfUsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_llfUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible LLF class test. Calls program~~foreseer_test_riemann_solver_compressible_llf~~CallsGraph program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf interface~str str program~foreseer_test_riemann_solver_compressible_llf->interface~str proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string var panprogramforeseer_test_riemann_solver_compressible_llfCallsGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_llfCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 Source Code foreseer_test_riemann_solver_compressible_llf Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_llf ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. Source Code program foreseer_test_riemann_solver_compressible_llf !< FORESEER test: Riemann solver compressible LLF class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_llf use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_llf","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_llf.html","title":"foreseer_test_riemann_solver_compressible_llf – FORESEER"},{"text":"Uses: foreseer penf program~~foreseer_test_eos_compressible~~UsesGraph program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~penf penf module~penf->program~foreseer_test_eos_compressible module~foreseer_eos_object foreseer_eos_object module~penf->module~foreseer_eos_object module~foreseer_eos_compressible foreseer_eos_compressible module~penf->module~foreseer_eos_compressible module~foreseer_conservative_object foreseer_conservative_object module~penf->module~foreseer_conservative_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~penf->module~foreseer_riemann_solver_object module~foreseer_primitive_object foreseer_primitive_object module~penf->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~penf->module~foreseer_conservative_compressible module~foreseer_primitive_compressible foreseer_primitive_compressible module~penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations module~penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~penf->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer->program~foreseer_test_eos_compressible module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible->module~foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer vecfor vecfor vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_primitive_object vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_llf var panprogramforeseer_test_eos_compressibleUsesGraph = svgPanZoom('#programforeseer_test_eos_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: equation of state compressible class test. Variables are_tests_passed eos Source Code foreseer_test_eos_compressible Variables Type Attributes Name Initial logical :: are_tests_passed (14) List of passed tests. type( eos_compressible ) :: eos An equation of state. Source Code program foreseer_test_eos_compressible !< FORESEER test: equation of state compressible class test. use foreseer , only : eos_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. logical :: are_tests_passed ( 14 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 1 ) = ( eos % gam () >= 1.4_R8P - ZeroR8 ). and .( eos % gam () <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%gam() = 1.4, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , gam = 1.4_R8P ) are_tests_passed ( 2 ) = ( eos % cv () >= 74 2.86_R8P - ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 2 ) eos = eos_compressible ( cv = 74 2.86_R8P , gam = 1.4_R8P ) are_tests_passed ( 3 ) = ( eos % R () >= 29 7.144_R8P - 1000 * ZeroR8 ). and .( eos % R () <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%R() = 297.144, is right? ' , are_tests_passed ( 3 ) eos = eos_compressible ( cv = 74 2.86_R8P , R = 29 7.144_R8P ) are_tests_passed ( 4 ) = ( eos % cp () >= 104 0.004_R8P - ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 4 ) eos = eos_compressible ( cp = 104 0.004_R8P , R = 29 7.144_R8P ) are_tests_passed ( 5 ) = ( eos % cv () >= 74 2.86_R8P - 1000 * ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 5 ) eos = eos_compressible ( gam = 1.4_R8P , R = 29 7.144_R8P ) are_tests_passed ( 6 ) = ( eos % cp () >= 104 0.004_R8P - 1000 * ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 6 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 7 ) = ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) >= 0.4_R8P - ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) <= 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, energy=1) = 0.4, is right? ' , are_tests_passed ( 7 ) are_tests_passed ( 8 ) = ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) >= 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, temperature=1) = 297.144, is right? ' , are_tests_passed ( 8 ) are_tests_passed ( 9 ) = ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) >= 1._R8P / 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) <= 1._R8P / 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, temperature=1) = 1/297.144, is right? ' , are_tests_passed ( 9 ) are_tests_passed ( 10 ) = ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, energy=1) = 1/0.4, is right? ' , are_tests_passed ( 10 ) are_tests_passed ( 11 ) = ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(density=1, pressure=1) = 1/0.4, is right? ' , are_tests_passed ( 11 ) are_tests_passed ( 12 ) = ( eos % energy ( temperature = 1._R8P ) >= 74 2.86_R8P - ZeroR8 ). and .& ( eos % energy ( temperature = 1._R8P ) <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(temperature=1) = 742.86, is right? ' , are_tests_passed ( 12 ) are_tests_passed ( 13 ) = ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 29 7.144_R8P - ZeroR8 ). and .& ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 29 7.144_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(density=1, pressure=1) = 1/297.144, is right? ' , are_tests_passed ( 13 ) are_tests_passed ( 14 ) = ( eos % temperature ( energy = 1._R8P ) >= 1._R8P / 74 2.86_R8P - ZeroR8 ). and .& ( eos % temperature ( energy = 1._R8P ) <= 1._R8P / 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(energy=1) = 1/742.86, is right? ' , are_tests_passed ( 14 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_eos_compressible","tags":"","loc":"program/foreseer_test_eos_compressible.html","title":"foreseer_test_eos_compressible – FORESEER"}]}